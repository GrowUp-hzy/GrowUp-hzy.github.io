<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>git学习笔记</title>
    <url>/2020/08/25/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h2><p><strong>linux</strong> </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install git</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>mac:  <a href="http://git-scm.com/download/mac">http://git-scm.com/download/mac</a></p>
<p>windows:  <a href="http://git-scm.com/download/win">http://git-scm.com/download/win</a></p>
<p>git官方文档:  <a href="https://git-scm.com/book/zh/v2">https://git-scm.com/book/zh/v2</a></p>
<p>Git安装完之后，需要做最后一步配置，如果你没有做这项配置，是没有git公钥和私钥的，而<strong>上传代码到远程仓库</strong>的时候需要秘钥进行验证是否本人上传的，想要创建可以使用下面的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">打开git bash，分别执行以下两句命令</span><br><span class="line">git config --global user.name “用户名”</span><br><span class="line">git config --global user.email “邮箱”</span><br></pre></td></tr></table></figure>

<p>config 的三个作用域</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--local 只对某个仓库有效</span><br><span class="line">--global 对当前用户所有仓库有效</span><br><span class="line">--system 对系统所有登录的用户有效</span><br><span class="line">--list</span><br></pre></td></tr></table></figure>



<h3 id="SSH配置"><a href="#SSH配置" class="headerlink" title="SSH配置"></a>SSH配置</h3><ol>
<li>打开git bash。</li>
<li>使用<code>cd ~/.ssh</code>可以查看是否已配置SSH。</li>
<li>执行生成公钥和私钥的命令<code>ssh-keygen -t rsa</code> 并按回车3下(为什么按三下，是因为有提示你是否需要设置密码，如果设置了每次使用Git都会用到密码，一般都是直接不写为空，直接回车就好了)。会在一个文件夹里面生成一个私钥 id_rsa和一个公钥id_rsa.pub。（可执行<code>start ~</code>命令，生成的公私钥在 .ssh的文件夹里面）。</li>
<li>.ssh如果不做特殊处理的话，一般是在<code>C:\Users\Administrator</code>目录下。如果看不到.ssh文件，可以使用<code>ls -ah</code>指令查看隐藏文件夹即可，这是存放秘钥的文件，打开这个文件会看到id_rsa和id_rsa.pub。id_rsa是私钥文件，id_rsa.pub是公钥文件。</li>
<li>执行查看公钥的命令<code>cat ~/.ssh/id_rsa.pub</code>  。</li>
</ol>
<h2 id="建Git仓库"><a href="#建Git仓库" class="headerlink" title="建Git仓库"></a>建Git仓库</h2><p>两种场景:</p>
<p>1.把已有的项目代码纳入Git管理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 项目代码所在的文件夹</span><br><span class="line">git init</span><br></pre></td></tr></table></figure>

<p>2.建立新的项目直接用Git管理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd 某个文件夹</span><br><span class="line">git init your_project #会在当前路径下创建和项目名相同的文件夹</span><br><span class="line">cd your_project</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir 创建目录</span><br><span class="line">echo &quot;&quot; &gt; 文件名 创建文件</span><br><span class="line">clear 清屏</span><br></pre></td></tr></table></figure>

<p>在仓库中添加文件</p>
<p>1.将文件拷贝到工作目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp ... .</span><br></pre></td></tr></table></figure>

<p>2.测试文件符合要求后添加到暂存目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add files</span><br><span class="line">git add -u 所有文件</span><br></pre></td></tr></table></figure>

<p>3.查看文件是否被git管理</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure>

<p>4.提交暂存区的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit -m&#x27;更改理由&#x27; -am&#x27;..&#x27;从工作区直接提交</span><br></pre></td></tr></table></figure>



<img src="https://i.loli.net/2020/08/25/zb1ZRmB3NkfMT2X.png" alt="image-20200122145213546" style="zoom: 50%;" />

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add 更新将要提交的内容</span><br><span class="line">git restore 放弃工作目录中的更改</span><br><span class="line">git rm 移除</span><br></pre></td></tr></table></figure>

<p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区</p>
<h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://i.loli.net/2020/08/25/OefR9gPFKqdC1hI.png" alt="img"></p>
<p><code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p><code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>给文件重名名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git mv old new</span><br><span class="line">操作完后commit提交</span><br></pre></td></tr></table></figure>

<p>查看版本历史,提交日志</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git log -n5 --oneline 最近5条 简明 </span><br><span class="line">git log --all --graph 所有分支 图像化关系</span><br></pre></td></tr></table></figure>

<p>版本历史图形化工具</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">查看分支</span><br><span class="line">git branch -v</span><br><span class="line">创建分支</span><br><span class="line">git checkout -b 分支名 commitid</span><br><span class="line">切换分支</span><br><span class="line">git checkout 分支名</span><br></pre></td></tr></table></figure>

<p>查看某个命令的帮助文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git help --web 命令  --web 在网页</span><br></pre></td></tr></table></figure>



<h2 id="git目录"><a href="#git目录" class="headerlink" title=".git目录"></a>.git目录</h2><p><strong>HEAD文件</strong>:指向了现在引用的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat HEAD</span><br><span class="line">ref: refs/heads/master</span><br></pre></td></tr></table></figure>

<p><strong>config文件</strong>:记录了用户的信息</p>
<p><strong>refs/</strong>:引用目录,包含了heads和tags目录</p>
<p>​    tags:标签 里程碑,项目开发到一定程度,给commit打一个标签如[v1.0] </p>
<p>​    标签文件是tag类型 本身有一个40位的哈希值 ,内容包含了一个commit的类型的object</p>
<p>​    heads:分支,如前后端建立独立的分支,互不影响,需要集成时可合并到一个公共的分支</p>
<p>​    查看文件对象类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat 分支文件</span><br><span class="line">git cat-file -t 哈希值</span><br><span class="line">-p 看内容</span><br><span class="line">如果哈希值足以保证唯一性可以使用短的一部分</span><br></pre></td></tr></table></figure>

<p>​    master文件为commit类型</p>
<p>​    git branch -av查看分支可以看到master分支引用指针就是heads目录中master文件的哈希值</p>
<p><strong>objects/</strong>:所有文件对象</p>
<p>git在每次commit的时候都会生成一个tree对象、一个parent对象（如果不是第一次提交的话）、和一个commit对象，这个最顶层的tree就是对应整个工作目录，tree下面还有blob、tree对象，都是一串hash值指向对应的内容，当某个文件发生变动的时候会重新保存一次快照（hash），如果文件没有发生变动，保留的快照依然是上次的。</p>
<p>松散对象 (loose object) 会被打包到pack/目录</p>
<p>查看文件对象类型 为:tree</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cat-file -t 文件名+哈希值</span><br></pre></td></tr></table></figure>

<p>查看内容 包含一个blob文件,就是提交的内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git cat-file -p 文件名+哈希值</span><br></pre></td></tr></table></figure>

<h2 id="git对象彼此的关系"><a href="#git对象彼此的关系" class="headerlink" title="git对象彼此的关系"></a>git对象彼此的关系</h2><img src="https://i.loli.net/2020/05/17/wkfcTLDnYlp89Xr.png" alt="image-20200128140710806" style="zoom: 50%;" />

<p>每一次提交都会创建一个commit对象,一个commit对象对应包含一个tree对象,tree代表了当前时间点仓库目录结构的快照,blob指具体的文件,在git中如果两个文件内容相同就看作一个文件,不论文件名</p>
<h2 id="git分离头指针"><a href="#git分离头指针" class="headerlink" title="git分离头指针"></a>git分离头指针</h2><p>如果不小心通过git checkout命令切换到某个commit中（即HEAD指向某个commit），git会提示我们正处于分离头指针的状态下（工作在没有分支的情况下），如果我们做了大量的修改，但是某天我们突然又切换到另一个commit时，我们的修改就有可能被git当做垃圾清除掉，因此这个动作十分危险。</p>
<p>分离头指针的用处：进行尝试性的变更时</p>
<p>试着修改某些文件时，如果觉得修改的效果不满意，可以直接切换到别的分支，丢弃当前修改</p>
<p>如果我们切换出去时，觉得当前的修改十分重要，就按照git的提示创建一个新分支</p>
<p>如果某个变更（提交）是非常重要的，那么一定要跟某个分支绑定在一起</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">创建新分支：</span><br><span class="line"></span><br><span class="line">git checkout -b  新分支名称  基于某个分支或者commit</span><br><span class="line"></span><br><span class="line">eg：git checkout -b newBranch master</span><br><span class="line"></span><br><span class="line">比较某两个commit的区别</span><br><span class="line"></span><br><span class="line">git diff 第一个commit 第二个commit</span><br><span class="line"></span><br><span class="line">eg：git diff HEAD HEAD^1  (当前的HEAD指向的commit和他的父级进行比对)</span><br><span class="line"></span><br><span class="line">HEAD^ ==HEAD~ == HEAD^1 == HEAD~1</span><br><span class="line"></span><br><span class="line">HEAD^^ == HEAD^1^1 == HEAD^2</span><br></pre></td></tr></table></figure>

<h2 id="删除不需要的分支"><a href="#删除不需要的分支" class="headerlink" title="删除不需要的分支"></a>删除不需要的分支</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch -D 分支名</span><br></pre></td></tr></table></figure>

<h2 id="修改commit的message"><a href="#修改commit的message" class="headerlink" title="修改commit的message"></a>修改commit的message</h2><p>对最近一次commit的message做变更</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git commit --amend </span><br></pre></td></tr></table></figure>

<p>更改之前的message</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i 需更改commit的父级id </span><br><span class="line">执行后进入编辑,把需要修改的一次message前面的&#x27;pick&#x27;改为&#x27;r&#x27;或&#x27;reword&#x27;,保存退出,会跳转到修改message</span><br></pre></td></tr></table></figure>

<h2 id="合并多个连续的commit"><a href="#合并多个连续的commit" class="headerlink" title="合并多个连续的commit"></a>合并多个连续的commit</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rebase -i 父级commitid</span><br><span class="line">执行后进入编辑,仅保留要合并到的commit的&#x27;pick&#x27;,把需要需要合并的几个&#x27;pick&#x27;改为&#x27;s&#x27;或&#x27;squash&#x27;,退出保存,修改说明</span><br></pre></td></tr></table></figure>

<h2 id="合并多个间隔的commit"><a href="#合并多个间隔的commit" class="headerlink" title="合并多个间隔的commit"></a>合并多个间隔的commit</h2><p>首先<code>git log --graph</code>查看commit历史</p>
<p>变基<code>git rebase -i 父commitid</code>进入vi</p>
<p>将父commitid拷贝进来并改变顺序,放在要合并的commit上面</p>
<p>要合并的commit的’pick’改为’s’</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pick acf475ed #父commit</span><br><span class="line">s 7ac3c1cb8b92 #要合并的commit</span><br><span class="line">...其他</span><br></pre></td></tr></table></figure>

<p>保存退出后报错:<code>interactive rebase in progress; onto 7ac3c1c</code></p>
<p>然后执行<code>git rebase --continue</code>继续变基,进入vi</p>
<p>怎加一个message,保存退出即可</p>
<p>其他参考:<a href="https://segmentfault.com/a/1190000007748862">https://segmentfault.com/a/1190000007748862</a></p>
<h2 id="git处理合并冲突"><a href="#git处理合并冲突" class="headerlink" title="git处理合并冲突"></a>git处理合并冲突</h2><p><strong>什么是合并冲突</strong></p>
<p>在 Git 中，“合并（merging）” 是在形式上整合别的分支到你当前的工作分支的操作。你需要得到在另外一个上下文背景下的改动（这就也就是我们所提到过的，一个有效的分支应该是建立在一个上下文工作背景上的），并且合并它们到你的当前的工作文件中来。</p>
<p>作为你的版本管理系统，Git 所带来的最伟大的改善就是它让合并操作变得非常轻松简单。在大多数情况下，Git 会自己弄清楚该如何整合这些新来的变化。</p>
<p>当然，也存在极少数的情况，你必须自己手动地告诉 Git 该怎么做。最为常见的就是大家都改动了同一个文件。即便在这种情况下，Git  还是有可能自动地发现并解决掉这些冲突。但是，如果两个人同时更改了同一个文件的同一行代码，或者一个人改动了那些被另一个人删除了的代码，Git  就不能简单地确定到底谁的改动才是正确的。这时 Git 会把这些地方标记为一个冲突，你必须首先解决掉这些冲突，然后再继续你的工作。<br> 如何解决合并冲突</p>
<p>当面对一个合并冲突时，我们首先要搞明白发生了什么。例如是不是你和你的同事都同时编辑了同一个文件的同一行代码呢？是不是他删除了一个你正在编辑的文件呢？是不是你们同时添加了一个相同文件名的文件呢？<br> 当你使用 “git status” 时， Git 会告诉你存在一个 “未合并的路径（unmerged paths）”，这只是用另外一个方式告诉你，存在一个或多个冲突：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> On branch contact-form</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> You have unmerged paths.</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Unmerged paths:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">   (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash">       both modified:   contact.html</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)1234567891011</span><br></pre></td></tr></table></figure>

<p>就让我们来深入地探讨一下，如何去解决这些最常见的冲突。<br> 当两个改动发生在同一个文件的同一些行上，我们就要看看发生冲突的文件的内容了。Git 会非常友好地把文件中那些有问题的区域在  “&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD” 和 “&gt;&gt;&gt;&gt;&gt;&gt;&gt;  [other/branch/name]” 之间标记出来。</p>
<p>第一个标记后的内容源于当前分支。在尖括号之后，Git 会告诉我们这些改动是从哪里（哪个分支）来的。然后有冲突的改动会被 “=======” 分割起来。<br> 现在，当清理文件并得到最终代码后，所有剩下的工作就是将这个结果保存起来，并且马上退出这个合并工具。这样 Git 就会知道你已经完成了这个操作。Git 会在后台对那个文件自动地执行 “git add” 命令。这也标志着冲突已经解决了。如果你<em>不</em>使用合并工具，而是手动在文本编辑器中清理这些冲突，你必须手动地将文件标记为已解决状态（通过执行命令 “git add ”）。</p>
<p>最终，当所有的冲突被解决后，你必须通过一个正常的提交操作来完成这个清理合并冲突的工作。</p>
<h2 id="如何撤销一个合并"><a href="#如何撤销一个合并" class="headerlink" title="如何撤销一个合并"></a>如何撤销一个合并</h2><p>你应该始终牢记，你可以在任何时间执行撤销操作，并返回到你开始合并之前的状态。要对自己有信心，你不会破坏项目中的任何东西。只要在命令行界面中键入 “git merge –abort” 命令，你的合并操作就会被安全的撤销。</p>
<p>当你解决完冲突，并且在合并完成后发现一个错误，你仍然还是有机会来简单地撤销它。你只须要键入 “git reset –hard ” 命令，系统就会回滚到那个合并开始前的状态，然后重新开始吧！</p>
<p>git status会有rebase in progress; onto ……这种问题？ 该怎么解决？</p>
<p>是你之前或者刚刚用过 <code>git rebase</code>，但上一次的进程还没有完成。</p>
<p>可以直接 <code>git rebase --abort</code> 来取消目前的进程</p>
<h2 id="比较暂存区和HEAD所含文件的差异"><a href="#比较暂存区和HEAD所含文件的差异" class="headerlink" title="比较暂存区和HEAD所含文件的差异"></a>比较暂存区和HEAD所含文件的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff --cached</span><br></pre></td></tr></table></figure>

<h2 id="比较工作区和暂存区所含文件的差异"><a href="#比较工作区和暂存区所含文件的差异" class="headerlink" title="比较工作区和暂存区所含文件的差异"></a>比较工作区和暂存区所含文件的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line">git diff -- 可加具体文件名</span><br></pre></td></tr></table></figure>

<h2 id="让暂存区恢复成和HEAD一样"><a href="#让暂存区恢复成和HEAD一样" class="headerlink" title="让暂存区恢复成和HEAD一样"></a>让暂存区恢复成和HEAD一样</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD</span><br></pre></td></tr></table></figure>

<h2 id="让工作区恢复为和暂存区一样"><a href="#让工作区恢复为和暂存区一样" class="headerlink" title="让工作区恢复为和暂存区一样"></a>让工作区恢复为和暂存区一样</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git checkout -- 文件名</span><br></pre></td></tr></table></figure>

<h2 id="取消暂存区部分文件的更改"><a href="#取消暂存区部分文件的更改" class="headerlink" title="取消暂存区部分文件的更改"></a>取消暂存区部分文件的更改</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset HEAD -- 文件名</span><br></pre></td></tr></table></figure>

<h2 id="消除最近几次的提交"><a href="#消除最近几次的提交" class="headerlink" title="消除最近几次的提交"></a>消除最近几次的提交</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git reset --hard commitid(想回到的commit状态)</span><br></pre></td></tr></table></figure>

<h2 id="查看不同提交的指定文件的差异"><a href="#查看不同提交的指定文件的差异" class="headerlink" title="查看不同提交的指定文件的差异"></a>查看不同提交的指定文件的差异</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git diff 分支名或commitid 分支名或commitid -- 指定文件</span><br></pre></td></tr></table></figure>

<h2 id="删除文件的正确做法"><a href="#删除文件的正确做法" class="headerlink" title="删除文件的正确做法"></a>删除文件的正确做法</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git rm 文件名</span><br></pre></td></tr></table></figure>

<h2 id="开发中临时加塞了紧急任务怎么处理"><a href="#开发中临时加塞了紧急任务怎么处理" class="headerlink" title="开发中临时加塞了紧急任务怎么处理"></a>开发中临时加塞了紧急任务怎么处理</h2><p>场景:开发中有一部分文件已经放到了暂存区,一部分还在工作区修改当中,但是测试发现对应的分支是有问题的,需要临时修复bug</p>
<p>1.先把手头的工作备份到其他地方<code>git stash</code>,可以用<code>git stash list</code>查看</p>
<p>2.修复完bug提交后再恢复继续</p>
<p><code>git stash apply  </code> stash列表中存放的文件仍会保留</p>
<p><code>git stash pop</code>stash列表中存放的文件会移除</p>
<h2 id="指定不需要Git管理的文件"><a href="#指定不需要Git管理的文件" class="headerlink" title="指定不需要Git管理的文件"></a>指定不需要Git管理的文件</h2><p>gitHub新建仓库时会让你配置一个<code>.gitignore</code>文件,针对不同的语言指定不被git管理的文件类型</p>
<p>只可以命名为<code>.gitignore</code></p>
<p>如java</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Compiled class file</span><br><span class="line">*.class</span><br><span class="line"># Package Files #</span><br><span class="line">*.jar</span><br><span class="line">*.war</span><br><span class="line">*.tar.gz</span><br><span class="line">*.zip</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="将Git仓库备份到本地"><a href="#将Git仓库备份到本地" class="headerlink" title="将Git仓库备份到本地"></a>将Git仓库备份到本地</h2><p>常用的传输协议</p>
<img src="https://i.loli.net/2020/08/25/cBJhQ4TCLmNA9xF.png" alt="image-20200129165637618" style="zoom:50%;" />

<p>哑协议与智能协议</p>
<p>直观区别:哑协议传输进度不可见,智能协议可见</p>
<p>传输速度:智能协议比哑协议块</p>
<p>推荐使用智能协议</p>
<p>备份特点:多点备份</p>
<img src="https://gomall-oss.oss-cn-beijing.aliyuncs.com/2020/08/25/0f4e90560ebd40d7989babbb3f7428fcimage-20200129170218098.png" alt="image-20200129170218098" style="zoom: 50%;" />

<p>如果要和远端的仓库进行关联的话,需要<code>remote</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git remote -v 查看</span><br><span class="line">git remote add 名字 地址 新建远端仓库</span><br></pre></td></tr></table></figure>

<p>当本地仓库有新的分支，而远端并未添加进去时，直接push</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push 远端仓库</span><br></pre></td></tr></table></figure>

<h2 id="Git远程操作"><a href="#Git远程操作" class="headerlink" title="Git远程操作"></a>Git远程操作</h2><h3 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h3><p>远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到<code>git clone</code>命令。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;版本库的网址&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，克隆jQuery的版本库。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> https://github.com/jquery/jquery.git</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为<code>git clone</code>命令的第二个参数。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;版本库的网址&gt; &lt;本地目录名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git clone</code>支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等</p>
<h3 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h3><p>为了便于管理，Git要求每个远程主机都必须指定一个主机名。<code>git remote</code>命令就用于管理主机名。</p>
<p>不带选项的时候，<code>git remote</code>命令列出所有远程主机。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">origin</span><br></pre></td></tr></table></figure>
</blockquote>
<p>使用<code>-v</code>选项，可以参看远程主机的网址。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin  git@github.com:jquery/jquery.git (fetch)</span><br><span class="line">origin  git@github.com:jquery/jquery.git (push)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。</p>
<p>克隆版本库的时候，所使用的远程主机自动被Git命名为<code>origin</code>。如果想用其他的主机名，需要用<code>git clone</code>命令的<code>-o</code>选项指定。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -o jQuery https://github.com/jquery/jquery.git</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line">jQuery</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，克隆的时候，指定远程主机叫做jQuery。</p>
<p><code>git remote show</code>命令加上主机名，可以查看该主机的详细信息。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote show &lt;主机名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote add</code>命令用于添加远程主机。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;主机名&gt; &lt;网址&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote rm</code>命令用于删除远程主机。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rm &lt;主机名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><code>git remote rename</code>命令用于远程主机的改名。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git remote rename &lt;原主机名&gt; &lt;新主机名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h3><p>一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到<code>git fetch</code>命令。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将某个远程主机的更新，全部取回本地。</p>
<p><code>git fetch</code>命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。</p>
<p>默认情况下，<code>git fetch</code>取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，取回<code>origin</code>主机的<code>master</code>分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如<code>origin</code>主机的<code>master</code>，就要用<code>origin/master</code>读取。</p>
<p><code>git branch</code>命令的<code>-r</code>选项，可以用来查看远程分支，<code>-a</code>选项查看所有分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line">origin/master</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">* master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，本地主机的当前分支是<code>master</code>，远程分支是<code>origin/master</code>。</p>
<p>取回远程主机的更新以后，可以在它的基础上，使用<code>git checkout</code>命令创建一个新的分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b newBrach origin/master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，在<code>origin/master</code>的基础上，创建一个新分支。</p>
<p>此外，也可以使用<code>git merge</code>命令或者<code>git rebase</code>命令，在本地分支上合并远程分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rebase origin/master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示在当前分支上，合并<code>origin/master</code>。</p>
<h3 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h3><p><code>git pull</code>命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>比如，取回<code>origin</code>主机的<code>next</code>分支，与本地的<code>master</code>分支合并，需要写成下面这样。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next:master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果远程分支是与当前分支合并，则冒号后面的部分可以省略。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin next</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，取回<code>origin/next</code>分支，再与当前分支合并。实质上，这等同于先做<code>git fetch</code>，再做<code>git merge</code>。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge origin/next</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在<code>git clone</code>的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的<code>master</code>分支自动”追踪”<code>origin/master</code>分支。</p>
<p>Git也允许手动建立追踪关系。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream master origin/next</span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令指定<code>master</code>分支追踪<code>origin/next</code>分支。</p>
<p>如果当前分支与远程分支存在追踪关系，<code>git pull</code>就可以省略远程分支名。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，本地的当前分支自动与对应的<code>origin</code>主机”追踪分支”（remote-tracking branch）进行合并。</p>
<p>如果当前分支只有一个追踪分支，连远程主机名都可以省略。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，当前分支自动与唯一一个追踪分支进行合并。</p>
<p>如果合并需要采用rebase模式，可以使用<code>--rebase</code>选项。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果远程主机删除了某个分支，默认情况下，<code>git pull</code> 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致<code>git pull</code>不知不觉删除了本地分支。</p>
<p>但是，你可以改变这个行为，加上参数 <code>-p</code> 就会在本地删除远程已经删除的分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull -p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch --prune origin </span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch -p</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h3><p><code>git push</code>命令用于将本地分支的更新，推送到远程主机。它的格式与<code>git pull</code>命令相仿。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以<code>git pull</code>是&lt;远程分支&gt;:&lt;本地分支&gt;，而<code>git push</code>是&lt;本地分支&gt;:&lt;远程分支&gt;。</p>
<p>如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将本地的<code>master</code>分支推送到<code>origin</code>主机的<code>master</code>分支。如果后者不存在，则会被新建。</p>
<p>如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin :master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示删除<code>origin</code>主机的<code>master</code>分支。</p>
<p>如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将当前分支推送到<code>origin</code>主机的对应分支。</p>
<p>如果当前分支只有一个追踪分支，那么主机名都可以省略。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>如果当前分支与多个主机存在追踪关系，则可以使用<code>-u</code>选项指定一个默认主机，这样后面就可以不加任何参数使用<code>git push</code>。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin master</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令将本地的<code>master</code>分支推送到<code>origin</code>主机，同时指定<code>origin</code>为默认主机，后面就可以不加任何参数使用<code>git push</code>了。</p>
<p>不带任何参数的<code>git push</code>，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用<code>git config</code>命令。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git config --global push.default matching</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global push.default simple</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用<code>--all</code>选项。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --all origin</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令表示，将所有本地分支都推送到<code>origin</code>主机。</p>
<p>如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做<code>git pull</code>合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用<code>--force</code>选项。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push --force origin </span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>上面命令使用<code>--force</code>选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用<code>--force</code>选项。</p>
<p>最后，<code>git push</code>不会推送标签（tag），除非使用<code>--tags</code>选项。</p>
<blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --tags</span></span><br></pre></td></tr></table></figure>

</blockquote>
]]></content>
      <categories>
        <category>代码管理</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>version control</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8学习笔记</title>
    <url>/2020/08/28/Java8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="Java8-函数式接口−"><a href="#Java8-函数式接口−" class="headerlink" title="Java8 函数式接口−"></a>Java8 <strong>函数式接口</strong>−</h2><p>函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。函数式接口可以被隐式转换为 lambda 表达式。</p>
<a id="more"></a>

<p><code>@FunctionalInterface</code>注解</p>
<ol>
<li><p>该注解只能标记在”有且仅有一个抽象方法”的接口上。</p>
</li>
<li><p>JDK8接口中的静态方法和默认方法，都不算是抽象方法。</p>
</li>
<li><p>接口默认继承Java.lang.Object，所以如果接口显示声明覆盖了Object中方法，那么也不算抽象方法。</p>
</li>
<li><p>该注解不是必须的，如果一个接口符合”函数式接口”定义，那么加不加该注解都没有影响。加上该注解能够更好地让编译器进行检查。如果编写的不是函数式接口，但是加上了@FunctionInterface，那么编译器会报错。</p>
</li>
<li><p>默认方法<strong>接口可以有实现方法，而且不需要实现类去实现其方法。</strong>目的是为了解决接口的修改与现有的实现不兼容的问题。</p>
</li>
</ol>
<p><strong>常用内置函数式接口</strong></p>
<p>java.uitl.function</p>
<p><strong>Supplier</strong>供给型接口:产生数据</p>
<p>无参数,有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Supplier</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Gets a result.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Consumer</strong>消费型接口:接收数据来使用</p>
<p>有参数,无返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Performs this operation on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Function</strong>加工型接口:得到一个数据返回另一个数据</p>
<p>有参数,有返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Applies this function to the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the function argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the function result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Predicate</strong>断言,判断型接口</p>
<p>有参数,返回true/false</p>
<p>and与 or或  negate非(取反)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Evaluates this predicate on the given argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t the input argument</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if the input argument matches the predicate,</span></span><br><span class="line"><span class="comment">     * otherwise &#123;<span class="doctag">@code</span> false&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"> <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>;</span><br></pre></td></tr></table></figure>



<h2 id="Lambda-表达式-−"><a href="#Lambda-表达式-−" class="headerlink" title="Lambda 表达式 −"></a><strong>Lambda 表达式</strong> −</h2><p> Lambda 允许把函数作为一个方法的参数（函数作为参数传递到方法中）。</p>
<ol>
<li><p>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</p>
</li>
<li><p>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</p>
</li>
<li><p>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</p>
</li>
<li><p>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。</p>
</li>
<li><p>lambda表达式的重点是延迟执行，如果需要直接执行，无需把它包装在lambda表达式当中。之所以希望以后执行原因如下：</p>
<pre><code>在一个单独的线程中运行代码；
多次运行代码；
在算法的适当位置运行代码（排序中的比较操作）；
发生某种情况是运行代码（点击按钮，数据到达）；
在必要时运行代码；</code></pre>
</li>
</ol>
<p><strong>优点 : lambda表达式让我们可以把一个方法当成参数传递进另一个方法，顶替匿名内部类消除了样板式代码。并让我们的代码看起来更加简洁、干净。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * lambda表达式对集合进行迭代</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    List&lt;String&gt; languages = Arrays.asList(<span class="string">&quot;java&quot;</span>,<span class="string">&quot;scala&quot;</span>,<span class="string">&quot;python&quot;</span>);</span><br><span class="line">    <span class="comment">//java8之前</span></span><br><span class="line">    <span class="keyword">for</span> (String each : languages)&#123;</span><br><span class="line">        System.out.println(each);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//java8之后</span></span><br><span class="line">    <span class="comment">//languages.forEach(x -&gt; System.out.println(x));</span></span><br><span class="line">    languages.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现setInterval</span></span><br><span class="line"><span class="comment"> * 每间隔指定的时间一次, 做些什么(也就是传入的A.func)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test1().setInterval(() -&gt; System.out.println(Math.random()),<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterval</span><span class="params">(A a,<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="comment">//在一个新的线程中执行防止线程阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                a.func();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="方法引用-−"><a href="#方法引用-−" class="headerlink" title="方法引用 −"></a>方法引用 −</h2><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p>
<p>​    <strong>如果Lambda表达式所要实现的代码,在其他地方已经存在相同方案,那么就可以使用方法引用</strong></p>
<p>​    <strong>方法引用就是让指定方法去实现接口的抽象方法</strong></p>
<p>​    <strong>常见引用方式</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">instanceName::methodName 对象::方法名</span><br><span class="line">ClassName::staticMethodName 类名::静态方法</span><br><span class="line">ClassName::methodName 类名::普通方法</span><br><span class="line">ClassName::new 类名::new (构造器)</span><br><span class="line">TypeName[]::new String[]::new(数组的构造器)</span><br></pre></td></tr></table></figure>

<p><strong>注意:引用的方法要和接口中抽象方法的参数一致,当接口的抽象方法有返回值时,被引用的方法也必须有返回值</strong></p>
<p> Java 中 4 种不同方法的引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对象::成员方法</span></span><br><span class="line"><span class="comment">     * 打印当前时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        Supplier&lt;Long&gt; supplier = now::getTime;</span><br><span class="line">        Long aLong = supplier.get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名::静态方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Supplier&lt;Long&gt; supplier = System::currentTimeMillis;</span><br><span class="line">        Long aLong = supplier.get();</span><br><span class="line">        System.out.println(aLong);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  类名::实例方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//求字符串长度</span></span><br><span class="line">        Function&lt;String,Integer&gt; func = String::length;</span><br><span class="line">        Integer length = func.apply(<span class="string">&quot;53º 40,6 N 008º 06,3 E&quot;</span>);</span><br><span class="line">        System.out.println(length);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//截取字符串</span></span><br><span class="line">        <span class="comment">/*BiFunction&lt;String,Integer,String&gt; func2 = (String str,Integer index) -&gt; &#123;</span></span><br><span class="line"><span class="comment">            //引用实例方法将第一个参数作为被引用方法的调用者</span></span><br><span class="line"><span class="comment">          return str.substring(index);</span></span><br><span class="line"><span class="comment">        &#125;;*/</span></span><br><span class="line">        BiFunction&lt;String,Integer,String&gt; func2 = String::substring;</span><br><span class="line">        String s = func2.apply(<span class="string">&quot;静谧于心，慎独于学&quot;</span>,<span class="number">5</span>);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类名::new构造器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test4</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//引用无参构造</span></span><br><span class="line">        Supplier&lt;Person&gt; supplier = Person::<span class="keyword">new</span>;</span><br><span class="line">        Person p1 = supplier.get();</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">        <span class="comment">//引用有参构造</span></span><br><span class="line">        BiFunction&lt;String,Integer,Person&gt; func = Person::<span class="keyword">new</span>;</span><br><span class="line">        Person p2 = func.apply(<span class="string">&quot;edc&quot;</span>, <span class="number">40</span>);</span><br><span class="line">        System.out.println(p2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型[]::new</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test5</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Function&lt;Integer,<span class="keyword">int</span>[]&gt; func = <span class="keyword">int</span>[]::<span class="keyword">new</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr = func.apply(<span class="number">10</span>);</span><br><span class="line">        System.out.println(Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="Stream-API-−"><a href="#Stream-API-−" class="headerlink" title="Stream API −"></a><strong>Stream API</strong> −</h2><p>新添加的Stream API（java.util.stream）<strong>以一种声明的方式处理数据。</strong> 把真正的函数式编程风格引入到Java中。</p>
<ol>
<li><p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
</li>
<li><p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
</li>
<li><p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
</li>
<li><p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。</p>
</li>
</ol>
<p><strong>什么是stream?</strong></p>
<ul>
<li>Stream（流）是一个来自数据源的元素队列并支持聚合操作。</li>
<li>元素是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。</li>
<li>数据源 流的来源。可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li>聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><p><strong>Pipelining</strong>: 中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</p>
</li>
<li><p><strong>内部迭代</strong>：以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</p>
</li>
</ul>
<p><strong>在 Java 8 中, 集合生成流的方式：</strong></p>
<p><strong>stream()</strong> − 通过集合接口默认方法为集合创建串行流。</p>
<p><strong>Stream.of()</strong>- Stream的默认方法创建流</p>
<p><strong>parallelStream()</strong> − 为集合创建并行流。</p>
<p><img src="https://i.loli.net/2020/07/15/eqf4Q5r9a8XSTvt.png" alt="image-20191230155712192"></p>
<p> <strong>API</strong>:</p>
<p><strong>forEach()</strong> 用来迭代流中的每个数据,以下代码片段使用 forEach 输出了10个随机数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>count()</strong> 方法用来统计元素的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;斯嘉丽.约翰逊&quot;</span>,<span class="string">&quot;迪丽热巴&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>,<span class="string">&quot;李子柒&quot;</span>);</span><br><span class="line"><span class="keyword">long</span> count = list.stream().count();</span><br></pre></td></tr></table></figure>

<p><strong>limit()</strong> 方法用于获取指定数量的流,以下代码片段使用 limit 方法打印出 10 条数据：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p> <strong>skip()</strong> 方法用于跳过前N个元素获取后面的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">Collections.addAll(list,<span class="string">&quot;斯嘉丽.约翰逊&quot;</span>,<span class="string">&quot;迪丽热巴&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>,<span class="string">&quot;李子柒&quot;</span>);</span><br><span class="line">list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>map()</strong> 方法用于映射每个元素到对应的结果, 以下代码片段使用 map 输出了元素对应的平方数：</p>
<p><strong>distinct()</strong> 去重 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line"><span class="comment">//获取对应的平方数</span></span><br><span class="line">List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//map()可以将一种类型的Stream流转换为另一种类型的Stream流</span></span><br><span class="line"><span class="comment">//将Stream&lt;String&gt;转换为Stream&lt;Integer&gt;</span></span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">Stream&lt;Integer&gt; integerStream = stringStream.map(Integer::parseInt);</span><br></pre></td></tr></table></figure>

<p><strong>distinct()</strong> 去重, 需要实现hascCode和equase方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//为String,int,自定义对象集合去重</span></span><br><span class="line">        Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">        stream1.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);</span><br><span class="line">        stream2.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象需要重写hascCode和equase方法</span></span><br><span class="line">        Stream&lt;Person&gt; personStream = Stream.of(</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;李清照&quot;</span>, <span class="number">18</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;李白&quot;</span>, <span class="number">30</span>),</span><br><span class="line">                <span class="keyword">new</span> Person(<span class="string">&quot;李白&quot;</span>, <span class="number">30</span>)</span><br><span class="line">        );</span><br><span class="line">        personStream.distinct().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p><strong>reduce()</strong> 将集合元素合为一个数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//T reduce(T identity,BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">      <span class="comment">//T identity 默认值</span></span><br><span class="line">      <span class="comment">//BinaryOperator&lt;T&gt; accumulator 继承BiFunction 对数据进行处理的方式</span></span><br><span class="line">      <span class="comment">//Integer reduce = Stream.of(5, 6, 7, 8, 9).reduce(0, Integer::sum);</span></span><br><span class="line">      Integer reduce = Stream.of(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">0</span>, (x, y) -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot;,y=&quot;</span> + y);</span><br><span class="line">          <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;);</span><br><span class="line">      System.out.println(reduce);</span><br></pre></td></tr></table></figure>

<p><strong>filter()</strong> 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hzy&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>);</span><br><span class="line"><span class="comment">//获取空字符串的数量</span></span><br><span class="line"><span class="keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<p><strong>sorted</strong> 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random random = <span class="keyword">new</span> Random();</span><br><span class="line">random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//sorted(Comparator&lt;? super T&gt; comparator)指定排序规则</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">88</span>, <span class="number">99</span>);</span><br><span class="line">integerStream.sorted((Integer i1,Integer i2) -&gt; i2 - i1<span class="comment">//降序</span></span><br><span class="line">        ).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>**match()**查看元素是否满足指定条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream = Stream.of(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">boolean</span> b = stream.allMatch((i -&gt; i &gt; <span class="number">0</span>));<span class="comment">//匹配所有元素,都满足条件true</span></span><br><span class="line"><span class="keyword">boolean</span> b1 = stream.anyMatch(i -&gt; i &gt; <span class="number">5</span>);<span class="comment">//匹配部分元素,有一个满足条件即true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = stream.noneMatch(i -&gt; i &lt; <span class="number">0</span>);<span class="comment">//匹配所有元素,都不满足条件为true</span></span><br></pre></td></tr></table></figure>

<p><strong>find()</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find()找到第一个元素</span></span><br><span class="line">      Stream&lt;Integer&gt; stream = Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>);</span><br><span class="line">      Optional&lt;Integer&gt; first = stream.findFirst();</span><br><span class="line">      System.out.println(first.get());</span><br></pre></td></tr></table></figure>

<p><strong>并行(parallel)程序</strong></p>
<p><strong>parallelStream</strong> 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hzy&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">//获取空字符串的数量</span></span><br><span class="line"><span class="keyword">long</span> count  = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure>

<p>Collectors 结合 collect()方法后使用 Collectors.joining(String 分隔符)方法变为分隔符分隔的字符串， Collectors.toList()方法变为集合：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>,<span class="string">&quot;edv&quot;</span>,<span class="string">&quot;jax&quot;</span>);</span><br><span class="line">List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line">String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br></pre></td></tr></table></figure>

<h2 id="Date-Time-API-−"><a href="#Date-Time-API-−" class="headerlink" title="Date Time API −"></a><strong>Date Time API</strong> −</h2><p> 加强对日期与时间的处理。</p>
<p>因为Java的Date，Calendar类型使用起来并不是很方便，而且Date类(据说)有着线程不安全等诸多弊端。同时若不进行封装，会在每次使用时特别麻烦。于是Java8推出了线程安全、简易、高可靠的时间包。并且数据库中也支持LocalDateTime类型，在数据存储时候使时间变得简单。Java8这次新推出的包括三个相关的时间类型：LocalDateTime年月日十分秒；LocalDate日期；LocalTime时间；三个包的方法都差不多。</p>
<p>常用API:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取当前时间的LocalDateTime对象</span></span><br><span class="line">LocalDateTime.now();</span><br><span class="line">String now = DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>).format(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//根据年月日构建LocalDateTime</span></span><br><span class="line">LocalDateTime.of(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//比较日期先后</span></span><br><span class="line">LocalDateTime.now().isBefore(),</span><br><span class="line">LocalDateTime.now().isAfter(),</span><br></pre></td></tr></table></figure>

<h2 id="Optional-类-−"><a href="#Optional-类-−" class="headerlink" title="Optional 类 −"></a><strong>Optional 类</strong> −</h2><p> Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</p>
<p> <strong>空指针异常是一个运行时异常，对于这一类异常，如果没有明确的处理策略，那么最佳实践在于让程序早点挂掉，但是很多场景下，不是开发人员没有具体的处理策略，而是根本没有意识到空指针异常的存在。</strong></p>
<p>1). 直观感受<br>假设我们需要返回一个字符串的长度，如果不借助第三方工具类，我们需要调用str.length()方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">null</span> == str) &#123; <span class="comment">// 空指针判定</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> str.length();</span><br></pre></td></tr></table></figure>


<p>如果采用Optional类，实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> Optional.ofNullable(str).map(String::length).orElse(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>2). 基本使用</p>
<ol>
<li>对象创建</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Optional&lt;String&gt; optStr = Optional.empty();</span><br></pre></td></tr></table></figure>

<p>上面的示例代码调用empty()方法创建了一个空的Optional对象型。</p>
<p>上面的示例代码调用empty()方法创建了一个空的Optional对象型。</p>
<p>创建对象：不允许为空<br>Optional提供了方法of()用于创建非空对象，该方法要求传入的参数不能为空，否则抛NullPointException，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当str为null的时候，将抛出NullPointException</span></span><br><span class="line">Optional&lt;String&gt; optStr = Optional.of(str); </span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建对象：允许为空<br> 如果不能确定传入的参数是否存在null值的可能性，则可以用Optional的ofNullable()方法创建对象，如果入参为null，则创建一个空对象。示例如下：</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果str是null，则创建一个空对象</span></span><br><span class="line">Optional&lt;String&gt; optStr = Optional.ofNullable(str); </span><br></pre></td></tr></table></figure>

<p>3.流式处理<br>流式处理也是java8给我们带来的一个重量级新特性，让我们对集合的操作变得更加简洁和高效。</p>
<p>这里Optional也提供了两个基本的流式处理：映射和过滤。</p>
<p>为了演示，我们设计了一个User类，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用户编号 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Optional&lt;Long&gt; phone;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Optional&lt;String&gt; email;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略setter和getter</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>映射：map与flatMap</strong></p>
<p><strong>映射是将输入转换成另外一种形式的输出的操作</strong></p>
<p>比如前面例子中，我们输入字符串，而输出的是字符串的长度，这就是一种映射，我们利用方法map()得以实现。假设我们希望获得一个人的姓名，那么我们可以如下实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = Optional.ofNullable(user).map(User::getName).orElse(<span class="string">&quot;no name&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>这样当入参user不为空的时候则返回其name，否则返回no name</p>
<p>如果我们希望通过上面方式得到phone或email，利用上面的方式则行不通了，因为map之后返回的是Optional，我们把这种称为Optional嵌套，我们必须在map一次才能拿到我们想要的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> phone = optUser.map(User::getPhone).map(Optional::get).orElse(-<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p>其实这个时候，更好的方式是利用flatMap，一步拿到我们想要的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> phone = optUser.flatMap(User::getPhone).orElse(-<span class="number">1L</span>);</span><br></pre></td></tr></table></figure>

<p><strong>过滤：fliter</strong></p>
<p><strong>fliter，顾名思义是过滤的操作，我们可以将过滤操作做为参数传递给该方法，从而实现过滤目的</strong></p>
<p>假如我们希望筛选18周岁以上的成年人，则可以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">optUser.filter(u -&gt; u.getAge() &gt;= <span class="number">18</span>).ifPresent(u -&gt; System.out.println(<span class="string">&quot;Adult:&quot;</span> + u));</span><br></pre></td></tr></table></figure>

<p>4.默认行为<br>默认行为是当Optional为不满足条件时所执行的操作，比如在上面的例子中我们使用的orElse()就是一个默认操作，用于在Optional对象为空时执行特定操作，当然也有一些默认操作是当满足条件的对象存在时执行的操作。</p>
<p>get()</p>
<p>get用于获取变量的值，但是当变量不存在时则会抛出NoSuchElementException，所以如果不确定变量是否存在，则不建议使用</p>
<p>orElse(Tother)</p>
<p>当Optional的变量不满足给定条件时，则执行orElse，比如前面当str为null时，返回0。</p>
<p>orElseGet(Supplier&lt;? extends X&gt; expectionSupplier)</p>
<p>如果条件不成立时，需要执行相对复杂的逻辑，而不是简单的返回操作，则可以使用orElseGet实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> phone = optUser.map(User::getPhone).map(Optional::get).orElseGet(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// do something here</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>orElseThrow(Supplier&lt;? extends X&gt; expectionSupplier)</p>
<p>与get()方法类似，都是在不满足条件时返回异常，不过这里我们可以指定返回的异常类型。</p>
<p>ifPresent(Consumer&lt;? super T&gt;)</p>
<p>当满足条件时执行传入的参数化操作。</p>
<p><strong>注意事项</strong></p>
<p>Optional是一个final类，未实现任何接口，所以当我们在利用该类包装定义类的属性的时候，如果我们定义的类有序列化的需求，那么因为Optional没有实现Serializable接口，这个时候执行序列化操作就会有问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 用户编号 */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Optional&lt;Long&gt; phone;  <span class="comment">// 不能序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Optional&lt;String&gt; email;  <span class="comment">// 不能序列化</span></span><br><span class="line"></span><br><span class="line">不过我们可以采用如下替换策略：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> phone;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;Long&gt; <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> Optional.ofNullable(<span class="keyword">this</span>.phone);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="将一个字符串转为小写-再转为大写"><a href="#将一个字符串转为小写-再转为大写" class="headerlink" title="将一个字符串转为小写,再转为大写"></a>将一个字符串转为小写,再转为大写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Consumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将一个字符串转为小写,再转为大写</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        printHello((str) -&gt; &#123;</span><br><span class="line">            System.out.println(str.toLowerCase());</span><br><span class="line">        &#125;,(str) -&gt; &#123;</span><br><span class="line">            System.out.println(str.toUpperCase());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printHello</span><span class="params">(Consumer&lt;String&gt; consumer1,Consumer&lt;String&gt; consumer2)</span></span>&#123;</span><br><span class="line">        String str =<span class="string">&quot;HELLO WORLD&quot;</span>;</span><br><span class="line">        consumer1.andThen(consumer2).accept(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将字符串转为数字-再乘5"><a href="#将字符串转为数字-再乘5" class="headerlink" title="将字符串转为数字,再乘5"></a>将字符串转为数字,再乘5</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.function.Function;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将字符串转为数字,再乘5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        getNumber((String str) -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;,(i) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> i*<span class="number">5</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getNumber</span><span class="params">(Function&lt;String,Integer&gt; function1,Function&lt;Integer,Integer&gt; function2)</span></span>&#123;</span><br><span class="line">        Integer num = function1.andThen(function2).apply(<span class="string">&quot;10&quot;</span>);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//forEach’ 来迭代流中的每个数据,以下代码片段使用 forEach 输出了10个随机数：</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//limit() 方法用于获取指定数量的流,以下代码片段使用 limit 方法打印出 10 条数据：</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    random.ints().limit(<span class="number">10</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//map() 方法用于映射每个元素到对应的结果, 以下代码片段使用 map 输出了元素对应的平方数：</span></span><br><span class="line">    List&lt;Integer&gt; numbers = Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>);</span><br><span class="line">    <span class="comment">//获取对应的平方数</span></span><br><span class="line">    List&lt;Integer&gt; squaresList = numbers.stream().map(i -&gt; i*i).distinct().collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//filter() 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hzy&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>);</span><br><span class="line">    <span class="comment">//获取空字符串的数量</span></span><br><span class="line">    <span class="keyword">long</span> count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：</span></span><br><span class="line">    Random random = <span class="keyword">new</span> Random();</span><br><span class="line">    random.ints().limit(<span class="number">10</span>).sorted().forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParallel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//parallelStream 是流并行处理程序的代替方法</span></span><br><span class="line">    <span class="comment">//使用 parallelStream 来输出空字符串的数量：</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;hzy&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="comment">//获取空字符串的数量</span></span><br><span class="line">    <span class="keyword">long</span> count  = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollectors</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//Collectors 结合 collect()方法后使用 Collectors.joining(String 分隔符)方法变为分隔符分隔的字符串，</span></span><br><span class="line">    <span class="comment">// Collectors.toList()方法变为集合：</span></span><br><span class="line">    List&lt;String&gt; strings = Arrays.asList(<span class="string">&quot;abc&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;edc&quot;</span>,<span class="string">&quot;edv&quot;</span>,<span class="string">&quot;jax&quot;</span>);</span><br><span class="line">    List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br><span class="line">    System.out.println(<span class="string">&quot;筛选列表: &quot;</span> + filtered);</span><br><span class="line">    String mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(<span class="string">&quot;:&quot;</span>));</span><br><span class="line">    System.out.println(<span class="string">&quot;合并字符串: &quot;</span> + mergedString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤集合"><a href="#过滤集合" class="headerlink" title="过滤集合"></a>过滤集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;EDC&quot;</span>,<span class="string">&quot;张家辉&quot;</span>,<span class="string">&quot;韩寒&quot;</span>,<span class="string">&quot;乔布斯&quot;</span>,<span class="string">&quot;张曼玉&quot;</span>);</span><br><span class="line">    <span class="comment">//1.拿到所有姓张的 2.名字长度为3的 3.打印这些数据</span></span><br><span class="line">    list.stream()</span><br><span class="line">            .filter((s -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> s.startsWith(<span class="string">&quot;张&quot;</span>);</span><br><span class="line">            &#125;))</span><br><span class="line">            .filter(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> s.length() == <span class="number">3</span>;</span><br><span class="line">            &#125;).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历集合"><a href="#遍历集合" class="headerlink" title="遍历集合"></a>遍历集合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testForEach</span><span class="params">()</span></span>&#123;<span class="comment">//遍历集合</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;泰戈尔&quot;</span>,<span class="string">&quot;雨果&quot;</span>,<span class="string">&quot;阿德勒&quot;</span>,<span class="string">&quot;普罗米修斯&quot;</span>);</span><br><span class="line">    list.stream().forEach((String s) -&gt; &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;);</span><br><span class="line">    list.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取元素个数"><a href="#获取元素个数" class="headerlink" title="获取元素个数"></a>获取元素个数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCount</span><span class="params">()</span></span>&#123;<span class="comment">//获取元素个数</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;斯嘉丽.约翰逊&quot;</span>,<span class="string">&quot;迪丽热巴&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>,<span class="string">&quot;李子柒&quot;</span>);</span><br><span class="line">    <span class="keyword">long</span> count = list.stream().count();</span><br><span class="line">    list.size();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="过滤符合条件的元素"><a href="#过滤符合条件的元素" class="headerlink" title="过滤符合条件的元素"></a>过滤符合条件的元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFilter</span><span class="params">()</span></span>&#123;<span class="comment">//过滤符合条件的元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;泰戈尔&quot;</span>,<span class="string">&quot;雨果&quot;</span>,<span class="string">&quot;阿德勒&quot;</span>,<span class="string">&quot;普罗米修斯&quot;</span>);</span><br><span class="line">    list.stream().filter(s -&gt; s.length() == <span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取前几个元素"><a href="#获取前几个元素" class="headerlink" title="获取前几个元素"></a>获取前几个元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLimit</span><span class="params">()</span></span>&#123;<span class="comment">//获取前3个元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;斯嘉丽.约翰逊&quot;</span>,<span class="string">&quot;迪丽热巴&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>,<span class="string">&quot;李子柒&quot;</span>);</span><br><span class="line">    list.stream().limit(<span class="number">3</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="跳过前几个元素"><a href="#跳过前几个元素" class="headerlink" title="跳过前几个元素"></a>跳过前几个元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSkip</span><span class="params">()</span></span>&#123;<span class="comment">//跳过前2个元素</span></span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Collections.addAll(list,<span class="string">&quot;斯嘉丽.约翰逊&quot;</span>,<span class="string">&quot;迪丽热巴&quot;</span>,<span class="string">&quot;王祖贤&quot;</span>,<span class="string">&quot;李子柒&quot;</span>);</span><br><span class="line">    list.stream().skip(<span class="number">2</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="转换stream流的类型"><a href="#转换stream流的类型" class="headerlink" title="转换stream流的类型"></a>转换stream流的类型</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMap</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//map()可以将一种类型的Stream流转换为另一种类型的Stream流</span></span><br><span class="line">    <span class="comment">//将Stream&lt;String&gt;转换为Stream&lt;Integer&gt;</span></span><br><span class="line">    Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;11&quot;</span>, <span class="string">&quot;22&quot;</span>, <span class="string">&quot;33&quot;</span>);</span><br><span class="line">    Stream&lt;Integer&gt; integerStream = stringStream.map(Integer::parseInt);</span><br><span class="line">    Stream&lt;Integer&gt; integerStream2 = stringStream.map((String str) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> Integer.parseInt(str);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="根据元素升序排序"><a href="#根据元素升序排序" class="headerlink" title="根据元素升序排序"></a>根据元素升序排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSorted</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//sorted()根据元素升序排序</span></span><br><span class="line">    <span class="comment">//sorted(Comparator&lt;? super T&gt; comparator)指定排序规则</span></span><br><span class="line">    Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">55</span>, <span class="number">88</span>, <span class="number">99</span>);</span><br><span class="line">    integerStream.sorted().forEach(System.out::println);<span class="comment">//升序</span></span><br><span class="line">    integerStream.sorted((Integer i1,Integer i2) -&gt; i2 - i1<span class="comment">//降序</span></span><br><span class="line">    ).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自定义对象集合去重"><a href="#自定义对象集合去重" class="headerlink" title="自定义对象集合去重"></a>自定义对象集合去重</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDistinct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//为String,int,自定义对象集合去重</span></span><br><span class="line">    Stream&lt;String&gt; stream1 = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>, <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    stream1.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    Stream&lt;Integer&gt; stream2 = Stream.of(<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>);</span><br><span class="line">    stream2.distinct().forEach(System.out::println);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对象需要重写hascCode和equase方法</span></span><br><span class="line">    Stream&lt;Person&gt; personStream = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;李清照&quot;</span>, <span class="number">18</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;李白&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;李白&quot;</span>, <span class="number">30</span>)</span><br><span class="line">    );</span><br><span class="line">    personStream.distinct().forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="判断元素是否符合条件"><a href="#判断元素是否符合条件" class="headerlink" title="判断元素是否符合条件"></a>判断元素是否符合条件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMatch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">boolean</span> b = stream.allMatch((i -&gt; i &gt; <span class="number">0</span>));<span class="comment">//匹配所有元素,都满足条件true</span></span><br><span class="line">    <span class="keyword">boolean</span> b1 = stream.anyMatch(i -&gt; i &gt; <span class="number">5</span>);<span class="comment">//匹配部分元素,有一个满足条件即true</span></span><br><span class="line">    <span class="keyword">boolean</span> b2 = stream.noneMatch(i -&gt; i &lt; <span class="number">0</span>);<span class="comment">//匹配所有元素,都不满足条件为true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="找到第一个元素"><a href="#找到第一个元素" class="headerlink" title="找到第一个元素"></a>找到第一个元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//findFirst()找到第一个元素</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>);</span><br><span class="line">    Optional&lt;Integer&gt; first = stream.findFirst();</span><br><span class="line">    System.out.println(first.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将集合元素聚合"><a href="#将集合元素聚合" class="headerlink" title="将集合元素聚合"></a>将集合元素聚合</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//将集合元素合为一个数据</span></span><br><span class="line">    <span class="comment">//T reduce(T identity,BinaryOperator&lt;T&gt; accumulator)</span></span><br><span class="line">    <span class="comment">//T identity 默认值</span></span><br><span class="line">    <span class="comment">//BinaryOperator&lt;T&gt; accumulator 继承BiFunction 对数据进行处理的方式</span></span><br><span class="line">    <span class="comment">//Integer reduce = Stream.of(5, 6, 7, 8, 9).reduce(0, Integer::sum);</span></span><br><span class="line">    Integer reduce = Stream.of(<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>).reduce(<span class="number">0</span>, (x, y) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;x=&quot;</span> + x + <span class="string">&quot;,y=&quot;</span> + y);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(reduce);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Map-和Reduce"><a href="#Map-和Reduce" class="headerlink" title="Map()和Reduce()"></a>Map()和Reduce()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMapAndReduce</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//求出所有年龄的总和</span></span><br><span class="line">    <span class="comment">//1.得到所有的年龄</span></span><br><span class="line">    <span class="comment">//2.求和</span></span><br><span class="line">    Integer sumAge = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;陈冠希&quot;</span>, <span class="number">40</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;韩寒&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;彭于晏&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    ).map((p) -&gt; &#123;<span class="comment">//1.得到所有的年龄</span></span><br><span class="line">        <span class="keyword">return</span> p.getAge();</span><br><span class="line">    &#125;).reduce(<span class="number">0</span>, (x, y) -&gt; &#123;<span class="comment">//2.求和</span></span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//简化版</span></span><br><span class="line">    <span class="comment">//.map(Person::getAge).reduce(0, Integer::sum);</span></span><br><span class="line">    System.out.println(<span class="string">&quot;年龄总和:&quot;</span>+sumAge+<span class="string">&quot;\n----------------&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求最大年龄</span></span><br><span class="line">    Integer maxAge = Stream.of(</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;陈冠希&quot;</span>, <span class="number">40</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;韩寒&quot;</span>, <span class="number">30</span>),</span><br><span class="line">            <span class="keyword">new</span> Person(<span class="string">&quot;彭于晏&quot;</span>, <span class="number">28</span>)</span><br><span class="line">    ).map(Person::getAge).reduce(<span class="number">0</span>,Integer::max);</span><br><span class="line">    System.out.println(<span class="string">&quot;最大年龄:&quot;</span>+maxAge+<span class="string">&quot;\n----------------&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//统计 a 出现的次数</span></span><br><span class="line">    Integer count = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .map(s -&gt; &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>.equals(s) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            &#125;).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="某个字符出现的次数"><a href="#某个字符出现的次数" class="headerlink" title="某个字符出现的次数"></a>某个字符出现的次数</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> count = Stream.of(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;a&quot;</span>)</span><br><span class="line">            .filter(s -&gt; s.equals(<span class="string">&quot;a&quot;</span>)).count();</span><br><span class="line">    System.out.println(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="将Stream中的数据收集到集合或数组"><a href="#将Stream中的数据收集到集合或数组" class="headerlink" title="将Stream中的数据收集到集合或数组"></a>将Stream中的数据收集到集合或数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将流中的数据收集到集合或数组中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCollect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span>, <span class="string">&quot;cc&quot;</span>);</span><br><span class="line">    <span class="comment">//收集到list</span></span><br><span class="line">    List&lt;String&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">    <span class="comment">//收集到set</span></span><br><span class="line">    Set&lt;String&gt; set = stream.collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//收集到hashSet</span></span><br><span class="line">    HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">//收集到ArrayList</span></span><br><span class="line">    ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>));</span><br><span class="line">    <span class="comment">//收集到Object数组</span></span><br><span class="line">    Object[] objects = stream.toArray();</span><br><span class="line">    <span class="comment">//收集到任意类型数组</span></span><br><span class="line">    String[] strings = stream.toArray(String[]::<span class="keyword">new</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并行流"><a href="#并行流" class="headerlink" title="并行流"></a>并行流</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testParallel</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 方式一:获取并行流</span></span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    Stream&lt;String&gt; stringStream = list.parallelStream();</span><br><span class="line">    <span class="comment">//方式二:串行流转为并行流</span></span><br><span class="line">    Stream&lt;Integer&gt; stream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;--并行流---&quot;</span>);</span><br><span class="line">    stream.parallel()<span class="comment">//转为并行流</span></span><br><span class="line">            .filter(i -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">                <span class="keyword">return</span> i &gt; <span class="number">3</span>;</span><br><span class="line">            &#125;).count();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;---串行流---&quot;</span>);</span><br><span class="line">    Stream.of(<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">1</span>,<span class="number">23</span>,<span class="number">55</span>).filter(i -&gt; &#123;</span><br><span class="line">        System.out.println(Thread.currentThread() + <span class="string">&quot;:&quot;</span> +i);</span><br><span class="line">        <span class="keyword">return</span> i &gt; <span class="number">3</span>;</span><br><span class="line">    &#125;).count();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实现setInterval"><a href="#实现setInterval" class="headerlink" title="实现setInterval()"></a>实现setInterval()</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test1().setInterval(() -&gt; System.out.println(Math.random()),<span class="number">1000L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInterval</span><span class="params">(A a,<span class="keyword">long</span> time)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="comment">//在一个新的线程中执行防止线程阻塞</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(time);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                a.func();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java基础</category>
        <category>Java新特性</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池学习笔记</title>
    <url>/2020/10/19/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p><strong>池化技术的好处</strong> </p>
<ol>
<li>降低资源消耗：可以重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度：当任务到达时，任务可以不需要等到线程创建就能立即执行。 </li>
<li>提高线程的可管理性：线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。<a id="more"></a>

</li>
</ol>
<p><strong>线程池的应用场景</strong></p>
<ol>
<li>服务器接受到大量请求时,使用线程池技术时非常合适的,它可以大大减少线程的创建和销毁次数,提高服务器的工作效率</li>
<li>实际上,在开发中,如果需要创建5个以上的线程,那么就可以使用线程池来管理</li>
</ol>
<p><strong>线程池的类关系图</strong></p>
<p><img src="https://i.loli.net/2020/06/21/qED6aYMo9GIJTc7.png" alt="image-20200621135143739"></p>
<h2 id="线程池的构造器参数"><a href="#线程池的构造器参数" class="headerlink" title="线程池的构造器参数"></a><strong>线程池的构造器参数</strong></h2><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>corePoolSize</td>
<td>int</td>
<td>核心线程数</td>
</tr>
<tr>
<td>maxPoolSize</td>
<td>int</td>
<td>最大线程数</td>
</tr>
<tr>
<td>keepAliveTime</td>
<td>long</td>
<td>保持存活时间</td>
</tr>
<tr>
<td>workQueue</td>
<td>BlockingQueue</td>
<td>任务存储队列</td>
</tr>
<tr>
<td>threadFactory</td>
<td>ThreadFactory</td>
<td>当线程池需要新的线程的时候,会使用threadFactory来生成新的线程</td>
</tr>
<tr>
<td>Handler</td>
<td>RejectedExecutionHandler</td>
<td>由于线程池无法接受所提交的任务的拒绝策略</td>
</tr>
</tbody></table>
<p><strong>corePoolSize和maxPoolSize</strong></p>
<ul>
<li><code>corePoolSize</code>指的是核心线程数:线程池在完成初始化后,默认情况下,还没有创建任何线程,线程池会等待有任务到来时,再创建新线程去执行任务,直到达到核心线程数,之后核心线程会一直保持这个数量;当任务数量超过核心线程数,将任务放在阻塞队列<code>workQueue</code>中,等待核心线程空闲后处理</li>
<li>如果核心线程全部在工作中,而且队列也满了,线程池就会在核心线程的基础上,额外增加一些线程,这些新增加的线程数最大上限就是<code>maxPoolSize</code></li>
</ul>
<p><img src="https://i.loli.net/2020/06/21/Z9WRJDTiGud25am.png" alt="image-20200621142929332"></p>
<p><strong>线程创建规则</strong></p>
<ol>
<li>如果线程数小于corePoolSize, 即使其他线程处于空闲状态,也会创建一个新线程(核心线程)来运行新任务</li>
<li>如果线程数等于(或大于)corePoolSize但少于maxPoolSize,则将任务放入队列</li>
<li>如果队列已满,并且线程数小于maxPoolSize,则创建一个新线程来运行任务</li>
<li>如果队列已满,并且线程数大于或等于maxPoolSize则拒绝该任务</li>
</ol>
<p><img src="https://i.loli.net/2020/09/10/jHp8ADB5tyfu1bI.jpg" alt="thread_pool"></p>
<p><strong>增减线程的特点</strong></p>
<ol>
<li>通过设置corePoolSize和maxPoolSize为相同数量,就可以创建固定大小的线程池,即使队列满了也不会在拓展线程</li>
<li>线程池希望保持较少的线程数,并且只有在负载变得很大时才增加它,这就是队列的用意</li>
<li>通过设置maxPoolSize为很高的只,例如Integer.MAX_VALUE,可以允许线程池容纳任意数量的并发任务</li>
<li>是只有在队列填满时才创建多于corePoolSize的线程,所以如果使用无界队列(例如LinkedBlockingQueue),那么线程数就不会超过corePoolSize</li>
</ol>
<p><strong>keepAliveTime</strong></p>
<p>空闲的非核心线程的存活时间,用于回收线程</p>
<ul>
<li>如果线程池当前的线程数多于corePoolSize,那么如果多余的线程空闲时间超过keepAliveTime,它们就会被终止</li>
</ul>
<p><strong>ThreadFactory</strong></p>
<p>线程工厂,用于创建线程</p>
<ul>
<li>新的线程是由ThreadFactory创建的,默认使用的线程工厂是<code>Executors.defaultThreadFactory()</code>,创建出来的线程都在同一个线程组,拥有同样的<code>NORM_PRIORITY</code>优先级并且都不是守护线程;如果自己定义ThreadFactory,那么就可以改变线程名,线程组,优先级,是否是守护线程等</li>
<li>通常使用默认的就可以,源码如下:</li>
</ul>
<p><img src="https://i.loli.net/2020/10/19/z1wWjDkSo5VLuG6.png" alt="image-20200621150205849"></p>
<p><strong>workQueue</strong></p>
<p>有三种最常见的队列类型:</p>
<ol>
<li>直接交接: SynchronousQueue 无容量</li>
<li>无界队列: LinkedBlockingQueue 无限容量,有内存溢出的风险</li>
<li>有界队列: ArrayBlockingQueue 可设置容量</li>
</ol>
<p><strong>ThreadPoolExecutor的启动</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  -通过 new 创建线程池时, 除非调用 prestartAllCoreThreads / prestartCoreThread 方法启动核心线程,</span></span><br><span class="line"><span class="comment">*  -否则即使工作队列中存在任务,同样也不会执行.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">8</span>, <span class="number">20</span>, <span class="number">3L</span>, TimeUnit.SECONDS, linkedBlockingDeque);</span><br><span class="line">		</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Starts all core threads, causing them to idly wait for work. This</span></span><br><span class="line"><span class="comment">* overrides the default policy of starting core threads only when</span></span><br><span class="line"><span class="comment">* new tasks are executed.</span></span><br><span class="line"><span class="comment">*	-启动所有核心线程，让它们无空闲的等待工作。 这将覆盖仅在执行新任务时启动核心线程的默认策略。</span></span><br><span class="line"><span class="comment">* -手动启动线程池.</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> the number of threads started</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">threadPoolExecutor.prestartAllCoreThreads();</span><br></pre></td></tr></table></figure>

<h2 id="JDK内置线程池"><a href="#JDK内置线程池" class="headerlink" title="JDK内置线程池"></a>JDK内置线程池</h2><p><strong>线程池应该手动创建还是自动创建</strong></p>
<p><strong>手动创建</strong>,可以让我们更加明确线程池的允许规则,避免资源耗尽的风险</p>
<p><strong>自动创建</strong>,也就是直接调用JDK封装号的构造函数,可能会带来一些问题:</p>
<p><code>Executors.newFixedThreadPool(int nThreads)</code>数量固定的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                     <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                     <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>corePoolSize和maxPoolSize被设置为相同的nThreads参数,并使用了无界队列LinkedBlockingQueue,不会拓展线程所以也没有存活时间</p>
<p>当任务在队列中堆积过多,可能就会造成OOM</p>
<p><code>Executors.newSingleThreadExecutor()</code>只有一个线程的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>Executors.newCachedThreadPool()</code> 可缓存线程</p>
<p>无界线程池,具有自动回收多余线程的功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>最大的线程数被设置为Integer.MAX_VALUE,线程空闲60秒后回收,不使用队列(SynchronousQueue)</p>
<p><code>Executors.newScheduledTreadPool()</code></p>
<p>支持定时及周期性任务执行的线程池,使用延迟队列(DelayedWorkQueue)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService threadPool =</span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//延迟5秒执行任务</span></span><br><span class="line">        threadPool.schedule(<span class="keyword">new</span> EveryTaskOneThread.Task(),<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">        <span class="comment">//1秒之后每个3秒执行一次任务</span></span><br><span class="line">        threadPool.scheduleAtFixedRate(<span class="keyword">new</span> EveryTaskOneThread.Task(),</span><br><span class="line">                <span class="number">1</span>, <span class="number">3</span>,TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以,还是更具业务的并发量手动创建线程池吧</p>
<p>JDK1.8后加入<code>workStealingPool</code></p>
<ul>
<li>子任务</li>
<li>窃取</li>
</ul>
<h2 id="线程数量怎么设定"><a href="#线程数量怎么设定" class="headerlink" title="线程数量怎么设定?"></a><strong>线程数量怎么设定?</strong></h2><ul>
<li><p>CPU密集型(加密,即使hash等) : 最佳线程数为CPU核心数的1-2倍左右</p>
</li>
<li><p>耗时I/O型(读写数据库,文件,网络传输等): 最佳线程数一般会大于CPU核心数很多倍,以JVM线程监控显示繁忙情况为依据,保证线程空闲可以衔接上,参考Brain Goetz推荐的计算方法:</p>
<p>==线程数=CPU核心数 * (1+平均等待时间/平均工作时间))==</p>
</li>
<li><p>实际上最靠谱的还是通过压力测试得出合适的线程数</p>
</li>
</ul>
<h2 id="停止线程池的正确方式"><a href="#停止线程池的正确方式" class="headerlink" title="停止线程池的正确方式"></a>停止线程池的正确方式</h2><ul>
<li><strong>shutdown</strong> 执行该方法后,线程池会将当前队列中的任务执行完毕,并且在次期间拒绝新任务进入,执行完后停止线程池</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        executorService.execute(<span class="keyword">new</span> ShutDownTask());</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(executorService.isShutdown());</span><br><span class="line">    Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">    <span class="comment">//是否进入停止状态</span></span><br><span class="line">    System.out.println(executorService.isShutdown());</span><br><span class="line">    <span class="comment">//拒绝新任务</span></span><br><span class="line">    executorService.execute(<span class="keyword">new</span> ShutDownTask());</span><br><span class="line">    <span class="comment">//是否真正意义上的关闭</span></span><br><span class="line">    System.out.println(executorService.isTerminated());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">500</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>awaitTermination(timeout)</code>:在一段时间内所有任务是否被执行完毕</p>
<ul>
<li>**shutdownNow ** 将所有线程中断,并且队列中还未执行的任务作为一个列表返回</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)&#123;</span><br><span class="line">            executorService.execute(<span class="keyword">new</span> ShutDownTask());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(executorService.isShutdown());</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">    	<span class="comment">//发送中断信号,并返回runnableList</span></span><br><span class="line">        List&lt;Runnable&gt; runnableList =</span><br><span class="line">                executorService.shutdownNow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutDownTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断了&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="任务拒绝策略"><a href="#任务拒绝策略" class="headerlink" title="任务拒绝策略"></a>任务拒绝策略</h2><ul>
<li><strong>拒绝时机</strong><ol>
<li>当Executor关闭(shutdown)时,提交新任务会被拒绝</li>
<li>当Executor对最大线程和队列容量使用有限制并且已经饱和时</li>
</ol>
</li>
</ul>
<p><strong>4种拒绝策略</strong></p>
<ul>
<li><p><strong>AbortPolicy</strong>: 默认,直接抛出RejectedExecutionException拒绝异常</p>
</li>
<li><p><strong>DiscardPolicy</strong>: 默默的把被拒绝的任务丢弃</p>
</li>
<li><p><strong>DiscardOldestPolicy</strong>: 当有新任务时,会丢弃任务队列中存在最久的老任务,以腾出位置给新任务</p>
</li>
<li><p><strong>CallerRunsPolicy</strong>: 将被线程池拒绝的任务交给调用者(caller)主线程去执行</p>
</li>
</ul>
<h2 id="钩子方法"><a href="#钩子方法" class="headerlink" title="钩子方法"></a>钩子方法</h2><p>每个任务执行前后可以增加处理(日志,统计)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 演示每个任务执行前后都可以放钩子函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PauseableTreadPool</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记线程是否处于暂停状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableTreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableTreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableTreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PauseableTreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写方法 before钩子</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(isPaused) &#123;</span><br><span class="line">                unpaused.await();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暂停方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//恢复方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//唤醒全部</span></span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        PauseableTreadPool pauseableTreadPool =</span><br><span class="line">                <span class="keyword">new</span> PauseableTreadPool(<span class="number">10</span>, <span class="number">20</span>,</span><br><span class="line">                <span class="number">10l</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingDeque&lt;&gt;());</span><br><span class="line"></span><br><span class="line">        Runnable runnable = <span class="keyword">new</span> Runnable() &#123; <span class="comment">//线程体</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;被执行&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">            pauseableTreadPool.execute(runnable);</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableTreadPool.pause();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池被暂停&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1500</span>);</span><br><span class="line">        pauseableTreadPool.resume();</span><br><span class="line">        System.out.println(<span class="string">&quot;线程池已恢复&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="原理-amp-源码分析"><a href="#原理-amp-源码分析" class="headerlink" title="原理&amp;源码分析"></a>原理&amp;源码分析</h2><p>主要分析ThreadPoolExecutor</p>
<p><strong>线程池的组成部分</strong></p>
<ul>
<li><p>线程池管理器 ExecutorService控制线程池的启动和停止</p>
</li>
<li><p>工作线程 ThreadPoolExecutor中的内部类Worker</p>
</li>
<li><p>任务队列 线程安全的<code>BlockingQueue&lt;Runnable&gt; workQueue;</code></p>
</li>
<li><p>任务接口(Task) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Worker(Runnable firstTask) &#123;</span><br><span class="line">    setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">    <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">    <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>线程池事项任务复用的原理</strong></p>
<ul>
<li>用相同的线程执行不同的任务</li>
</ul>
<p><strong>ThreadPoolExecutor中的execute方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在将来的某个时间执行给定的任务,任务可以在新线程或池中现有的线程中执行</span></span><br><span class="line"><span class="comment"> * 如果无法将任务提交执行,原因之一是执行器已关闭或由于其容量已满,该任务由当前的 RejectedExecutionHandler 处理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> command 要执行的任务</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Proceed in 3 steps:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 1. 如果工作线程数量少于corePoolSize,尝试调用addWorker以给定的command启动一个新线程</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 2.如果一个任务可以成功排队，那么我们仍然需要</span></span><br><span class="line"><span class="comment">     * 仔细检查我们是否应该添加线程</span></span><br><span class="line"><span class="comment">     * （因为现有的自上次检查后死亡）或</span></span><br><span class="line"><span class="comment">     * 自从进入此方法以来，该池已关闭。 所以我们</span></span><br><span class="line"><span class="comment">     * 重新检查状态，并在必要时回退排队</span></span><br><span class="line"><span class="comment">     * 停止，如果没有，则启动一个新线程。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 3.如果我们无法将任务排队，那么我们尝试添加一个新的</span></span><br><span class="line"><span class="comment">     * 线程。 如果失败，我们知道我们已经关闭或饱和</span></span><br><span class="line"><span class="comment">     * 并因此拒绝任务。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get(); <span class="comment">//ctl记录了线程池状态和线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123; <span class="comment">//循环获取任务执行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();</span><br><span class="line">                <span class="comment">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class="line">                <span class="comment">// if not, ensure thread is not interrupted.  This</span></span><br><span class="line">                <span class="comment">// requires a recheck in second case to deal with</span></span><br><span class="line">                <span class="comment">// shutdownNow race while clearing interrupt</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task);</span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="线程池的状态"><a href="#线程池的状态" class="headerlink" title="线程池的状态"></a>线程池的状态</h2><ul>
<li>RUNNING: 接受型任务并处理排队任务</li>
<li>SHUTDOWN: 不接受任务,但处理排队任务</li>
<li>STOP: 不接受新任务,也不处理排队任务,并中断正在进行的任务</li>
<li>TIDYING(整洁): 所有任务都已终止, workerCount为0时,线程会转换到TIDYING状态, 并将运行 terminate() 钩子方法</li>
<li>TERMINATED: terminate() 运行完成</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>

<h2 id="使用线程池的注意点"><a href="#使用线程池的注意点" class="headerlink" title="使用线程池的注意点"></a>使用线程池的注意点</h2><ul>
<li><p>避免任务的堆积</p>
<p> FixedThreadPool  SingleThreadExecutor<br> 任务队列长度过大, 可能会堆积大量的请求, 从而导致OOM.</p>
</li>
<li><p>避免线程数过度增加</p>
<p>CachedThreadPool ScheduledThreadPool<br>允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 </p>
</li>
<li><p>排查线程泄漏</p>
<p>线程已经执行完毕,却没有正确的被回收,往往是任务的逻辑问题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Java多线程</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>MVCC多版本并发控制</title>
    <url>/2021/04/02/MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="MVCC基本原理"><a href="#MVCC基本原理" class="headerlink" title="MVCC基本原理"></a>MVCC基本原理</h1><p>MVCC（Multi-Version Concurrent Control），即多版本并发控制协议，广泛使用于数据库系统。</p>
<a id="more"></a>

<p>在介绍MVCC概念之前，我们先来想一下数据库系统里的一个问题：假设有多个用户同时读写数据库里的一行记录，那么怎么保证数据的一致性呢？一个基本的解决方法是对这一行记录加上一把锁，将不同用户对同一行记录的读写操作完全串行化执行，由于同一时刻只有一个用户在操作，因此一致性不存在问题。但是，它存在明显的性能问题：读会阻塞写，写也会阻塞读，整个数据库系统的并发性能将大打折扣。</p>
<p>MVCC（Multi-Version Concurrent Control），即多版本并发控制协议，它的目标是在保证数据一致性的前提下，提供一种高并发的访问性能。在MVCC协议中，每个用户在连接数据库时看到的是一个具有一致性状态的镜像，每个事务在提交到数据库之前对其他用户均是不可见的。当事务需要更新数据时，不会直接覆盖以前的数据，而是生成一个新的版本的数据，因此一条数据会有多个版本存储，但是同一时刻只有最新的版本号是有效的。因此，读的时候就可以保证总是以当前时刻的版本的数据可以被读到，不论这条数据后来是否被修改或删除。</p>
<hr>
<p>在并发读写数据库时，读操作可能会不一致的数据（脏读）。为了避免这种情况，需要实现数据库的并发访问控制，最简单的方式就是加锁访问。由于，加锁会将读写操作串行化，所以不会出现不一致的状态。但是，读操作会被写操作阻塞，大幅降低读性能。在java concurrent包中，有copyonwrite系列的类，专门用于<strong>优化读远大于写</strong>的情况。而其优化的手段就是，在进行写操作时，将数据copy一份，不会影响原有数据，然后进行修改，修改完成后原子替换掉旧的数据，而读操作只会读取原有数据。通过这种方式实现写操作不会阻塞读操作，从而优化读效率。而写操作之间是要互斥的，并且每次写操作都会有一次copy，所以只适合读大于写的情况。</p>
<p> MVCC的原理与copyonwrite类似，全称是Multi-Version Concurrent Control，即多版本并发控制。在MVCC协议下，每个读操作会看到一个一致性的snapshot(快照)，并且可以实现非阻塞的读。MVCC允许数据具有多个版本，这个版本可以是时间戳或者是全局递增的事务ID，在同一个时间点，不同的事务看到的数据是不同的。</p>
<p> 实现原理： </p>
<p> ——————————————————————————————&gt; 时间轴</p>
<p> |——-R(T1)—–|</p>
<p> |———–U(T2)———–|</p>
<p> 如上图，假设有两个并发操作R(T1)和U(T2)，T1和T2是事务ID，T1小于T2，系统中包含数据a = 1(T1)，R和W的操作如下：</p>
<p> R：read a (T1)</p>
<p> U：a = 2   (T2)</p>
<p> R（读操作）的版本T1表示要读取数据的版本，而之后写操作才会更新版本，读操作不会。在时间轴上，R晚于U，而由于U在R开始之后提交，所以对于R是不可见的。所以，R只会读取T1版本的数据，即a = 1。</p>
<p> 由于在update操作提交之前，不能影响已有数据的一致性，所以不会改变旧的数据，update操作会被拆分成insert + delete。需要标记删除旧的数据，insert新的数据。只有update提交之后，才会影响后续的读操作。而对于读操作而且，只能读到在其之前的所有的写操作，正在执行中的写操作对其是不可见的。</p>
<p>上面说了一堆的虚的理论，下面来点干活，看一下<a href="https://yq.aliyun.com/go/articleRenderRedirect?url=http://lib.csdn.net/base/14">MySQL</a>的innodb引擎是如何实现MVCC的。</p>
<p>innodb会为每一行添加两个字段，分别表示该行<strong>创建的版本</strong>和<strong>删除的版本</strong>，填入的是事务的版本号，这个版本号随着事务的创建不断递增。在repeated read的隔离级别（<a href="https://yq.aliyun.com/go/articleRenderRedirect?spm=a2c4e.11153940.0.0.1a4a7f4eKAPANh&url=http://blog.csdn.net/chosen0ne/article/details/10036775">事务的隔离级别请看这篇文章</a>）下，具体各种数据库操作的实现：</p>
<p> <strong>select</strong>：满足以下两个条件innodb会返回该行数据：</p>
<p>（1）该行的创建版本号小于等于当前版本号，用于保证在select操作之前所有的操作已经执行落地。</p>
<p>（2）该行的删除版本号大于当前版本或者为空。删除版本号大于当前版本意味着有一个并发事务将该行删除了。</p>
<p> <strong>insert</strong>：将新插入的行的创建版本号设置为当前系统的版本号。</p>
<p> <strong>delete</strong>：将要删除的行的删除版本号设置为当前系统的版本号。</p>
<p> <strong>update</strong>：不执行原地update，而是转换成insert + delete。将旧行的删除版本号设置为当前版本号，并将新行insert同时设置创建版本号为当前版本号。</p>
<p> 其中，写操作（insert、delete和update）执行时，需要将系统版本号递增。</p>
<p>由于旧数据并不真正的删除，所以必须对这些数据进行清理，innodb会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做<strong>purge</strong>。</p>
<p> 通过MVCC很好的实现了事务的隔离性，可以达到repeated read级别，要实现serializable还必须加锁。</p>
<h2 id="MySQL的MVCC"><a href="#MySQL的MVCC" class="headerlink" title="MySQL的MVCC"></a>MySQL的MVCC</h2><p>在Mysql中MVCC是在Innodb存储引擎中得到支持的，Innodb为每行记录都实现了三个隐藏字段：</p>
<ul>
<li>6字节的事务ID（DB_TRX_ID ）</li>
<li>7字节的回滚指针（<strong>DB_ROLL_PTR</strong>）</li>
<li>隐藏的ID</li>
</ul>
<p>6字节的事物ID用来标识该行所述的事务，7字节的回滚指针需要了解下Innodb的事务模型。</p>
<h3 id="Innodb的事务相关概念"><a href="#Innodb的事务相关概念" class="headerlink" title="Innodb的事务相关概念"></a>Innodb的事务相关概念</h3><p>为了支持事务，Innbodb引入了下面几个概念：</p>
<ul>
<li><strong>redo log</strong><br>redo log就是保存执行的SQL语句到一个指定的Log文件，当Mysql执行recovery时重新执行redo log记录的SQL操作即可。当客户端执行每条SQL（更新语句）时，redo log会被首先写入log buffer；当客户端执行COMMIT命令时，log buffer中的内容会被视情况刷新到磁盘。redo log在磁盘上作为一个独立的文件存在，即Innodb的log文件。</li>
<li><strong>undo log</strong><br>与redo log相反，undo log是为回滚而用，具体内容就是copy事务前的数据库内容（行）到undo buffer，在适合的时间把undo buffer中的内容刷新到磁盘。undo buffer与redo buffer一样，也是环形缓冲，但当缓冲满的时候，undo buffer中的内容会也会被刷新到磁盘；与redo log不同的是，磁盘上不存在单独的undo log文件，所有的undo log均存放在主ibd数据文件中（表空间），即使客户端设置了每表一个数据文件也是如此。</li>
<li><strong>rollback segment</strong><br>回滚段这个概念来自Oracle的事物模型，在Innodb中，undo log被划分为多个段，具体某行的undo log就保存在某个段中，称为回滚段。可以认为undo log和回滚段是同一意思。</li>
<li><strong>锁</strong><br>Innodb提供了基于行的锁，如果行的数量非常大，则在高并发下锁的数量也可能会比较大，据Innodb文档说，Innodb对锁进行了空间有效优化，即使并发量高也不会导致内存耗尽。<br>对行的锁有分两种：排他锁、共享锁。共享锁针对读，排他锁针对写，完全等同读写锁的概念。如果某个事务在更新某行（排他锁），则其他事物无论是读还是写本行都必须等待；如果某个事物读某行（共享锁），则其他读的事物无需等待，而写事物则需等待。通过共享锁，保证了多读之间的无等待性，但是锁的应用又依赖Mysql的事务隔离级别。</li>
<li><strong>隔离级别</strong><br>隔离级别用来限制事务直接的交互程度，目前有几个工业标准：<br>- READ_UNCOMMITTED：脏读<br>- READ_COMMITTED：读提交<br>- REPEATABLE_READ：重复读<br>- SERIALIZABLE：串行化<br>Innodb对四种类型都支持，脏读和串行化应用场景不多，读提交、重复读用的比较广泛，后面会介绍其实现方式。</li>
</ul>
<h3 id="行的更新过程"><a href="#行的更新过程" class="headerlink" title="行的更新过程"></a>行的更新过程</h3><p>下面演示下事务对某行记录的更新过程：</p>
<h4 id="1-初始数据行"><a href="#1-初始数据行" class="headerlink" title="1. 初始数据行"></a>1. 初始数据行</h4><p><img src="D:\study\Markdown\images\ThduNrH7n9FltOK.jpg" alt="img"></p>
<p>F1～F6是某行列的名字，1～6是其对应的数据。后面三个隐含字段分别对应该行的事务号和回滚指针，假如这条数据是刚INSERT的，可以认为ID为1，其他两个字段为空。</p>
<h4 id="2-事务1更改该行的各字段的值"><a href="#2-事务1更改该行的各字段的值" class="headerlink" title="2.事务1更改该行的各字段的值"></a>2.事务1更改该行的各字段的值</h4><p><img src="D:\study\Markdown\images\UyPvrm5Fiq9Z7nV.jpg" alt="img"></p>
<p>当事务1更改该行的值时，会进行如下操作：</p>
<ul>
<li>用排他锁锁定该行</li>
<li>记录redo log</li>
<li>把该行修改前的值Copy到undo log，即上图中下面的行</li>
<li>修改当前行的值，填写事务编号，使回滚指针指向undo log中的修改前的行</li>
</ul>
<h4 id="3-事务2修改该行的值"><a href="#3-事务2修改该行的值" class="headerlink" title="3.事务2修改该行的值"></a>3.事务2修改该行的值</h4><p><img src="D:\study\Markdown\images\OvJyS8dBYbiGRuc.jpg" alt="img"></p>
<p>与事务1相同，此时undo log，中有有两行记录，并且通过回滚指针连在一起。</p>
<p>因此，如果undo log一直不删除，则会通过当前记录的回滚指针回溯到该行创建时的初始内容，所幸的是在Innodb中存在purge线程，它会查询那些比现在最老的活动事务还早的undo log，并删除它们，从而保证undo log文件不至于无限增长。</p>
<h4 id="4-事务提交"><a href="#4-事务提交" class="headerlink" title="4. 事务提交"></a>4. 事务提交</h4><p>当事务正常提交时Innodb只需要更改事务状态为COMMIT即可，不需做其他额外的工作，而Rollback则稍微复杂点，需要根据当前回滚指针从undo log中找出事务修改前的版本，并恢复。如果事务影响的行非常多，回滚则可能会变的效率不高，根据经验值没事务行数在1000～10000之间，Innodb效率还是非常高的。很显然，Innodb是一个COMMIT效率比Rollback高的存储引擎。据说，Postgress的实现恰好与此相反。</p>
<h4 id="5-Insert-Undo-log"><a href="#5-Insert-Undo-log" class="headerlink" title="5. Insert Undo log"></a>5. Insert Undo log</h4><p>上述过程确切地说是描述了UPDATE的事务过程，其实undo log分insert和update undo log，因为insert时，原始的数据并不存在，所以回滚时把insert undo log丢弃即可，而update undo log则必须遵守上述过程。</p>
<h3 id="事务级别"><a href="#事务级别" class="headerlink" title="事务级别"></a>事务级别</h3><p>众所周知地是更新（update、insert、delete）是一个事务过程，在Innodb中，查询也是一个事务，只读事务。当读写事务并发访问同一行数据时，能读到什么样的内容则依赖事务级别：</p>
<ul>
<li>READ_UNCOMMITTED<br>读未提交时，读事务直接读取主记录，无论更新事务是否完成(提交)</li>
<li>READ_COMMITTED<br>读提交时，读事务每次都读取undo log中最近的版本，因此两次对同一字段的读可能读到不同的数据（幻读），但能保证每次都读到最新的数据。</li>
<li>REPEATABLE_READ<br>每次都读取指定的版本，这样保证不会产生幻读，但可能读不到最新的数据</li>
<li>SERIALIZABLE<br>锁表，读写相互阻塞，使用较少</li>
</ul>
<p>读事务一般有SELECT语句触发，在Innodb中保证其非阻塞，但带FOR UPDATE的SELECT除外，带FOR UPDATE的SELECT会对行加排他锁，等待更新事务完成后读取其最新内容。就整个Innodb的设计目标来说，就是提供高效的、非阻塞的查询操作。</p>
<h3 id="MVCC总结"><a href="#MVCC总结" class="headerlink" title="MVCC总结"></a>MVCC总结</h3><p>上述更新前建立undo log，根据各种策略读取时非阻塞就是MVCC，undo log中的行就是MVCC中的多版本，这个可能与我们所理解的MVCC有较大的出入，一般我们认为MVCC有下面几个特点：</p>
<ul>
<li>每行数据都存在一个版本，每次数据更新时都更新该版本</li>
<li>修改时Copy出当前版本随意修改，个事务之间无干扰</li>
<li>保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃copy（rollback）</li>
</ul>
<p>就是每行都有版本号，保存时根据版本号决定是否成功，听起来含有乐观锁的味道。。。，而Innodb的实现方式是：</p>
<ul>
<li>事务以排他锁的形式修改原始数据</li>
<li>把修改前的数据存放于undo log，通过回滚指针与主数据关联</li>
<li>修改成功（commit）啥都不做，失败则恢复undo log中的数据（rollback）</li>
</ul>
<p>二者最本质的区别是，当修改数据时是否要排他锁定，如果锁定了还算不算是MVCC？ </p>
<p>Innodb的实现真算不上MVCC，因为并没有实现核心的多版本共存，undo log中的内容只是串行化的结果，记录了多个事务的过程，不属于多版本共存。但理想的MVCC是难以实现的，当事务仅修改一行记录使用理想的MVCC模式是没有问题的，可以通过比较版本号进行回滚；但当事务影响到多行数据时，理想的MVCC就无能为力了。</p>
<p>比如，如果Transaciton1执行理想的MVCC，修改Row1成功，而修改Row2失败，此时需要回滚Row1，但因为Row1没有被锁定，其数据可能又被Transaction2所修改，如果此时回滚Row1的内容，则会破坏Transaction2的修改结果，导致Transaction2违反ACID。</p>
<p>理想MVCC难以实现的根本原因在于企图通过乐观锁代替二段提交。修改两行数据，但为了保证其一致性，与修改两个分布式系统中的数据并无区别，而二提交是目前这种场景保证一致性的唯一手段。二段提交的本质是锁定，乐观锁的本质是消除锁定，二者矛盾，故理想的MVCC难以真正在实际中被应用，Innodb只是借了MVCC这个名字，提供了读的非阻塞而已。</p>
<p>也不是说MVCC就无处可用，对一些一致性要求不高的场景和对单一数据的操作的场景还是可以发挥作用的，比如多个事务同时更改用户在线数，如果某个事务更新失败则重新计算后重试，直至成功。这样使用MVCC会极大地提高并发数，并消除线程锁。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>线程安全</tag>
      </tags>
  </entry>
  <entry>
    <title>Gateway+JWT鉴权</title>
    <url>/2020/07/12/Gateway+JWT%E9%89%B4%E6%9D%83/</url>
    <content><![CDATA[<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p>JWT（JSON Web Token）, 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。</p>
<a id="more"></a>

<p>JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h3 id="JWT的组成"><a href="#JWT的组成" class="headerlink" title="JWT的组成"></a>JWT的组成</h3><ul>
<li>Header（头部） —— base64编码的Json字符串</li>
<li>Payload（载荷） —— base64编码的Json字符串</li>
<li>Signature（签名）—— 使用指定算法，通过Header和Payload加盐计算的字符串</li>
</ul>
<p><strong>header</strong></p>
<p>jwt的头部承载两部分信息：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &#x27;typ&#x27;: &#x27;JWT&#x27;, //声明类型</span><br><span class="line">  &#x27;alg&#x27;: &#x27;RS256&#x27; //签名加密的算法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9</span><br></pre></td></tr></table></figure>


<p><strong>playload</strong></p>
<p>载荷就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分:</p>
<ul>
<li>标准中注册的声明 (==建议但不强制使用==) ：</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;JWT Builder&quot;</span>, <span class="comment">//jwt签发者</span></span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1416797419</span>, <span class="comment">// jwt的签发时间</span></span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1448333419</span>,  <span class="comment">//jwt的过期时间，这个过期时间必须要大于签发时间</span></span><br><span class="line">  <span class="attr">&quot;aud&quot;</span>: <span class="string">&quot;www.bilibili.com&quot;</span>, <span class="comment">//接收jwt的一方</span></span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;1837307557@qq.com&quot;</span>,  <span class="comment">//jwt所面向的用户</span></span><br><span class="line">  <span class="attr">&quot;GivenName&quot;</span>: <span class="string">&quot;Levin&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;Surname&quot;</span>: <span class="string">&quot;Levin&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;Email&quot;</span>: <span class="string">&quot;1837307557@qq.com&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;Role&quot;</span>: [ <span class="string">&quot;ADMIN&quot;</span>, <span class="string">&quot;MEMBER&quot;</span> ],</span><br><span class="line">  <span class="attr">&quot;nbf&quot;</span> : <span class="number">1416797420</span> <span class="comment">//定义在什么时间之前，该jwt都是不可用的,</span></span><br><span class="line">  <span class="string">&quot;jti&quot;</span> : <span class="string">&quot;jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>==公共==的声明 ：<br>公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.</p>
</li>
<li><p>==私有==的声明 ：<br>私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
</li>
</ul>
<p>定义一个payload:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 包括需要传递的用户信息；</span></span><br><span class="line">&#123; <span class="attr">&quot;iss&quot;</span>: <span class="string">&quot;Online JWT Builder&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;iat&quot;</span>: <span class="number">1416797419</span>, </span><br><span class="line">  <span class="attr">&quot;exp&quot;</span>: <span class="number">1448333419</span>, </span><br><span class="line">  <span class="attr">&quot;aud&quot;</span>: <span class="string">&quot;www.gusibi.com&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;sub&quot;</span>: <span class="string">&quot;uid&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;nickname&quot;</span>: <span class="string">&quot;goodspeed&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;username&quot;</span>: <span class="string">&quot;goodspeed&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;scopes&quot;</span>: [ <span class="string">&quot;admin&quot;</span>, <span class="string">&quot;user&quot;</span> ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后将其进行base64加密，得到Jwt的第二部分。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJpc3MiOiJPbmxpbmUgSldUIEJ1aWxkZXIiLCJpYXQiOjE0MTY3OTc0MTksImV4cCI6MTQ0ODMzMzQxOSwiYXVk</span><br></pre></td></tr></table></figure>


<p><strong>signature</strong></p>
<p>jwt的第三部分是一个签证信息，这个签证信息由三部分组成：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据头部alg算法与私有秘钥进行加密得到的签名字符串；</span></span><br><span class="line"><span class="comment">// 这一段是最重要的敏感信息，只能在服务端解密；</span></span><br><span class="line">HMACSHA256(  </span><br><span class="line">    base64UrlEncode(header) + <span class="string">&quot;.&quot;</span> +</span><br><span class="line">    base64UrlEncode(payload),</span><br><span class="line">    SECREATE_KEY</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这个部分需要base64加密后的header和base64加密后的payload使用 “.” 连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javascript</span></span><br><span class="line"><span class="keyword">var</span> encodedString = base64UrlEncode(header) + <span class="string">&#x27;.&#x27;</span> + base64UrlEncode(payload);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> signature = HMACSHA256(encodedString, <span class="string">&#x27;secret&#x27;</span>); <span class="comment">// TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span></span><br></pre></td></tr></table></figure>


<p>将这三部分用”.”连接成一个完整的字符串,构成了最终的jwt:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiJ9.eyJ1c2VyX2lkIjoxMjczOTEyMTE1MDI3MTE2MDMyLCJ1c2VyX3JvbGUiOjAsImV4cCI6MTU5MzMxODM2OH0.FqXgDP6b3qoTrAXteCHxQ2IUnryh_7XfeUHPTW8bXiLpXVDn1zigBJTGcxFhivcy0aIACBs32i0ynbBc5DUli6chesvIE7HfbAl9IiBj0D6Ujde-HnQdHcrzjPt783fy-5Voj4HJZWHrAH9SCPkKqs6VUUR6Ba8QHJeoJtkmUXg</span><br></pre></td></tr></table></figure>


<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。</p>
<h3 id="加密及验证过程"><a href="#加密及验证过程" class="headerlink" title="加密及验证过程"></a>加密及验证过程</h3><p><strong>加密：</strong></p>
<p>生成头JSON，荷载(playload) JSON</p>
<p>将头JSON Base64编码 + 荷载JSON Base64编码 +secret 三者拼接进行加密得到签名</p>
<p>JSON Base64编码 + 荷载JSON Base64编码 + 签名 三者通过 “.” 相连接</p>
<p>一条 hhh.ppp.sss 格式的JWT 即生成</p>
<p><strong>解密：</strong></p>
<p>取得Jwt hhh.ppp.sss 格式字符，通过 “.” 将字符分为三段</p>
<p>对第一段进行Base64解析得到header json，获取加密算法类型</p>
<p>将第一段Header JSON Base64编码 + 第二段 荷载JSON Base64编码 + secret采用相应的加密算法加密得到签名</p>
<p>将步骤三得到的签名与步骤一分成的第三段也就是客户端传入的签名进行匹配，匹配成功说明该jwt为server自身产出；</p>
<p>获取playload内信息，通过信息可以做鉴权操作；</p>
<p>成功访问；</p>
<p>通过这些步骤，保证了第三方无法修改jwt，jwt只能自产自销，在分布式环境下服务接收到合法的jwt便可知是本系统内自身或其他服务发出的jwt，该用户是合法的；</p>
<h3 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h3><p>微服务集群中的每个服务, 对外提供的都是Rest风格的接口, 而Rest风格的一个最重要的规范就是: 服务的无状态性, 即:</p>
<ul>
<li>服务端不保存任何客户端请求者状态信息</li>
<li>客户端的每次请求必须具备自描述信息, 通过这些信息识别客户端身份</li>
</ul>
<p>优点:</p>
<ul>
<li>客户端请求不依赖服务端的信息, 任何多次请求不需要必须访问到同一台服务</li>
<li>服务端的集群和状态对客户端透明</li>
<li>服务端可以任意的迁移和伸缩</li>
<li>减小服务端存储压力</li>
</ul>
<h2 id="JJWT"><a href="#JJWT" class="headerlink" title="JJWT"></a>JJWT</h2><p><strong>jjwt是一个Java对jwt的支持库，我们使用这个库来创建、解码token</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>配合joda-time处理过期时间</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>joda-time<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>X509</strong></p>
<p>X.509是常见通用的证书格式。所有的证书都符合为Public Key Infrastructure (PKI) 制定的 ITU-T X509 国际标准。X.509是国际电信联盟-电信（ITU-T）部分标准和国际标准化组织（ISO）的证书格式标准。作为ITU-ISO目录服务系列标准的一部分，X.509是定义了公钥证书结构的基本标准。1988年首次发布，1993年和1996年两次修订。当前使用的版本是X.509 V3，它加入了扩展字段支持，这极大地增进了证书的灵活性。X.509 V3证书包括一组按预定义顺序排列的强制字段，还有可选扩展字段，即使在强制字段中，X.509证书也允许很大的灵活性，因为它为大多数字段提供了多种编码方案.</p>
<p> <strong>JWT 最常见的几种签名算法</strong>：<strong>HS256(HMAC-SHA256) 、RS256(RSA-SHA256) 还有 ES256(ECDSA-SHA256)。</strong></p>
<p>这三种算法都是一种消息签名算法，得到的都只是一段无法还原的签名。区别在于<strong>消息签名</strong>与<strong>签名验证</strong>需要的 「key」不同。</p>
<ol>
<li>HS256 使用同一个「secret_key」进行签名与验证。一旦 secret_key 泄漏，就毫无安全性可言了。<ul>
<li>因此 HS256 只适合集中式认证，签名和验证都必须由可信方进行。</li>
</ul>
</li>
<li>RS256 是使用 RSA 私钥进行签名，使用 RSA 公钥进行验证。公钥即使泄漏也毫无影响，只要确保私钥安全就行。<ul>
<li>RS256 可以将验证委托给其他应用，只要将公钥给他们就行。</li>
</ul>
</li>
<li>ES256 和 RS256 一样，都使用私钥签名，公钥验证。算法速度上差距也不大，但是它的签名长度相对短很多（省流量），并且算法强度和 RS256 差不多。</li>
</ol>
<p>对于单体应用而言，HS256 和 RS256 的安全性没有多大差别。<br>而对于需要进行多方验证的微服务架构而言，显然 RS256/ES256 安全性更高。<br>只有 user 微服务需要用 RSA 私钥生成 JWT，其他微服务使用公钥即可进行签名验证，私钥得到了更好的保护。</p>
<p><strong>非对称加密</strong></p>
<p>同时生成私钥和公钥, 私钥加密, 可通过私钥或公钥解密; 公钥加密, 只有私钥可以解密</p>
<ol>
<li>优点：<ul>
<li>更安全，密钥越长，它就越难破解</li>
</ul>
</li>
<li>缺点：<ul>
<li>加密速度慢</li>
</ul>
</li>
<li>常用算法：<ul>
<li>RSA、Elgamal、背包算法、Rabin、D-H、ECC（椭圆曲线加密算法)</li>
</ul>
</li>
</ol>
<h2 id="生成JWT"><a href="#生成JWT" class="headerlink" title="生成JWT"></a>生成JWT</h2><p>客户端发送 POST 请求到服务器，提交登录处理的Controller层<br>调用认证服务进行用户名密码认证，如果认证通过，返回完整的用户信息及对应权限信息<br>利用 JJWT 对用户、权限信息、秘钥构建Token<br>返回构建好的Token</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 私钥加密生成token</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> user 载荷数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> privateKey 私钥字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> expireMinutes 过期时间,单位分钟</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(ShopUser user, <span class="keyword">byte</span>[] privateKey, Integer expireMinutes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">            .claim(JWTConstants.JWT_KEY_ID, user.getId())</span><br><span class="line">            .claim(JWTConstants.JWT_KEY_USER_NAME, user.getUserName())</span><br><span class="line">            .claim(JWTConstants.JWT_KEY_ROLE, user.getRole())</span><br><span class="line">            .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">            .signWith(SignatureAlgorithm.RS256, RsaUtils.getPrivateKey(privateKey))</span><br><span class="line">            .compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Jwts.builder()</strong> 返回了一个 <strong>DefaultJwtBuilder()</strong></p>
<p><strong>DefaultJwtBuilder属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectMapper OBJECT_MAPPER = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"><span class="keyword">private</span> Header header; <span class="comment">//头部</span></span><br><span class="line"><span class="keyword">private</span> Claims claims; <span class="comment">//声明</span></span><br><span class="line"><span class="keyword">private</span> String payload; <span class="comment">//载荷</span></span><br><span class="line"><span class="keyword">private</span> SignatureAlgorithm algorithm; <span class="comment">//签名算法</span></span><br><span class="line"><span class="keyword">private</span> Key key; <span class="comment">//签名key</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] keyBytes; <span class="comment">//签名key的字节数组</span></span><br><span class="line"><span class="keyword">private</span> CompressionCodec compressionCodec; <span class="comment">//压缩算法</span></span><br></pre></td></tr></table></figure>

<p>DefaultJwtBuilder包含了一些Header和Payload的一些常用设置方法</p>
<h2 id="解析-amp-验证JWT"><a href="#解析-amp-验证JWT" class="headerlink" title="解析&amp;验证JWT"></a>解析&amp;验证JWT</h2><p>客户端向服务器请求，服务端读取请求头信息(request.header)获取Token<br>如果找到Token信息，则根据配置文件中的签名加密秘钥，调用JJWT Lib对Token信息进行解密和解码；<br>完成解码并验证签名通过后，对Token中的exp、nbf、aud等信息进行验证；<br>全部通过后，根据获取的用户的角色权限信息，进行对请求的资源的权限逻辑判断；<br>如果权限逻辑判断通过则通过Response对象返回；否则则返回HTTP 401；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 公钥解析token</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> token 用户请求中的token</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> publicKey 公钥字节数组</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, <span class="keyword">byte</span>[] publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Jwts.parser().setSigningKey(RsaUtils.getPublicKey(publicKey))</span><br><span class="line">            .parseClaimsJws(token);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Jwts.parser()</strong> 返回了<strong>DefaultJwtParser</strong> 对象</p>
<p><strong>DefaultJwtParser() 属性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//don&#x27;t need millis since JWT date fields are only second granularity:</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ISO_8601_FORMAT = <span class="string">&quot;yyyy-MM-dd&#x27;T&#x27;HH:mm:ss&#x27;Z&#x27;&quot;</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MILLISECONDS_PER_SECOND = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ObjectMapper objectMapper = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] keyBytes; <span class="comment">//签名key字节数组</span></span><br><span class="line"><span class="keyword">private</span> Key key; <span class="comment">//签名key</span></span><br><span class="line"><span class="keyword">private</span> SigningKeyResolver signingKeyResolver; <span class="comment">//签名Key解析器</span></span><br><span class="line"><span class="keyword">private</span> CompressionCodecResolver compressionCodecResolver = <span class="keyword">new</span> DefaultCompressionCodecResolver(); <span class="comment">//压缩解析器</span></span><br><span class="line">Claims expectedClaims = <span class="keyword">new</span> DefaultClaims(); <span class="comment">//期望Claims</span></span><br><span class="line"><span class="keyword">private</span> Clock clock = DefaultClock.INSTANCE; <span class="comment">//时间工具实例</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> allowedClockSkewMillis = <span class="number">0</span>;  <span class="comment">//允许的时间偏移量</span></span><br></pre></td></tr></table></figure>

<p><strong>parse()</strong> 方法传入一个JWT字符串，返回一个JWT对象</p>
<p><strong>解析过程</strong>：</p>
<ol>
<li><p>检查: 以分隔符” <strong>.</strong> “切分JWT的三个部分。如果分隔符数量错误或者载荷为空，将抛出 <strong>MalformedJwtException</strong> 异常。</p>
</li>
<li><p>头部解析: 将头部原始Json键值存入map。根据是否加密创建不同的头部对象。jjwt的DefaultCompressionCodecResolver根据头部信息的压缩算法信息，添加不同的压缩解码器。</p>
</li>
<li><p>载荷解析: 先对载荷进行Base64解码，如果有经过压缩，那么在解码后再进行解压缩。此时将值赋予payload。如果载荷是json形式，将json键值读入map，将值赋予claims 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (payload.charAt(<span class="number">0</span>) == <span class="string">&#x27;&#123;&#x27;</span> &amp;&amp; payload.charAt(payload.length() - <span class="number">1</span>) == <span class="string">&#x27;&#125;&#x27;</span>) &#123; </span><br><span class="line">    <span class="comment">//likely to be json, parse it:</span></span><br><span class="line">    Map&lt;String, Object&gt; claimsMap = readValue(payload);</span><br><span class="line">    claims = <span class="keyword">new</span> DefaultClaims(claimsMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>签名解析: 如果存在签名部分，则对签名进行解析。</p>
<ul>
<li><p>首先根据头部的签名算法信息，获取对应的算法。<br> 如果签名部分不为空，但是签名算法为null或者’none’，将抛出<strong>MalformedJwtException</strong>异常。</p>
</li>
<li><p>获取签名key</p>
</li>
<li><p><em>可能的异常</em></p>
<ul>
<li>如果同时设置了key属性和keyBytes属性，parser不知道该使用哪个值去作为签名key解析，将抛出异常。</li>
<li>如果key属性和keyBytes属性只存在一个，但是设置了signingKeyResolver，也不知道该去解析前者还是使用后者，将抛出异常。</li>
<li>如果设置了key（setSigningKey() 方法）则直接使用生成Key对象。如果两种形式( key和keyBytes )都没有设置，则使用SigningKeyResolver（通过setSigningKeyResolver()方法设置）获取key, 当然，获取key为null会抛出异常</li>
</ul>
</li>
<li><p>创建签名校验器<br> JJWT实现了一个默认的签名校验器<strong>DefaultJwtSignatureValidator</strong>。该类提供了两个构造方法，外部调用的构造方法传入算法和签名key，再加上一个<strong>DefaultSignatureValidatorFactory</strong>工厂实例传递调用另一个构造函数，以便工厂根据不同算法创建不同类型的Validator。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultJwtSignatureValidator</span><span class="params">(SignatureAlgorithm alg, Key key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DefaultSignatureValidatorFactory.INSTANCE, alg, key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultJwtSignatureValidator</span><span class="params">(SignatureValidatorFactory factory, SignatureAlgorithm alg, Key key)</span> </span>&#123;</span><br><span class="line">    Assert.notNull(factory, <span class="string">&quot;SignerFactory argument cannot be null.&quot;</span>);</span><br><span class="line">    <span class="keyword">this</span>.signatureValidator = factory.createSignatureValidator(alg, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>比对验证<br>根据头部和载荷重新计算签名并比对。<br>如果不匹配，抛出<strong>SignatureException</strong>异常</p>
</li>
<li><p>时间校验<br>根据当前时间和时间偏移判断是否过期。<br>根据当前时间和时间偏移判断是够未到可接收时间</p>
</li>
<li><p>Claims参数校验<br>即校验parser前面设置的所以require部分。校验完成后，以header，claims或者payload创建DefaultJwt对象返回</p>
</li>
<li><p><strong>至此，已经完成JWT Token的校验过程。校验通过后返回JWT对象。</strong></p>
</li>
</ul>
</li>
</ol>
<h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><h3 id="JWTUtils"><a href="#JWTUtils" class="headerlink" title="JWTUtils"></a>JWTUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.uni.entity.ShopUser;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.*;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  JWT 的工具类：包含了创建和解码的工具</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 载荷数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireMinutes 过期时间,单位分钟</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(ShopUser user, PrivateKey privateKey, Integer expireMinutes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_ID, user.getId())</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_USER_NAME, user.getUserName())</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_ROLE, user.getRole())</span><br><span class="line">                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.RS256, privateKey)</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥加密token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user 载荷数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 私钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> expireMinutes 过期时间,单位分钟</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">generateToken</span><span class="params">(ShopUser user, <span class="keyword">byte</span>[] privateKey, Integer expireMinutes)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_ID, user.getId())</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_USER_NAME, user.getUserName())</span><br><span class="line">                .claim(JWTConstants.JWT_KEY_ROLE, user.getRole())</span><br><span class="line">                .setExpiration(DateTime.now().plusMinutes(expireMinutes).toDate())</span><br><span class="line">                .signWith(SignatureAlgorithm.RS256, RsaUtils.getPrivateKey(privateKey))</span><br><span class="line">                .compact();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用公钥解析token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, PublicKey publicKey)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(publicKey).parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥解析token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Jws&lt;Claims&gt; <span class="title">parserToken</span><span class="params">(String token, <span class="keyword">byte</span>[] publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Jwts.parser().setSigningKey(RsaUtils.getPublicKey(publicKey))</span><br><span class="line">                .parseClaimsJws(token);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户请求中的令牌</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShopUser <span class="title">getInfoFromToken</span><span class="params">(String token, PublicKey publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        Claims body = claimsJws.getBody();</span><br><span class="line"></span><br><span class="line">        Long user_id = (Long) body.get(JWTConstants.JWT_KEY_ID);</span><br><span class="line">        String user_name = (String) body.get(JWTConstants.JWT_KEY_USER_NAME);</span><br><span class="line">        Integer user_role = (Integer) body.get(JWTConstants.JWT_KEY_ROLE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShopUser(user_id, user_name, user_role);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token中的用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> token 用户请求中的token</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 公钥字节数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ShopUser <span class="title">getInfoFromToken</span><span class="params">(String token, <span class="keyword">byte</span>[] publicKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(token, publicKey);</span><br><span class="line">        Claims body = claimsJws.getBody();</span><br><span class="line"></span><br><span class="line">        Long user_id = (Long) body.get(JWTConstants.JWT_KEY_ID);</span><br><span class="line">        String user_name = (String) body.get(JWTConstants.JWT_KEY_USER_NAME);</span><br><span class="line">        Integer user_role = (Integer) body.get(JWTConstants.JWT_KEY_ROLE);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ShopUser(user_id, user_name, user_role);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 测试解析token */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PublicKey publicKey = RsaUtils.getPublicKey(<span class="string">&quot;D://rsa//rsa.pub&quot;</span>);</span><br><span class="line">        Jws&lt;Claims&gt; claimsJws = parserToken(<span class="string">&quot;eyJhbGciOiJSUzI1NiJ9.eyJ1c2VyX2lkIjoxMjczOTEyMTE1MDI3MTE2MDMyLCJ1c2VyX3JvbGUiOjAsImV4cCI6MTU5MzMxODM2OH0.FqXgDP6b3qoTrAXteCHxQ2IUnryh_7XfeUHPTW8bXiLpXVDn1zigBJTGcxFhivcy0aIACBs32i0ynbBc5DUli6chesvIE7HfbAl9IiBj0D6Ujde-HnQdHcrzjPt783fy-5Voj4HJZWHrAH9SCPkKqs6VUUR6Ba8QHJeoJtkmUXg&quot;</span>, publicKey);</span><br><span class="line">        System.out.println(claimsJws.getSignature());</span><br><span class="line">        System.out.println(claimsJws.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="RsaUtils"><a href="#RsaUtils" class="headerlink" title="RsaUtils"></a>RsaUtils</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.impl.crypto.DefaultJwtSignatureValidator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.nio.file.Files;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rsa非对称加密</span></span><br><span class="line"><span class="comment"> * 私钥加密，解密需要公钥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RsaUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取公钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 公钥保存路径,相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPublicKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  获取公钥</span></span><br><span class="line"><span class="comment">     * X.509是定义了公钥证书结构的基本标准</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 公钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 公钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">getPublicKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        X509EncodedKeySpec spec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从文件中读取私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> filename 私钥保存路径，相对于classpath</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 私钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(String filename)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = readFile(filename);</span><br><span class="line">        <span class="keyword">return</span> getPrivateKey(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes 私钥的字节形式</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 私钥对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">getPrivateKey</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        PKCS8EncodedKeySpec spec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据密文,生成rsa公钥和私钥,并写入指定文件</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKeyFilename 公钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKeyFilename 私钥文件路径</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secret 生成密钥的密文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateKey</span><span class="params">(String publicKeyFilename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String privateKeyFilename, String secret)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(secret.getBytes());</span><br><span class="line">        keyPairGenerator.initialize(<span class="number">1024</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="comment">//获取公钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicKeyBytes = keyPair.getPublic().getEncoded();</span><br><span class="line">        writeFile(publicKeyFilename, publicKeyBytes);</span><br><span class="line">        <span class="comment">//获取私钥并写出</span></span><br><span class="line">        <span class="keyword">byte</span>[] privateKeyBytes = keyPair.getPrivate().getEncoded();</span><br><span class="line">        writeFile(privateKeyFilename, privateKeyBytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] readFile(String filename) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> Files.readAllBytes(<span class="keyword">new</span> File(filename).toPath());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeFile</span><span class="params">(String destPath, <span class="keyword">byte</span>[] bytes)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        File dest = <span class="keyword">new</span> File(destPath);</span><br><span class="line">        <span class="keyword">if</span> (!dest.exists())&#123;</span><br><span class="line">            dest.createNewFile();</span><br><span class="line">        &#125;</span><br><span class="line">        Files.write(dest.toPath(), bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 测试公私钥获取 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//公私钥路径</span></span><br><span class="line">        String pubKeyPath = <span class="string">&quot;D:\\rsa\\rsa.pub&quot;</span>;</span><br><span class="line">        String priKeyPath = <span class="string">&quot;D:\\rsa\\rsa.pri&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//明文</span></span><br><span class="line">        String secret = <span class="string">&quot;sc@Login(Auth&#125;*^31)&amp;czxy%&quot;</span>;</span><br><span class="line">        <span class="comment">//RsaUtils.generateKey(pubKeyPath, priKeyPath, secret);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 解密 */</span></span><br><span class="line">        PublicKey publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">        System.out.println(<span class="string">&quot;公钥: &quot;</span> + publicKey);</span><br><span class="line">        PrivateKey privateKey = RsaUtils.getPrivateKey(priKeyPath);</span><br><span class="line">        System.out.println(<span class="string">&quot;私钥: &quot;</span> + privateKey);</span><br><span class="line">        <span class="comment">//签名验证器</span></span><br><span class="line">        DefaultJwtSignatureValidator validator = <span class="keyword">new</span> DefaultJwtSignatureValidator(SignatureAlgorithm.RS256, publicKey);</span><br><span class="line">        <span class="keyword">boolean</span> valid = validator.isValid(<span class="string">&quot;eyJhbGciOiJSUzI1NiJ9.eyJ1c2VyX2lkIjoxMjczOTEyMTE1MDI3MTE2MDMyLCJ1c2VyX3JvbGUiOjAsImV4cCI6MTU5MzMxODM2OH0&quot;</span>, <span class="string">&quot;FqXgDP6b3qoTrAXteCHxQ2IUnryh_7XfeUHPTW8bXiLpXVDn1zigBJTGcxFhivcy0aIACBs32i0ynbBc5DUli6chesvIE7HfbAl9IiBj0D6Ujde-HnQdHcrzjPt783fy-5Voj4HJZWHrAH9SCPkKqs6VUUR6Ba8QHJeoJtkmUXg&quot;</span>);</span><br><span class="line">        System.out.println(valid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JWTProperties"><a href="#JWTProperties" class="headerlink" title="JWTProperties"></a>JWTProperties</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.uni.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.uni.util.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化公钥和私钥</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:application.yml&quot;)</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jwt&quot;)</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String secret; <span class="comment">// 密文</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String pubKeyPath;<span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String priKeyPath;<span class="comment">// 私钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer expire;<span class="comment">// token过期时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] skipAuthUrls; <span class="comment">//跳过的url</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PublicKey publicKey; <span class="comment">// 公钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> PrivateKey privateKey; <span class="comment">// 私钥</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.info(<span class="string">&quot;公钥地址: &quot;</span> + pubKeyPath);</span><br><span class="line">            log.info(<span class="string">&quot;私钥地址: &quot;</span> + priKeyPath);</span><br><span class="line">            File pubKey = <span class="keyword">new</span> File(pubKeyPath);</span><br><span class="line">            File priKey = <span class="keyword">new</span> File(priKeyPath);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!pubKey.exists() || !priKey.exists()) &#123;</span><br><span class="line">                <span class="comment">// 生成公钥和私钥并写入文件</span></span><br><span class="line">                RsaUtils.generateKey(pubKeyPath, priKeyPath, secret);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取公钥和私钥</span></span><br><span class="line">            <span class="keyword">this</span>.publicKey = RsaUtils.getPublicKey(pubKeyPath);</span><br><span class="line">            <span class="keyword">this</span>.privateKey = RsaUtils.getPrivateKey(priKeyPath);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;初始化公钥和私钥失败! &quot;</span> + e);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">jwt:</span></span><br><span class="line">  <span class="attr">secret:</span> <span class="string">sc@Login(Auth&#125;*^31)&amp;czxy%</span> <span class="comment"># 登录校验的明文</span></span><br><span class="line">  <span class="attr">pubKeyPath:</span> <span class="string">D://rsa//rsa.pub</span> <span class="comment"># 公钥地址</span></span><br><span class="line">  <span class="attr">priKeyPath:</span> <span class="string">D://rsa//rsa.pri</span> <span class="comment"># 私 钥地址</span></span><br><span class="line">  <span class="attr">expire:</span> <span class="number">30</span> <span class="comment"># 过期时间,单位分钟</span></span><br><span class="line">  <span class="attr">skipAuthUrls:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">/auth/**</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">...</span></span><br></pre></td></tr></table></figure>

<h3 id="JWTConstants"><a href="#JWTConstants" class="headerlink" title="JWTConstants"></a>JWTConstants</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTConstants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_HEADER_KEY = <span class="string">&quot;Authorization&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY_ID = <span class="string">&quot;user_id&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY_USER_NAME = <span class="string">&quot;user_name&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String JWT_KEY_ROLE = <span class="string">&quot;user_role&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JWTModel"><a href="#JWTModel" class="headerlink" title="JWTModel"></a>JWTModel</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JWTModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String jwt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="用户登录"><a href="#用户登录" class="headerlink" title="用户登录"></a>用户登录</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.uni.config.JWTProperties;</span><br><span class="line"><span class="keyword">import</span> com.uni.entity.Dto;</span><br><span class="line"><span class="keyword">import</span> com.uni.entity.ShopUser;</span><br><span class="line"><span class="keyword">import</span> com.uni.service.ShopUserService;</span><br><span class="line"><span class="keyword">import</span> com.uni.util.*;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.ObjectUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/auth&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthAPI</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ShopUserService shopUserService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JWTProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping(&quot;/login&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dto <span class="title">doLogin</span><span class="params">(<span class="meta">@RequestBody</span> ShopUser user)</span></span>&#123;</span><br><span class="line">        ShopUser result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 验证用户明和密码</span></span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isNotEmpty(user)) &#123;</span><br><span class="line">             result = shopUserService.login(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ObjectUtils.isEmpty(result))&#123;</span><br><span class="line">            <span class="keyword">return</span> DtoUtil.returnFail(<span class="string">&quot;用户名或密码错误&quot;</span>, <span class="string">&quot;401&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//生成token</span></span><br><span class="line">            String token = JWTUtils.generateToken(</span><br><span class="line">                    result, jwtProperties.getPrivateKey(), <span class="number">30</span>);</span><br><span class="line">            <span class="keyword">return</span> DtoUtil.returnSuccess(<span class="string">&quot;登录成功&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> JWTModel(result.getId(), result.getUserName(), token));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;生成token失败! &quot;</span>, e);</span><br><span class="line">            <span class="keyword">return</span> DtoUtil.returnFail(<span class="string">&quot;登录失败&quot;</span>, <span class="string">&quot;500&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="网关鉴权"><a href="#网关鉴权" class="headerlink" title="网关鉴权"></a>网关鉴权</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.uni.config.JWTProperties;</span><br><span class="line"><span class="keyword">import</span> com.uni.util.JWTConstants;</span><br><span class="line"><span class="keyword">import</span> com.uni.util.JWTUtils;</span><br><span class="line"><span class="keyword">import</span> com.uni.util.RsaUtils;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Claims;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.Jws;</span><br><span class="line"><span class="keyword">import</span> io.jsonwebtoken.SignatureAlgorithm;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.lang3.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.DateTime;</span><br><span class="line"><span class="keyword">import</span> org.joda.time.Minutes;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GatewayFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.gateway.filter.GlobalFilter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.Ordered;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求鉴权过滤器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessGateWayFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span>, <span class="title">Ordered</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ObjectMapper objectMapper;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JWTProperties jwtProperties;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AntPathMatcher antPathMatcher; <span class="comment">//路径匹配器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccessGateWayFilter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.objectMapper = objectMapper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        String url = exchange.getRequest().getURI().getPath();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//跳过不需要验证的url</span></span><br><span class="line">        <span class="keyword">for</span> (String skip : jwtProperties.getSkipAuthUrls()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (antPathMatcher.match(skip, url))</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取token</span></span><br><span class="line">        String token = exchange.getRequest().getHeaders().getFirst(JWTConstants.JWT_HEADER_KEY);</span><br><span class="line">        ServerHttpResponse response = exchange.getResponse();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">//没有token</span></span><br><span class="line">            <span class="keyword">return</span> authError(response, <span class="string">&quot;请登录&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//解析token</span></span><br><span class="line">                Jws&lt;Claims&gt; claims = JWTUtils.parserToken(token, jwtProperties.getPublicKey());</span><br><span class="line">                DateTime now = DateTime.now();</span><br><span class="line">                DateTime exp = <span class="keyword">new</span> DateTime(claims.getBody().getExpiration());</span><br><span class="line">                </span><br><span class="line">                log.debug(claims.getBody().getExpiration().toString());</span><br><span class="line"></span><br><span class="line">                <span class="comment">/* </span></span><br><span class="line"><span class="comment">                	根据具体业务</span></span><br><span class="line"><span class="comment">                	用户信息&amp;权限验证 </span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                <span class="comment">//claims.getBody()获取载荷</span></span><br><span class="line">                <span class="comment">//JWTUtils.getInfoFromToken()获取token中的用户信息</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (valid)&#123; <span class="comment">//签名验证通过</span></span><br><span class="line">                    <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> authError(response, <span class="string">&quot;认证无效&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                log.error(<span class="string">&quot;检查token时异常: &quot;</span> + e);</span><br><span class="line">                <span class="keyword">if</span> (e.getMessage().contains(<span class="string">&quot;JWT expired&quot;</span>))</span><br><span class="line">                    <span class="keyword">return</span> authError(response, <span class="string">&quot;认证过期&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> authError(response, <span class="string">&quot;认证失败&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证错误输出</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> response 响应对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg 错误信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 响应信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Mono&lt;Void&gt; <span class="title">authError</span><span class="params">(ServerHttpResponse response, String msg)</span> </span>&#123;</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>,<span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        Dto returnFail = DtoUtil.returnFail(msg, HttpStatus.UNAUTHORIZED.toString());</span><br><span class="line">        String returnStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            returnStr = objectMapper.writeValueAsString(returnFail);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (JsonProcessingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        DataBuffer buffer = response.bufferFactory().wrap(returnStr.getBytes(StandardCharsets.UTF_8));</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Flux.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="刷新JWT"><a href="#刷新JWT" class="headerlink" title="刷新JWT"></a>刷新JWT</h2><p>令牌的刷新要做到用户无感知的效果</p>
<p><strong>Web应用程序</strong></p>
<p>一个好的模式是在它过期之前刷新令牌。</p>
<p>将令牌过期时间设置为一周，并在每次用户打开Web应用程序并每隔一小时刷新令牌。如果用户超过一周没有打开过应用程序，那他们就需要再次登录，这是可接受的Web应用程序UX(用户体验)。</p>
<p>要刷新令牌，API需要一个新的端点，它接收一个有效的、没有过期的JWT、并返回与新的到期字段相同的签名的JWT。然后Web应用程序会将令牌存储在某处。</p>
<p><strong>移动/本地应用程序</strong></p>
<p>大多数本地应用程序的登录有且仅有一次。</p>
<p>这里面的出发点是，刷新令牌永远不会过期，并且可以始终为有效的JWT进行更换。</p>
<p>永远不会过期的令牌的问题是它失去了令牌的意义。譬如，如果你电话丢了，你该怎么办？因此，它需要由用户以某种方式进行识别，应用程序需要提供撤销访问的方法。我们决定使用设备的名称，例如“maryo的iPad”。然后用户可以去应用程序，并撤销访问“maryo的iPad”。</p>
<p>另一种方法是撤销特定事件的刷新令牌，其中一个有趣的事件是更改密码。</p>
<p>我们认为JWT对于这些用例无效，因此我们使用随机生成的字符串，并将它们存储在我们这边。</p>
<h2 id="注销"><a href="#注销" class="headerlink" title="注销"></a>注销</h2><p>没有办法完美的将jwt失效</p>
<p><strong>jwt 的目的本来就是为了在服务器不存任何的东西,  用加解密 的 cpu 时间来换取以前要保存的空间 , 说白了就是用 cpu 时间换内存空间(这个内存可以是 session, 也可能是 redis 这种)</strong></p>
<p>可能的解决方案：</p>
<ul>
<li>将JWT存储在数据库中。您可以检查哪些令牌有效以及哪些令牌已被撤销，但这在我看来完全违背了使用JWT的目的。</li>
<li>从客户端删除令牌。这将阻止客户端进行经过身份验证的请求，但如果令牌仍然有效且其他人可以访问它，则仍可以使用该令牌。这引出了我的下一点。</li>
<li>令牌生命周期短。让令牌快速到期。根据应用，可能是几分钟或半小时。当客户端删除其令牌时，会有一个很短的时间窗口仍然可以使用它。从客户端删除令牌并具有短令牌生存期不需要对后端进行重大修改。但是令牌生命周期短意味着用户因令牌已过期而不断被注销。</li>
<li>旋转代币。也许引入刷新令牌的概念。当用户登录时，为他们提供JWT和刷新令牌。将刷新令牌存储在数据库中。对于经过身份验证的请求，客户端可以使用JWT，但是当令牌过期（或即将过期）时，让客户端使用刷新令牌发出请求以换取新的JWT。这样，您只需在用户登录或要求新的JWT时访问数据库。当用户注销时，您需要使存储的刷新令牌无效。否则，即使用户已经注销，有人在监听连接时仍然可以获得新的JWT。</li>
<li>创建JWT黑名单。根据过期时间，当客户端删除其令牌时，它可能仍然有效一段时间。如果令牌生存期很短，则可能不是问题，但如果您仍希望令牌立即失效，则可以创建令牌黑名单。当后端收到注销请求时，从请求中获取JWT并将其存储在内存数据库中。对于每个经过身份验证的请求，您需要检查内存数据库以查看令牌是否已失效。为了保持较小的搜索空间，您可以从黑名单中删除已经过期的令牌。</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/6bfeb86885a3">https://www.jianshu.com/p/6bfeb86885a3</a></p>
<p><a href="https://blog.csdn.net/weixin_41245089/article/details/88185206">https://blog.csdn.net/weixin_41245089/article/details/88185206</a></p>
<p><a href="https://blog.csdn.net/github_35976996/article/details/95170542">https://blog.csdn.net/github_35976996/article/details/95170542</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Authorization</category>
      </categories>
      <tags>
        <tag>微服务</tag>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>MyCat学习笔记</title>
    <url>/2019/10/26/MyCat%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Mycat数据库中间件"><a href="#Mycat数据库中间件" class="headerlink" title="Mycat数据库中间件"></a>Mycat数据库中间件</h1><p> 1、<strong>数据库中间件</strong>：</p>
<p>是一类连接软件组件和应用的计算机软件，以便于软件各部件之间的沟通。 例子：Tomcat，web中间件。 数据库中间件：连接java应用程序和数据库 </p>
<a id="more"></a>

<p>2、<strong>为什么要用Mycat？</strong> </p>
<ul>
<li>Java与数据库紧耦合</li>
<li>高访问量高并发对数据库的压力</li>
<li>读写请求数据不一致 </li>
</ul>
<p>==mysql单表瓶颈1000w数据,单库瓶颈5000w数据==</p>
<p><strong>数据库中间件对比:</strong></p>
<p><img src="D:\study\Markdown\images\image-20200517142233265.png" alt="image-20200517142233265"></p>
<p><strong>Mycat的官网:</strong>    <a href="http://www.mycat.io/">http://www.mycat.io/</a> </p>
<p><strong>Mycat能干什么:</strong></p>
<ul>
<li><p><strong>读写分离</strong><img src="https://i.loli.net/2020/05/17/xW3Nsw9V5tdliRO.png" alt="image-20200517142440990"></p>
</li>
<li><p><strong>数据分片</strong>  垂直拆分（分库）、水平拆分（分表）、垂直+水平拆分（分库分表)<img src="https://i.loli.net/2020/05/17/orkKWT3nDh8YqXR.png" alt="image-20200517142902826"></p>
</li>
<li><p><strong>多数据源整合</strong> <img src="https://i.loli.net/2020/05/17/2RzmPCoSs8QYHpk.png" alt="image-20200517143305538"></p>
</li>
</ul>
<p><strong>原理:</strong></p>
<p>Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL<br>语句做了一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发<br>往后端的真实数据库，并将返回的结果做适当的处理，最终再返回给用户</p>
<h2 id="安装启动"><a href="#安装启动" class="headerlink" title="安装启动"></a>安装启动</h2><p><strong>1、解压后即可使用</strong><br>解压缩文件拷贝到 linux 下 /usr/local/<br><strong>2、三个配置文件</strong> </p>
<ul>
<li>schema.xml：定义逻辑库，表、分片节点等内容 </li>
<li>rule.xml：定义分片规则 </li>
<li>server.xml：定义用户以及系统相关变量，如端口等 </li>
</ul>
<p><strong>3、修改配置文件server.xml 修改用户信息，与MySQL区分</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--用户名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span>     <span class="comment">&lt;!--密码--&gt;</span>           </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span> 		<span class="comment">&lt;!--管理的库--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>schemas</code>:数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,db2</p>
<p><strong>4.修改配置文件 schema.xml</strong> </p>
<p>删除<code>&lt;schema&gt;</code>标签间的表信息配置<code> dataNode=&quot;dn1&quot;</code>， <code>&lt;dataNode&gt;</code>标签只留一个， <code>&lt;dataHost&gt;</code>标签只留一个， <code>&lt;writeHost&gt; </code>,<code>&lt;readHost&gt;</code>只留一对 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 逻辑库  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>  <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 逻辑表 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 数据节点 database填写真实数据库--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;testdb&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 数据主机 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 心跳检测 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 写主机 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.132:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">			<span class="comment">&lt;!-- 读主机 --&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hzy&quot;</span> <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">	</span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>5.验证数据库访问情况</strong> </p>
<p>Mycat 作为数据库中间件要和数据库部署在不同机器上，所以要验证远程访问情况。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -uhzy -p000000 -h 192.168.107.108 -P 3306 </span><br><span class="line">mysql -uroot -p000000 -h 192.168.107.132 -P 3306 </span><br><span class="line"> </span><br><span class="line"><span class="comment">#如远程访问报错，请建对应用户 </span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> root@<span class="string">&#x27;缺少的host&#x27;</span>  <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">&#x27;000000&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p><strong>6.启动mycat</strong></p>
<ul>
<li>控制台启动 ：去 mycat/bin 目录下执行 ./mycat console </li>
<li>后台启动 ：去 mycat/bin 目录下 ./mycat start </li>
</ul>
<p>为了能第一时间看到启动日志，方便定位问题，我们选择控制台启动。</p>
<p><strong>7.登录mycat</strong></p>
<ul>
<li>登录后台管理窗口 </li>
</ul>
<p>此登录方式用于管理维护 Mycat </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -P 9066 -h 192.168.140.128 </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">常用命令如下： </span></span><br><span class="line">show database;</span><br><span class="line">show @@help;</span><br></pre></td></tr></table></figure>

<ul>
<li>登录数据窗口 </li>
</ul>
<p>此登录方式用于通过 Mycat 查询数据，我们选择这种方式访问Mycat</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123456 -P 8066 -h 192.168.107.132 </span><br></pre></td></tr></table></figure>

<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>我们通过 Mycat 和 MySQL 的<strong>主从复制</strong>配合搭建数据库的<strong>读写分离</strong>，实现 MySQL 的高可用性。<br>我们将搭建：一主一从、双主双从两种读写分离模式。 </p>
<p><img src="https://i.loli.net/2020/05/18/xutYMTd5vqngBhW.png" alt="image-20200518102823097"></p>
<p><strong>mysql主从复制原理:</strong></p>
<p><img src="https://i.loli.net/2020/05/18/EQKzcxyL7TD6JCY.png" alt="image-20200518103132114"></p>
<p>与redis不同的是,redis从机会把主机的数据从头到尾复制,而mysql从机只会从接入点开始复制; 并且会发生多次IO有延时问题</p>
<h3 id="主机配置"><a href="#主机配置" class="headerlink" title="主机配置"></a>主机配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改配置文件：</span><br><span class="line">vim &#x2F;etc&#x2F;my.cnf </span><br><span class="line">#主服务器唯一ID </span><br><span class="line">server-id&#x3D;1  </span><br><span class="line">#启用二进制日志 </span><br><span class="line">log-bin&#x3D;mysql-bin </span><br><span class="line"># 设置不要复制的数据库(可设置多个) </span><br><span class="line">binlog-ignore-db&#x3D;mysql </span><br><span class="line">binlog-ignore-db&#x3D;information_schema </span><br><span class="line">#设置需要复制的数据库 </span><br><span class="line">binlog-do-db&#x3D;需要复制的主数据库名字 </span><br><span class="line">#设置logbin格式 </span><br><span class="line">binlog_format&#x3D;STATEMENT </span><br></pre></td></tr></table></figure>

<blockquote>
<p>binlog的三种模式:<a href="https://blog.csdn.net/vhomes/article/details/8082734">https://blog.csdn.net/vhomes/article/details/8082734</a></p>
</blockquote>
<h3 id="从机配置"><a href="#从机配置" class="headerlink" title="从机配置"></a>从机配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;my.cnf </span><br><span class="line">#从服务器唯一ID </span><br><span class="line">server-id&#x3D;2  </span><br><span class="line">#启用中继日志 </span><br><span class="line">relay-log&#x3D;mysql-relay </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>重启服务</strong>:<code>systemctl restart mysqld</code></p>
</li>
<li><p><strong>确认防火墙已关闭:</strong><code>systemctl status firewalld</code></p>
</li>
<li><p><strong>在主机MySQL里执行授权命令</strong>: <code>GRANT REPLICATION SLAVE ON *.* TO &#39;slave&#39;@&#39;%&#39; IDENTIFIED BY &#39;123123&#39;; </code></p>
</li>
</ul>
<p>如果报错:Your password does not satisfy the current policy requirements,请执行:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set global validate_password_policy&#x3D;0;</span><br><span class="line">set global validate_password_length&#x3D;4;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>查看主机状态:</strong></li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB         | Executed_Gtid_Set |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">| mysql-bin.000001 |      438 | testdb       | mysql,information_schema |                   |</span><br><span class="line">+<span class="comment">------------------+----------+--------------+--------------------------+-------------------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>

<p>记录下File和Position的值, 执行完此步骤后不要再操作主服务器MySQL，防止主服务器状态值变化 </p>
<ul>
<li><strong>在从机上配置需要复制的主机</strong> </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#复制主机的命令 </span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机的IP地址&#39;, </span><br><span class="line">MASTER_USER&#x3D;&#39;slave&#39;, </span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123123&#39;, </span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;具体值; </span><br><span class="line">#启动从服务器复制功能 </span><br><span class="line">start slave; </span><br><span class="line">#查看从服务器状态 </span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>

<p><strong>例子:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.107.132&#39;, </span><br><span class="line">MASTER_USER&#x3D;&#39;slave&#39;, </span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123123&#39;, </span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.000003&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;154; </span><br></pre></td></tr></table></figure>

<p>如果之前配置过主从复制,需要先重置<code>stop slave;</code>, <code>reset master;</code></p>
<p>接着启动从服务器复制功能 <code>start slave; </code></p>
<p>查看从服务器状态 <code>show slave status\G</code>(不要加分号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#这两项尾Yes即为成功</span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br><span class="line">#如果失败可查看Error项</span><br><span class="line">Last_Errno: 0</span><br><span class="line">Last_Error: </span><br><span class="line">Last_IO_Errno: 0</span><br><span class="line">Last_IO_Error: </span><br><span class="line">Last_SQL_Errno: 0</span><br><span class="line">Last_SQL_Error: </span><br></pre></td></tr></table></figure>

<p> <strong>主机新建库(my.cnf中规定的库)、新建表、insert 记录，从机复制</strong> </p>
<h3 id="一主一从"><a href="#一主一从" class="headerlink" title="一主一从"></a>一主一从</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 写主机 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.132:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 读主机 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hzy&quot;</span> <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>启动mycat</strong></p>
<p>在写主机数据库表mytbl中插入带系统变量数据，造成主从数据不一致 <code>INSERT INTO mytbl VALUES(2,@@hostname); </code></p>
<p><strong>使用mycat查询,可以看到mycat操作的是主机数据</strong></p>
<p>原因是我们没有指定数据库访问的<strong>负载策略</strong><code>balance</code></p>
<ul>
<li><p>balance=”0”, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。 </p>
</li>
<li><p>balance=”1”，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从 模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。 </p>
</li>
<li><p>balance=”2”，所有读操作都随机的在 writeHost、readhost 上分发。 </p>
</li>
<li><p>balance=”3”，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力 </p>
</li>
</ul>
<p>==双主双从选1,单主单从或多从选3==</p>
<p><strong>修改schema.xml</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 数据主机 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;3&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="双主双从"><a href="#双主双从" class="headerlink" title="双主双从"></a>双主双从</h3><p>一个主机 m1 用于处理所有写请求，它的从机 s1 和另一台主机 m2 还有它的从机 s2 负责所有读请<br>求。当 m1 主机宕机后，m2 主机负责写请求，m1、m2 互为备机。</p>
<p><img src="https://i.loli.net/2020/05/18/YyWeo3ACMcrHqhf.png" alt="image-20200518133105869"></p>
<p><strong>Master1配置</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改配置文件：vim &#x2F;etc&#x2F;my.cnf </span><br><span class="line">#主服务器唯一ID </span><br><span class="line">server-id&#x3D;1  </span><br><span class="line">#启用二进制日志 </span><br><span class="line">log-bin&#x3D;mysql-bin </span><br><span class="line"># 设置不要复制的数据库(可设置多个) </span><br><span class="line">binlog-ignore-db&#x3D;mysql </span><br><span class="line">binlog-ignore-db&#x3D;information_schema </span><br><span class="line">#设置需要复制的数据库 </span><br><span class="line">binlog-do-db&#x3D;需要复制的主数据库名字 </span><br><span class="line">#设置logbin格式 </span><br><span class="line">binlog_format&#x3D;STATEMENT </span><br><span class="line"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件 </span><br><span class="line">log-slave-updates  </span><br><span class="line">#表示自增长字段每次递增的量，指字段一次递增多少，其默认值是1，取值范围是1 .. 65535 </span><br><span class="line">auto-increment-increment&#x3D;2  </span><br><span class="line"># 表示自增长字段从哪个数开始，指自增字段的起始值，他的取值范围是1 .. 65535 </span><br><span class="line">auto-increment-offset&#x3D;1  </span><br></pre></td></tr></table></figure>

<p><strong>Master2配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修改配置文件：vim &#x2F;etc&#x2F;my.cnf </span><br><span class="line">#主服务器唯一ID </span><br><span class="line">server-id&#x3D;3  </span><br><span class="line">#启用二进制日志 </span><br><span class="line">log-bin&#x3D;mysql-bin </span><br><span class="line">#设置不要复制的数据库(可设置多个) </span><br><span class="line">binlog-ignore-db&#x3D;mysql </span><br><span class="line">binlog-ignore-db&#x3D;information_schema </span><br><span class="line">#设置需要复制的数据库 </span><br><span class="line">binlog-do-db&#x3D;需要复制的主数据库名字 </span><br><span class="line">#设置logbin格式 </span><br><span class="line">binlog_format&#x3D;STATEMENT </span><br><span class="line"># 在作为从数据库的时候，有写入操作也要更新二进制日志文件 </span><br><span class="line">log-slave-updates  </span><br><span class="line">#表示自增长字段每次递增的量，指自增字段的起始值，其默认值是1，取值范围是1 .. 65535 </span><br><span class="line">auto-increment-increment&#x3D;2  </span><br><span class="line"># 表示自增长字段从哪个数开始，指自增字段的起始值，他的取值范围是1 .. 6553 </span><br><span class="line">65535 auto-increment-offset&#x3D;2 </span><br></pre></td></tr></table></figure>

<p>==注意:auto-increment-offset不可以是重复的==</p>
<p><strong>Slave1配置</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从服务器唯一ID </span><br><span class="line">server-id&#x3D;2  </span><br><span class="line">#启用中继日志 </span><br><span class="line">relay-log&#x3D;mysql-relay </span><br></pre></td></tr></table></figure>

<p><strong>Slave2配置</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#从服务器唯一ID </span><br><span class="line">server-id&#x3D;4  </span><br><span class="line">#启用中继日志 </span><br><span class="line">relay-log&#x3D;mysql-relay </span><br></pre></td></tr></table></figure>

<ul>
<li>双主机、双从机重启 mysql 服务 </li>
<li>主机从机都关闭防火墙 </li>
<li>在两台主机上建立帐户并授权 slave </li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在主机MySQL里执行授权命令 </span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;slave&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;123123&#x27;</span>; </span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>查看两台主机的状态</strong><code>show master status;</code>,记录binlogid和接入点</p>
</li>
<li><p><strong>设置两台从机的主机</strong>,Slava1 复制 Master1，Slava2 复制 Master2 </p>
</li>
<li><p><strong>两台主机互备</strong>,Master2 复制 Master1，Master1 复制 Master2 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br><span class="line">#复制主机的命令 </span><br><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;主机的IP地址&#39;, </span><br><span class="line">MASTER_USER&#x3D;&#39;slave&#39;, </span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123123&#39;, </span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysql-bin.具体数字&#39;,</span><br><span class="line">MASTER_LOG_POS&#x3D;具体值; </span><br><span class="line">#启动从服务器复制功能 </span><br><span class="line">start slave; </span><br><span class="line">#查看从服务器状态 </span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>修改schema.xml</strong></li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;testdb&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;1&quot;</span>                           <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span>                </span><br><span class="line">    <span class="comment">&lt;!-- can have multi write hosts --&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.128:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span>                                    <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span>                         </span><br><span class="line">        <span class="comment">&lt;!-- can have multi read hosts --&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.127:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>/&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span>    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.126:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span>                                    <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>&gt;</span>                         </span><br><span class="line">        <span class="comment">&lt;!-- can have multi read hosts --&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.140.125:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;123123&quot;</span>/&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span> </span><br><span class="line">#balance=&quot;1&quot;: 全部的readHost与stand by writeHost参与select语句的负载均衡。 </span><br><span class="line">#writeType=&quot;0&quot;: 所有写操作发送到配置的第一个writeHost，第一个挂了切到还生存的第二个 </span><br><span class="line">#writeHost，重新启动后以切换后的为准，切换记录在配置文件中:dnindex.properties 。 </span><br><span class="line">#switchType=&quot;1&quot;: 1 默认值，自动切换。 </span><br><span class="line">#              -1 表示不自动切换 </span><br><span class="line">#              2 基于 MySQL 主从同步的状态决定是否切换。 </span><br></pre></td></tr></table></figure>

<ul>
<li><p>**验证主从复制:**Master1 主机新建库、新建表、insert 记录，Master2 和从机复制 </p>
</li>
<li><p><strong>验证读写分离:</strong></p>
</li>
</ul>
<p>在写主机Master1数据库表mytbl中插入带系统变量数据，造成主从数据不一致</p>
<p> <code>INSERT INTO mytbl VALUES(3,@@hostname); </code>,</p>
<p>在Mycat里查询mytbl表,可以看到查询语句在Master2（host81）、Slava1（host80）、Slava2（host82） 主从三个主机间切换; </p>
<p>停止数据库Master1 在Mycat里插入数据依然成功，Master2自动切换为写主机 </p>
<h2 id="垂直拆分——分库"><a href="#垂直拆分——分库" class="headerlink" title="垂直拆分——分库"></a>垂直拆分——分库</h2><p>按照业务将表进行分类（或者 Schema）来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直（纵向）切分</p>
<p><strong>分库的原则</strong>：有紧密关联关系的表应该在一个库里，相互没有关联关系的表可以分到不同的库里,因为分库的表不可以关联查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#客户表  rows:20万  </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer( </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, </span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">200</span>), </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br><span class="line"><span class="comment">#订单表  rows:600万 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT, </span><br><span class="line">    order_type <span class="built_in">INT</span>, </span><br><span class="line">    customer_id <span class="built_in">INT</span>, </span><br><span class="line">    amount <span class="built_in">DECIMAL</span>(<span class="number">10</span>,<span class="number">2</span>),     </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);  </span><br><span class="line"><span class="comment">#订单详细表 rows:600万 </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> orders_detail(     </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,     </span><br><span class="line">    detail <span class="built_in">VARCHAR</span>(<span class="number">2000</span>),     </span><br><span class="line">    order_id <span class="built_in">INT</span>,     </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">); </span><br><span class="line"><span class="comment">#订单状态字典表 rows:20</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dict_order_type(     </span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> AUTO_INCREMENT,     </span><br><span class="line">    order_type <span class="built_in">VARCHAR</span>(<span class="number">200</span>),     </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">); </span><br></pre></td></tr></table></figure>

<p>客户表分在一个数据库，另外三张都需要关联查询，分在另外一个数据库。 </p>
<p><strong>1.修改 schema 配置文件</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逻辑库  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置customer表分配到dn2 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 数据节点 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- host1 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 心跳检测 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 写主机 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.132:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- host2 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 心跳检测 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 写主机 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hzy&quot;</span></span></span><br><span class="line"><span class="tag">				   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">	<span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通过mycat操作逻辑库默认执行到<code>dataNode=&quot;dn1&quot;</code>,我们指定了<code>customer</code>分配到<code>dataNode=&quot;dn2&quot;</code></p>
<p><code>balance=&quot;0&quot;</code>不设置读写分离</p>
<p><strong>2.两台机器分别创建新的的数据库</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> orders; </span><br></pre></td></tr></table></figure>

<p><strong>3.启动 Mycat</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;mycat console </span><br></pre></td></tr></table></figure>

<p><strong>4.访问 Mycat 进行分库</strong> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -umycat -p123456 -h 192.168.140.128 -P 8066 </span><br><span class="line">#切换到 TESTDB </span><br><span class="line">#创建 4 张表 </span><br><span class="line">#查看表信息，可以看到成功分库 </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/18/wcoehs4nuRV2QXC.png" alt="image-20200518150053652"></p>
<h2 id="水平拆分——分表"><a href="#水平拆分——分表" class="headerlink" title="水平拆分——分表"></a>水平拆分——分表</h2><p>根据表中的数据的逻辑关系按照某个字段的某种规则，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分</p>
<p>MySQL 单表存储数据条数是有瓶颈的，单表达到 1000 万条数据就达到了瓶颈，会影响查询效率，<br>需要进行水平拆分（分表）进行优化。<br>例如：例子中的 orders、orders_detail 都已经达到 600 万行数据，需要进行分表优化。 </p>
<p><strong>1.分表字段</strong> ,以 orders 表为例，可以根据不同自字段进行分表 </p>
<ul>
<li>**id主键或创建时间:**查询订单注重时效，历史订单被查询的次数少，如此分片会造成一个节点访问多，一个访问少，不平均。 </li>
<li><strong>customer_id（客户 id）:</strong> 根据客户 id 去分，两个节点访问平均，一个客户的所有订单都在同一个节点 </li>
</ul>
<p><strong>2.修改schema 配置文件</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 逻辑库  --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 配置customer表分配到dn2 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>orders</strong>表被划分到两个数据节点<code>dn1,dn2</code>,<code>mod_rule</code>分片规则名称</p>
<p>3.<strong>修改rule 配置文件</strong></p>
<p>定义<code>mod_rule</code>分片规则,并指定规则适用字段为 <code>customer_id</code>，选择分片算法 <code>mod-long</code>（对字段求模运算），customer_id 对两个节点求模，根据结果分片 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod_rule&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--配置算法 mod-long 参数 count 为 2，两个节点--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 多少个数据节点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>4.测试分表</strong></p>
<ul>
<li><p>在数据节点 dn2 上建 orders 表 </p>
</li>
<li><p>重启 Mycat，让配置生效 </p>
</li>
<li><p>访问 Mycat 实现分片 </p>
</li>
<li><p>在 mycat 里向 orders 表插入数据，INSERT 字段不能省略 INSERT INTO </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100100</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="number">101</span>,<span class="number">100</span>,<span class="number">100300</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">120000</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="number">101</span>,<span class="number">101</span>,<span class="number">103000</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="number">102</span>,<span class="number">101</span>,<span class="number">100400</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders(<span class="keyword">id</span>,order_type,customer_id,amount) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="number">102</span>,<span class="number">100</span>,<span class="number">100020</span>); </span><br></pre></td></tr></table></figure>

<p>在mycat、dn1、dn2中查看orders表数据，分表成功 </p>
<p><img src="https://i.loli.net/2020/05/19/mqtiIOo78aPzRCM.png" alt="image-20200519102119636"></p>
</li>
</ul>
<h2 id="Mycat-的分片-“join”"><a href="#Mycat-的分片-“join”" class="headerlink" title="Mycat 的分片 “join”"></a>Mycat 的分片 “join”</h2><p>Orders 订单表已经进行分表操作了，和它关联的 orders_detail 订单详情表如何进行 join 查询。 </p>
<p><strong>orders_detail 也要进行分片操作</strong>。Join 的原理如下图： </p>
<p><img src="https://i.loli.net/2020/05/19/PmWTrkAGIJbSfU9.png" alt="image-20200519102406924"></p>
<h3 id="ER-表"><a href="#ER-表" class="headerlink" title="ER 表"></a><strong>ER 表</strong></h3><p>Mycat 借鉴了 NewSQL 领域的新秀 Foundation DB 的设计思路，Foundation DB 创新性的提<br>出了 Table Group 的概念，其将子表的存储位置依赖于主表，并且物理上紧邻存放，因此彻底解决了<br>JION 的效率和性能问 题，根据这一思路，提出了基于 E-R 关系的数据分片策略，子表的记录与所<br>关联的父表记录存放在同一个数据分片上</p>
<p><strong>修改 schema.xml 配置文件</strong></p>
<p>配置orders的子表orders_detail,使用外键order_id进行分片,这样与orders表的数据分布紧密</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>在 dn2 创建 orders_detail 表</strong><br><strong>重启 Mycat</strong><br><strong>访问 Mycat 向 orders_detail 表插入数据</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">1</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">2</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">3</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">4</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">5</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_detail(<span class="keyword">id</span>,detail,order_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">&#x27;detail1&#x27;</span>,<span class="number">6</span>); </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/19/QfZp5g2eSaNi8DB.png" alt="image-20200519104145287"></p>
<p><strong>在mycat、dn1、dn2中运行两个表join语句</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> o.*,od.detail <span class="keyword">from</span> orders o </span><br><span class="line"><span class="keyword">inner</span> <span class="keyword">join</span> orders_detail od <span class="keyword">on</span> o.id=od.order_id; </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/19/5NiYIbGAkLgMw4W.png" alt="image-20200519104338407"></p>
<h3 id="全局表"><a href="#全局表" class="headerlink" title="全局表"></a><strong>全局表</strong></h3><p>在分片的情况下，当业务表因为规模而进行分片以后，业务表与这些附属的字典表之间的关联，<br>就成了比较 棘手的问题，考虑到字典表具有以下几个特性：<br>① 变动不频繁<br>② 数据量总体变化不大<br>③ 数据规模不大，很少有超过数十万条记录 </p>
<p>鉴于此，Mycat 定义了一种特殊的表，称之为“全局表”，全局表具有以下特性： </p>
<ul>
<li>全局表的插入、更新操作会实时在所有节点上执行，保持各个分片的数据一致性 </li>
<li>全局表的查询操作，只从一个节点获取 </li>
<li>全局表可以跟任何一个表进行 JOIN 操作 </li>
</ul>
<p>将字典表或者符合字典表特性的一些表定义为全局表，则从另外一个方面，很好的解决了数据<br>JOIN 的难题。通过全局表+基于 E-R 关系的分片策略，Mycat 可以满足 80%以上的企业应用开发 </p>
<p><strong>修改 schema.xml 配置文件</strong> </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod_rule&quot;</span> &gt;</span>     </span><br><span class="line">    <span class="tag">&lt;<span class="name">childTable</span> <span class="attr">name</span>=<span class="string">&quot;orders_detail&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">joinKey</span>=<span class="string">&quot;order_id&quot;</span> <span class="attr">parentKey</span>=<span class="string">&quot;id&quot;</span> /&gt;</span> <span class="tag">&lt;/<span class="name">table</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 定义全局字典表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;dict_order_type&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">type</span>=<span class="string">&quot;global&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>在 dn2 创建 dict_order_type 表</strong><br><strong>重启 Mycat</strong><br><strong>访问 Mycat 向 dict_order_type 表插入数据</strong> </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">101</span>,<span class="string">&#x27;type1&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dict_order_type(<span class="keyword">id</span>,order_type) <span class="keyword">VALUES</span>(<span class="number">102</span>,<span class="string">&#x27;type2&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p>在Mycat、dn1、dn2中查询表数据 </p>
<p><img src="https://i.loli.net/2020/05/19/bhZ6VcOHtdqkYJX.png" alt="image-20200519105523571"></p>
<h2 id="常用分片规则"><a href="#常用分片规则" class="headerlink" title="常用分片规则"></a>常用分片规则</h2><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a><strong>取模</strong></h3><p> 此规则为对分片字段求摸运算。也是水平分表最常用规则。</p>
<h3 id="分片枚举"><a href="#分片枚举" class="headerlink" title="分片枚举"></a><strong>分片枚举</strong></h3><p>通过在配置文件中配置可能的枚举 id，自己配置分片，本规则适用于特定的场景，比如有些业务<br>需要按照省份或区县来做保存，而全国省份区县固定的，这类业务使用本条规则。 </p>
<ul>
<li><p>修改schema.xml配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 分片枚举 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders_ware_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding_by_intfile&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改rule.xml配置文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding_by_intfile&quot;</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>areacode<span class="tag">&lt;/<span class="name">columns</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>hash-int<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span> </span><br><span class="line">… </span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span>             <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span>                 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;type&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p><code>columns</code>：分片字段，<code>algorithm</code>：分片函数 </p>
<p><code>mapFile</code>：标识配置文件名称，<code>type</code>：分片字段类型0为int型、非0为String  </p>
<p><code>defaultNode</code>：默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就报错 </p>
</li>
<li><p>修改<code>partition-hash-int.txt</code>配置文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">110&#x3D;0  </span><br><span class="line">120&#x3D;1 </span><br><span class="line">#110走dn1, 120走dn2</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Mycat</p>
</li>
<li><p>访问Mycat创建表 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#订单归属区域信息表   </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  orders_ware_info (     </span><br><span class="line">    <span class="string">`id`</span>        <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`order_id`</span>     <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;订单编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`address`</span>    <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">comment</span> <span class="string">&#x27;地址&#x27;</span>,</span><br><span class="line">    <span class="string">`areacode`</span>  <span class="built_in">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">comment</span> <span class="string">&#x27;区域编号&#x27;</span>, </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>插入数据 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;北京&#x27;</span>,<span class="string">&#x27;110&#x27;</span>); <span class="keyword">INSERT</span> <span class="keyword">INTO</span> orders_ware_info(<span class="keyword">id</span>, order_id,address,areacode) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">2</span>,<span class="string">&#x27;天津&#x27;</span>,<span class="string">&#x27;120&#x27;</span>); </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/19/ysuzLmniYANdl7c.png" alt="image-20200519140826389"></p>
</li>
</ul>
<h3 id="范围约定"><a href="#范围约定" class="headerlink" title="范围约定"></a>范围约定</h3><p>此分片适用于，提前规划好分片字段某个范围属于哪个分片。 </p>
<ul>
<li><p>修改schema.xml配置文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;payment_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;auto_sharding_long&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>修改rule.xml配置文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;auto_sharding_long&quot;</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>order_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>rang-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">… </span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span>                 <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span>                 			<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultNode&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span>        </span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>columns</code>：分片字段，<code>algorithm</code>：分片函数  <code>mapFile</code>：标识配置文件名称</p>
<p> <code>defaultNode</code>：默认节点:小于 0 表示不设置默认节点，大于等于 0 表示设置默认节点，设置默认节点如果碰到不识别的枚举值，就让它路由到默认节点，如不设置不识别就 报错 </p>
</li>
<li><p>修改autopartition-long.txt配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0-102&#x3D;0 </span><br><span class="line">103-200&#x3D;1  </span><br></pre></td></tr></table></figure>
</li>
<li><p>重启 Mycat </p>
</li>
<li><p>访问Mycat创建表 </p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#支付信息表   </span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  payment_info (     </span><br><span class="line">    <span class="string">`id`</span>        <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`order_id`</span>     <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;订单编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`payment_status`</span>    <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;支付状态&#x27;</span>,     </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li>插入数据</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="number">0</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="number">1</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id ,payment_status) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="number">0</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> payment_info (<span class="keyword">id</span>,order_id,payment_status) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>查询Mycat、dn1、dn2可以看到数据分片效果 </li>
</ul>
<p><img src="https://i.loli.net/2020/05/19/ifvRxBLUYjcDp7G.png" alt="image-20200519142804687"></p>
<h3 id="日期-天-分片"><a href="#日期-天-分片" class="headerlink" title="日期(天)分片"></a>日期(天)分片</h3><ul>
<li><p>修改schema.xml配置文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 日期分片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;login_info&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span> <span class="attr">rule</span>=<span class="string">&quot;sharding_by_date&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span> 	</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改rule.xml配置文件 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;sharding_by_date&quot;</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">rule</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>login_date<span class="tag">&lt;/<span class="name">columns</span>&gt;</span>                         </span><br><span class="line">        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>shardingByDate<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;/<span class="name">rule</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;shardingByDate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByDate&quot;</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2019-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span>                 </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sEndDate&quot;</span>&gt;</span>2019-01-04<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sPartionDay&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span>          </span><br><span class="line"><span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>columns</code>：分片字段，<code>algorithm</code>：分片函数  <code>dateFormat</code> ：日期格式  <code>sBeginDate</code> ：开始日期  </p>
<p><code>sEndDate</code>：结束日期,则代表数据达到了这个日期的分片后循环从开始分片插入</p>
<p><code>sPartionDay</code> ：分区天数，即默认从开始日期算起，分隔 2 天一个分区 </p>
</li>
<li><p>重启 Mycat </p>
</li>
<li><p>访问Mycat创建表</p>
</li>
<li><p>用户信息表   </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span>  login_info (     </span><br><span class="line">    <span class="string">`id`</span>        <span class="built_in">INT</span> AUTO_INCREMENT <span class="keyword">comment</span> <span class="string">&#x27;编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`user_id`</span>     <span class="built_in">INT</span> <span class="keyword">comment</span> <span class="string">&#x27;用户编号&#x27;</span>,     </span><br><span class="line">    <span class="string">`login_date`</span>    <span class="built_in">date</span> <span class="keyword">comment</span> <span class="string">&#x27;登录日期&#x27;</span>,     </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">);  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">101</span>,<span class="string">&#x27;2019-01-01&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">102</span>,<span class="string">&#x27;2019-01-02&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">103</span>,<span class="string">&#x27;2019-01-03&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">104</span>,<span class="string">&#x27;2019-01-04&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">103</span>,<span class="string">&#x27;2019-01-05&#x27;</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> login_info(<span class="keyword">id</span>,user_id,login_date) <span class="keyword">VALUES</span> (<span class="number">6</span>,<span class="number">104</span>,<span class="string">&#x27;2019-01-06&#x27;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>查询Mycat、dn1、dn2可以看到数据分片效果 </p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/05/19/RNLUr5a6AsQtknK.png" alt="image-20200519144530199"></p>
<h2 id="全局序列"><a href="#全局序列" class="headerlink" title="全局序列"></a>全局序列</h2><p>在实现分库分表的情况下，数据库自增主键已无法保证自增主键的全局唯一。为此，Mycat 提供<br>了全局 sequence，并且提供了包含本地配置和数据库配置等多种实现方式 </p>
<p><strong>1、 本地文件</strong><br>此方式 Mycat 将 sequence 配置到文件中，当使用到 sequence 中的配置后，Mycat 会更新<br>classpath 中的 sequence_conf.properties 文件中 sequence 当前的值。 </p>
<ul>
<li><p>优点：本地加载，读取速度较快 </p>
</li>
<li><p>缺点：抗风险能力差，Mycat 所在主机宕机后，无法读取本地文件。 </p>
</li>
</ul>
<p><strong>2、 数据库方式</strong><br>利用数据库一个表 来进行计数累加。但是并不是每次生成序列都读写数据库，这样效率太低。<br>Mycat 会预加载一部分号段到 Mycat 的内存中，这样大部分读写序列都是在内存中完成的。<br>如果内存中的号段用完了 Mycat 会再向数据库要一次。 </p>
<p>问：那如果 Mycat 崩溃了 ，那内存中的序列岂不是都没了？<br>是的。如果是这样，那么 Mycat 启动后会向数据库申请新的号段，原有号段会弃用。<br>也就是说如果 Mycat 重启，那么损失是当前的号段没用完的号码，但是不会因此出现主键重复 </p>
<ul>
<li><p>全局序列表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在 dn1 上创建全局序列表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> MYCAT_SEQUENCE (</span><br><span class="line">    <span class="keyword">NAME</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    current_value <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">increment</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">100</span>, </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span>(<span class="keyword">NAME</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span>; </span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建全局序列所需函数 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_currval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)</span><br><span class="line"><span class="keyword">DETERMINISTIC</span>   </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">DECLARE</span> retval <span class="built_in">VARCHAR</span>(<span class="number">64</span>); </span><br><span class="line"><span class="keyword">SET</span> retval=<span class="string">&quot;-999999999,null&quot;</span>; </span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">CAST</span>(current_value <span class="keyword">AS</span> <span class="built_in">CHAR</span>),<span class="string">&quot;,&quot;</span>,<span class="keyword">CAST</span>(<span class="keyword">increment</span> <span class="keyword">AS</span> <span class="built_in">CHAR</span>)) <span class="keyword">INTO</span> retval <span class="keyword">FROM</span> MYCAT_SEQUENCE </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name;</span><br><span class="line">RETURN retval; </span><br><span class="line"><span class="keyword">END</span> $$ </span><br><span class="line">DELIMITER ; </span><br><span class="line"></span><br><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_setval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>),<span class="keyword">VALUE</span> <span class="built_in">INTEGER</span>) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>) </span><br><span class="line"><span class="keyword">DETERMINISTIC</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE </span><br><span class="line"><span class="keyword">SET</span> current_value = <span class="keyword">VALUE</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name; </span><br><span class="line">RETURN mycat_seq_currval(seq_name); </span><br><span class="line"><span class="keyword">END</span> $$ D</span><br><span class="line">ELIMITER ; </span><br><span class="line"></span><br><span class="line">DELIMITER $$ </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> mycat_seq_nextval(seq_name <span class="built_in">VARCHAR</span>(<span class="number">50</span>)) <span class="keyword">RETURNS</span> <span class="built_in">VARCHAR</span>(<span class="number">64</span>)  <span class="keyword">DETERMINISTIC</span> </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line"><span class="keyword">UPDATE</span> MYCAT_SEQUENCE </span><br><span class="line"><span class="keyword">SET</span> current_value = current_value + <span class="keyword">increment</span> </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">NAME</span> = seq_name; </span><br><span class="line">RETURN mycat_seq_currval(seq_name); </span><br><span class="line"><span class="keyword">END</span> $$ </span><br><span class="line">DELIMITER ; </span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化序列表记录</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> MYCAT_SEQUENCE(<span class="keyword">NAME</span>,current_value,<span class="keyword">increment</span>) <span class="keyword">VALUES</span> (<span class="string">&#x27;ORDERS&#x27;</span>, <span class="number">400000</span>, <span class="number">100</span>); </span><br></pre></td></tr></table></figure>
</li>
<li><p>修改 Mycat 配置 </p>
<p>修改<code>sequence_db_conf.properties</code> </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#sequence stored in datanode</span></span><br><span class="line"><span class="attr">GLOBAL</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">COMPANY</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">CUSTOMER</span>=<span class="string">dn1</span></span><br><span class="line"><span class="attr">ORDERS</span>=<span class="string">dn1</span></span><br></pre></td></tr></table></figure>

<p>意思是 ORDERS这个序列在dn1这个节点上，具体dn1节点是哪台机子，请参考schema.xml </p>
</li>
<li><p>修改server.xml </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sequnceHandlerType&quot;</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>全局序列类型：0-本地文件，1-数据库方式，2-时间戳方式。此处应该修改成1。 </p>
</li>
<li><p>重启Mycat </p>
</li>
<li><p>验证全局序列<br>登录 Mycat，插入数据,id使用<code>MYCATSEQ_ORDERS</code>全局序列表中的下一个值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> orders(<span class="keyword">id</span>,amount,customer_id,order_type) <span class="keyword">values</span>(<span class="keyword">next</span> <span class="keyword">value</span> <span class="keyword">for</span> MYCATSEQ_ORDERS,<span class="number">1000</span>,<span class="number">101</span>,<span class="number">102</span>); </span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2020/05/19/1RouN4We3VJlOTz.png" alt="image-20200519152659030"></p>
</li>
<li><p>重启Mycat后，再次插入数据，再查询 </p>
<p><img src="https://i.loli.net/2020/05/19/PcFlzWhGDpCQa1r.png" alt="image-20200519152918153"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库中间件</tag>
        <tag>分库分表</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎和索引</title>
    <url>/2019/06/12/MySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="mysql逻辑架构"><a href="#mysql逻辑架构" class="headerlink" title="mysql逻辑架构"></a>mysql逻辑架构</h1><img src="https://gitee.com/hanzhengyu/picture-bed-2021/raw/master/20210304111747.png" class="full-image" />

<a id="more"></a>

<p><strong>利用show profile查看sql的执行周期</strong></p>
<p>修改配置文件/etc/my.cnf,新增以下一行,并重启mysql</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">query_cache_type&#x3D;1</span><br></pre></td></tr></table></figure>

<p>开启profiling:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like &#x27;%profiling%&#x27;;</span><br><span class="line">mysql&gt; set profiling=1;</span><br></pre></td></tr></table></figure>

<p> 显示最近的几次查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql&gt; show profiles;</span><br><span class="line">+<span class="comment">----------+------------+-----------------------------------+</span></span><br><span class="line">| Query_ID | Duration   | Query                             |</span><br><span class="line">+<span class="comment">----------+------------+-----------------------------------+</span></span><br><span class="line">|        1 | 0.00136600 | <span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">&#x27;%profiling%&#x27;</span> |</span><br><span class="line">|        <span class="number">2</span> | <span class="number">0.00049975</span> | <span class="keyword">select</span> * <span class="keyword">from</span> mytbl2 <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> |</span><br><span class="line">+<span class="comment">----------+------------+-----------------------------------+</span></span><br><span class="line">查询<span class="keyword">id</span>       时长         <span class="keyword">sql</span></span><br></pre></td></tr></table></figure>

<p>查看详细过程:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu,<span class="keyword">block</span> io <span class="keyword">for</span> <span class="keyword">query</span> 编号</span><br><span class="line">就是上图的过程</span><br></pre></td></tr></table></figure>

<h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>查看存储引擎:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure>

<p><strong>1、InnoDB存储引擎</strong><br>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。</p>
<p><strong>2、MyISAM存储引擎</strong><br>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。</p>
<p><strong>3、Archive引擎</strong><br>Archive档案存储引擎只支持INSERT和SELECT操作，在MySQL5.1之前不支持索引。<br>Archive表适合日志和数据采集类应用。<br>根据英文的测试结论来看，Archive表比MyISAM表要小大约75%，比支持事务处理的InnoDB表小大约83%。</p>
<p><strong>4、Blackhole引擎</strong><br>Blackhole引擎没有实现任何存储机制，它会丢弃所有插入的数据，不做任何保存。但服务器会记录Blackhole表的日志，所以可以用于复制数据到备库，或者简单地记录到日志。但这种应用方式会碰到很多问题，因此并不推荐。 </p>
<p><strong>5、CSV引擎</strong><br>CSV引擎可以将普通的CSV文件作为MySQL的表来处理，但不支持索引。<br>CSV引擎可以作为一种数据交换的机制，非常有用。<br>CSV存储的数据直接可以在操作系统里，用文本编辑器，或者excel读取。</p>
<p><strong>6、Memory引擎</strong><br>如果需要快速地访问数据，并且这些数据不会被修改，重启以后丢失也没有关系，那么使用Memory表是非常有用。Memory表至少比MyISAM表要快一个数量级。</p>
<p><strong>7、Federated引擎</strong><br>Federated引擎是访问其他MySQL服务器的一个代理，尽管该引擎看起来提供了一种很好的跨服务器的灵活性，但也经常带来问题，因此默认是禁用的。</p>
<p>常用的有MyISAM和InnoDB</p>
<p><strong>它们的区别:</strong></p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>MyISAM</th>
<th>InnoDB</th>
</tr>
</thead>
<tbody><tr>
<td><strong>外键</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>事务</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>行表锁</strong></td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
<td>行锁,操作时只锁某一行，不对其它行有影响，适合高并发的操作</td>
</tr>
<tr>
<td><strong>缓存</strong></td>
<td>只缓存索引，不缓存真实数据</td>
<td>不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响</td>
</tr>
<tr>
<td><strong>关注点</strong></td>
<td>节省资源、消耗少、简单业务</td>
<td>并发写、事务、更大资源</td>
</tr>
</tbody></table>
<p>mysql默认使用InnoDB,但mysql内置的系统表使用MyISAM,因为没有高并发,而且节省资源.</p>
<p>mysql单表瓶颈500w数据,单库瓶颈5000w数据</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>MySQL官方对索引的定义为:<strong>索引(Index)是帮助MySQL高效获取数据的数据结构.</strong><br>索引的目的在于提高查询效率，可以类比字典，</p>
<p>如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。</p>
<p>如果没有索引，那么你可能需要a—-z，如果我想找到Java开头的单词呢？或者Oracle开头的单词呢？</p>
<p>在数据之外，<strong>数据库系统还维护着满足特定查找算法的数据结构</strong>，这些数据结构以某种方式引用（指向）数据，<br>这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。下图就是一种可能的索引方式示例：</p>
<p><img src="https://gitee.com/hanzhengyu/picture-bed-2021/raw/master/20210304111800.png"></p>
<p>左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址<br>为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。</p>
<p><strong>优势:</strong></p>
<ul>
<li>提高数据检索的效率,降低数据库的IO成本</li>
<li>通过索引列对数据进行排序,降低数据排序的成本,降低了CPU的消耗</li>
</ul>
<p><strong>劣势:</strong></p>
<ul>
<li>虽然索引大大提高了查询速度,同时却会降低更新表的速度(INSERT,UPDATE,DELETE),因为更新表是,mysql不仅要保存数据,还要保存索引文件每次更新添加了索引列的字段,都会调整因为更新所带来的键值变化后的索引信息</li>
<li>实际上索引也是一张表,该表保存了主键与索引字段,并指向实体表的记录,所以索引也是要占用磁盘空间的</li>
</ul>
<h2 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h2><h3 id="BTree"><a href="#BTree" class="headerlink" title="BTree"></a>BTree</h3><p><img src="D:\study\Markdown\images\btree.png"></p>
<p>1.索引</p>
<p>2.红色方块代表指向数据的指针</p>
<p>3.黄色代表向下节点的索引</p>
<p>比如要查找98,与17,35对比,小于两者走P1,在它们之间走P2,大于它们走P3,以此类推找到最终的结果</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B+Tree"></a>B+Tree</h3><p><img src="D:\study\Markdown\images\b+tree.png"></p>
<p>1.索引</p>
<p>2.向下节点的索引</p>
<p>走到最终的叶子节点才有指向数据的指针</p>
<h3 id="B-Tree与B-Tree-的区别"><a href="#B-Tree与B-Tree-的区别" class="headerlink" title="B+Tree与B-Tree 的区别"></a>B+Tree与B-Tree 的区别</h3><p>　1）B-树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树的非叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。<br>　 2）在B-树中，越靠近根节点的记录查找时间越快，只要找到关键字即可确定记录的存在；而B+树中每个记录的查找时间基本是一样的，都需要从根节点走到叶子节点，而且在叶子节点中还要再比较关键字。从这个角度看B-树的性能好像要比B+树好，而在实际应用中却是B+树的性能要好些。因为B+树的非叶子节点不存放实际的数据，这样<strong>每个节点可容纳的元素个数比B-树多，树高比B-树小，这样带来的好处是减少磁盘访问次数。尽管B+树找到一个记录所需的比较次数要比B-树多，但是一次磁盘访问的时间相当于成百上千次内存比较的时间，因此实际中B+树的性能可能还会好些</strong>，而且B+树的叶子节点使用指针连接在一起，方便顺序遍历（例如查看一个目录下的所有文件，一个表中的所有记录等），这也是很多数据库和文件系统使用B+树的缘故。<br>　<br>思考：为什么说B+树比B-树更适合实际应用中操作系统的文件索引和数据库索引？ </p>
<ol>
<li>B+树的磁盘读写代价更低<br>　　B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 </li>
<li>B+树的查询效率更加稳定<br>　　由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</li>
</ol>
<h3 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h3><p>​    同一问题可用不同算法解决，而一个算法的质量优劣将影响到算法乃至程序的效率。算法分析的目的在于选择合适算法和改进算法。</p>
<p><img src="D:\study\Markdown\images\事件复杂度2.bmp"></p>
<h3 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h3><p>聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。<br>术语‘聚簇’表示数据行和相邻的键值聚簇的存储在一起。<br> 如下图，左侧的索引就是聚簇索引，因为数据行在磁盘的排列和索引排序保持一致。</p>
<p><img src="https://i.loli.net/2020/05/17/ShCrF894WibJ2dV.png"></p>
<p>聚簇索引的好处：<br>按照聚簇索引排列顺序，查询显示一定范围数据的时候，由于数据都是紧密相连，数据库不不用从多个数据块中提取数据，所以节省了大量的io操作。<br>聚簇索引的限制：<br>对于mysql数据库目前只有innodb数据引擎支持聚簇索引，而Myisam并不支持聚簇索引。<br>由于数据物理存储排序方式只能有一种，所以每个Mysql的表只能有一个聚簇索引。一般情况下就是该表的主键。<br>为了充分利用聚簇索引的聚簇的特性，所以innodb表的主键列尽量选用有序的顺序id，而不建议用无序的id，比如uuid这种。</p>
<h2 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h2><h3 id="单值索引"><a href="#单值索引" class="headerlink" title="单值索引"></a>单值索引</h3><p>即一个索引只包含单个列,一个表可以有多个单列索引</p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span>  AUTO_INCREMENT ,customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> (customer_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>单独建单值索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">INDEX</span> idx_customer_name <span class="keyword">ON</span> customer(customer_name); </span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_customer_name  <span class="keyword">on</span> customer;</span><br></pre></td></tr></table></figure>

<h3 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h3><p>索引列必须唯一,但允许有空值</p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span>  AUTO_INCREMENT ,customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_no)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>单独建唯一索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">UNIQUE</span> <span class="keyword">INDEX</span> idx_customer_no <span class="keyword">ON</span> customer(customer_no); </span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_customer_no <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure>

<h3 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h3><p>设定为主键的字段会自动建立索引,innodb为聚簇索引</p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span>  AUTO_INCREMENT ,customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer2 (<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span>   ,customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>) </span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p> 单独建主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer </span><br><span class="line"> <span class="keyword">add</span> PRIMARY <span class="keyword">KEY</span> customer(customer_no);  </span><br></pre></td></tr></table></figure>

<p>删除建主键索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> customer </span><br><span class="line"> <span class="keyword">drop</span> PRIMARY <span class="keyword">KEY</span> ;  </span><br></pre></td></tr></table></figure>

<p>修改建主键索引：<br>必须先删除掉(drop)原索引，再新建(add)索引</p>
<h3 id="复合索引"><a href="#复合索引" class="headerlink" title="复合索引"></a>复合索引</h3><p>即一个索引包含多个列</p>
<p>随表一起建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> customer (<span class="keyword">id</span> <span class="built_in">INT</span>(<span class="number">10</span>) <span class="keyword">UNSIGNED</span>  AUTO_INCREMENT ,customer_no <span class="built_in">VARCHAR</span>(<span class="number">200</span>),customer_name <span class="built_in">VARCHAR</span>(<span class="number">200</span>),</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>),</span><br><span class="line">  <span class="keyword">KEY</span> (customer_name),</span><br><span class="line">  <span class="keyword">UNIQUE</span> (customer_name),</span><br><span class="line">  <span class="keyword">KEY</span> (customer_no,customer_name)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>单独建索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">INDEX</span> idx_no_name <span class="keyword">ON</span> customer(customer_no,customer_name); </span><br></pre></td></tr></table></figure>

<p>删除索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> idx_no_name  <span class="keyword">on</span> customer ;</span><br></pre></td></tr></table></figure>

<h3 id="使用ALTER命令"><a href="#使用ALTER命令" class="headerlink" title="使用ALTER命令"></a>使用ALTER命令</h3><p><code>ALTER TABLE tbl_name ADD UNIQUE index_name (column_list)</code>: 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。</p>
<p><code>ALTER TABLE tbl_name ADD INDEX index_name (column_list)</code>: 添加普通索引，索引值可出现多次。</p>
<p><code>ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list)</code>:该语句指定了索引为 FULLTEXT ，用于全文索引。</p>
<h3 id="哪些情况需要创建索引"><a href="#哪些情况需要创建索引" class="headerlink" title="哪些情况需要创建索引"></a>哪些情况需要创建索引</h3><ul>
<li>主键自动建立唯一索引</li>
<li>频繁作为查询条件的字段应该创建索引</li>
<li>查询中与其他表关联的字段,外键关系应创建索引</li>
<li>单键/组合索引的选择问题,组合索引性价比更高</li>
<li>查询中排序的字段,提高排序速度</li>
<li>查询中统计或者分组字段</li>
</ul>
<h3 id="哪些情况不要创建索引"><a href="#哪些情况不要创建索引" class="headerlink" title="哪些情况不要创建索引"></a>哪些情况不要创建索引</h3><ul>
<li>表记录太少</li>
<li>经常增删改的表或者字段</li>
<li>where条件里用不到的字段</li>
<li>过滤性不好的字段(如性别)</li>
</ul>
<h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>衡量是否需要加索引的真正指标</p>
<p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句,从而知道MySQL是如何处理你的SQL语句的,分析你的查询语句或是表结构的性能瓶颈.</p>
<p><strong>通过EXPLAIN可以分析出以下信息</strong>:</p>
<ul>
<li>表的读取顺序</li>
<li>哪些索引可以使用</li>
<li>数据读取操作的操作类型</li>
<li>哪些索引被实际使用</li>
<li>表之间的引用</li>
<li>每张表有多少行被物理查询</li>
</ul>
<p><strong>语法</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * FROM...</span><br></pre></td></tr></table></figure>

<p>SQL_NO_CACHE:关闭缓存</p>
<h3 id="执行计划包含的信息"><a href="#执行计划包含的信息" class="headerlink" title="执行计划包含的信息:"></a>执行计划包含的信息:</h3><img src="https://i.loli.net/2020/05/17/6ZHISBnUur4slzG.png" alt="image-20200401111843128" style="zoom:150%;" />

<ul>
<li><p><strong>==id==</strong>:SELECT查询的序列号,包含一组数字,表示查询中执行SELECT子句或操作表的顺序.</p>
<p>三种情况:</p>
<ul>
<li>id相同,执行顺序由上至下</li>
<li>id不同,如果是子查询,id的序号会递增,id值越大优先级越高</li>
<li>id相同不同,同时存在,id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行</li>
</ul>
<p>关注点:</p>
<ul>
<li>id号每个号码,表示一趟独立的查询,一个sql的查询趟数越少越好.</li>
</ul>
</li>
<li><p><strong>==type==</strong>:显示查询使用了何种类型, 是较为重要的一个指标</p>
<p><img src="images%5Cimage-20200401123805293.png" alt="image-20200401123805293"></p>
<p>结果值从最好到最坏依次是： </p>
<p><code>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL </code></p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>system</td>
<td>表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</td>
</tr>
<tr>
<td>const</td>
<td>表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快;如将主键置于where列表中，MySQL就能将该查询转换为一个常量</td>
</tr>
<tr>
<td>eq_ref</td>
<td>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</td>
</tr>
<tr>
<td>ref</td>
<td>非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</td>
</tr>
<tr>
<td>==range==</td>
<td>只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引;一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询;这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</td>
</tr>
<tr>
<td>==index==</td>
<td>出现index是sql使用了索引但是没用通过索引进行过滤，一般是使用了覆盖索引或者是利用索引进行了排序分组</td>
</tr>
<tr>
<td>==all==</td>
<td>Full Table Scan，将遍历全表以找到匹配的行</td>
</tr>
<tr>
<td>index_merge</td>
<td>在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</td>
</tr>
<tr>
<td>ref_or_null</td>
<td>对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</td>
</tr>
<tr>
<td>index_subquery</td>
<td>利用索引来关联子查询，不再全表扫描</td>
</tr>
<tr>
<td>unique_subquery</td>
<td>该联接类型类似于index_subquery。 子查询中的唯一索引</td>
</tr>
</tbody></table>
</li>
<li><p><strong>==key_len==</strong>: 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 key_len字段能够帮你检查是否充分的利用上了索引,越大越好</p>
</li>
<li><p><strong>==rows==</strong>:rows列显示MySQL认为它执行查询时必须检查的行数。<br>越少越好</p>
</li>
<li><p><strong>key</strong>:实际使用的索引,如果为NULL,则没有使用索引; 查询中若使用了覆盖索引，则该索引和查询的select字段重叠</p>
</li>
<li><p><strong>==Extra==</strong>:包含不适合在其他列中显示但十分重要的额外信息</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>==Using filesort==</td>
<td>说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”  <strong>排序字段需要加索引</strong></td>
</tr>
<tr>
<td>==Using temporay==</td>
<td>使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。<strong>分组字段需要加索引</strong></td>
</tr>
<tr>
<td>USING index</td>
<td>表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！<br/>如果同时出现using where，表明索引被用来执行索引键值的查找;<br/>如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。<br/>利用索引进行了排序或分组</td>
</tr>
<tr>
<td>Using where</td>
<td>表明使用了where过滤</td>
</tr>
<tr>
<td>==using join buffer==</td>
<td>使用了连接缓存,<strong>表之间的连接条件需要加索引</strong></td>
</tr>
<tr>
<td>impossible where</td>
<td>where子句的值总是false，不能用来获取任何元组,sql不正确的提醒</td>
</tr>
<tr>
<td>select tables optimized away</td>
<td>在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者<br/>对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，<br/>查询执行计划生成的阶段即完成优化。</td>
</tr>
</tbody></table>
</li>
<li><p><strong>ref</strong>:显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值</p>
</li>
<li><p><strong>select_type</strong>:查询的类型,主要是用于区别普通查询,联合查询,子查询等复杂查询</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>SIMPLE</td>
<td>简单的 select 查询,查询中不包含子查询或者UNION</td>
</tr>
<tr>
<td>PRIMARY</td>
<td>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</td>
</tr>
<tr>
<td>DERIVED</td>
<td>在FROM列表中包含的子查询被标记为DERIVED(衍生)MySQL会递归执行这些子查询, 把结果放在临时表里。</td>
</tr>
<tr>
<td>SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询</td>
</tr>
<tr>
<td>DEPENDENT SUBQUERY</td>
<td>在SELECT或WHERE列表中包含了子查询,子查询基于外层</td>
</tr>
<tr>
<td>UNCACHEABLE SUBQUERY</td>
<td>不能使用缓存的子查询,通常是使用系统变量作为WHERE条件的查询</td>
</tr>
<tr>
<td>UNION</td>
<td>若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</td>
</tr>
<tr>
<td>UNION RESULT</td>
<td>从UNION表获取结果的SELECT</td>
</tr>
</tbody></table>
</li>
<li><p><strong>table</strong>:显示这一行的数据是关于那张表的</p>
</li>
<li><p><strong>partitions</strong>:代表分区表中命中情况,非区分表,该项为null</p>
</li>
<li><p><strong>possible_keys</strong>:显示可能应用在这张表中的索引，一个或多个。<br>查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
</li>
</ul>
<h3 id="如何正确的删除索引"><a href="#如何正确的删除索引" class="headerlink" title="如何正确的删除索引"></a>如何正确的删除索引</h3><p><strong>mysql索引存放在<code>information_schema</code>元数据库<code>STATISTICS</code>统计表中</strong></p>
<p>取出某个表的索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> INDEX_NAME <span class="keyword">FROM</span> information_schema.statistics</span><br><span class="line"><span class="keyword">WHERE</span> TABLE_NAME=<span class="string">&#x27;t_emp&#x27;</span> <span class="keyword">AND</span> TABLE_SCHEMA=<span class="string">&#x27;mydb&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> INDEX_NAME &lt;&gt; <span class="string">&#x27;PRIMARY&#x27;</span> <span class="keyword">AND</span> SEQ_IN_INDEX=<span class="number">1</span></span><br><span class="line"><span class="comment">#排除主键索引</span></span><br></pre></td></tr></table></figure>

<p>如何遍历这个索引集合</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">CURSOR 游标</span><br><span class="line">FETCH xxx INTO xxx</span><br></pre></td></tr></table></figure>

<p>如何让mysql执行一个字符串</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PREPARE</span> 预编译 xxx</span><br><span class="line"><span class="keyword">EXECUTE</span></span><br></pre></td></tr></table></figure>

<p><strong>用存储过程实现</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"><span class="keyword">CREATE</span>  <span class="keyword">PROCEDURE</span> <span class="string">`proc_drop_index`</span>(dbname <span class="built_in">VARCHAR</span>(<span class="number">200</span>),tablename <span class="built_in">VARCHAR</span>(<span class="number">200</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">       <span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> ct <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _index <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">       <span class="keyword">DECLARE</span> _cur <span class="keyword">CURSOR</span> <span class="keyword">FOR</span>  <span class="keyword">SELECT</span>   index_name   <span class="keyword">FROM</span> information_schema.STATISTICS   <span class="keyword">WHERE</span> table_schema=dbname <span class="keyword">AND</span> table_name=tablename <span class="keyword">AND</span> seq_in_index=<span class="number">1</span> <span class="keyword">AND</span>    index_name &lt;&gt;<span class="string">&#x27;PRIMARY&#x27;</span>  ;</span><br><span class="line">       <span class="keyword">DECLARE</span>  CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">FOR</span> <span class="keyword">NOT</span> <span class="keyword">FOUND</span> <span class="keyword">set</span> done=<span class="number">2</span> ;      </span><br><span class="line">        OPEN _cur;</span><br><span class="line">        FETCH   _cur INTO _index;</span><br><span class="line">        WHILE  _index&lt;&gt;&#x27;&#x27; DO </span><br><span class="line">               <span class="keyword">SET</span> @<span class="keyword">str</span> = <span class="keyword">CONCAT</span>(<span class="string">&quot;drop index &quot;</span>,_index,<span class="string">&quot; on &quot;</span>,tablename ); </span><br><span class="line">               <span class="keyword">PREPARE</span> sql_str <span class="keyword">FROM</span> @<span class="keyword">str</span> ;</span><br><span class="line">               <span class="keyword">EXECUTE</span>  sql_str;</span><br><span class="line">               <span class="keyword">DEALLOCATE</span> <span class="keyword">PREPARE</span> sql_str;</span><br><span class="line">               <span class="keyword">SET</span> _index=<span class="string">&#x27;&#x27;</span>; </span><br><span class="line">               FETCH   _cur INTO _index; </span><br><span class="line">        <span class="keyword">END</span> <span class="keyword">WHILE</span>;</span><br><span class="line">   CLOSE _cur;</span><br><span class="line">   <span class="keyword">END</span>$$</span><br></pre></td></tr></table></figure>

<h3 id="索引注意事项"><a href="#索引注意事项" class="headerlink" title="索引注意事项"></a>索引注意事项</h3><p>导致索引失效的细节</p>
<h4 id="全值匹配我最爱"><a href="#全值匹配我最爱" class="headerlink" title="全值匹配我最爱"></a>全值匹配我最爱</h4><p>where条件后的字段都应该建立索引, 达到最大索引命中</p>
<h4 id="最佳左前缀法则"><a href="#最佳左前缀法则" class="headerlink" title="最佳左前缀法则"></a>最佳左前缀法则</h4><p>如果索引包含了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。</p>
<h4 id="不在索引列上做任何操作"><a href="#不在索引列上做任何操作" class="headerlink" title="不在索引列上做任何操作"></a>不在索引列上做任何操作</h4><p>计算、函数、(自动or手动)类型转换，会导致索引失效而转向全表扫描,如下:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span>  <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span>   emp.name  <span class="keyword">LIKE</span> <span class="string">&#x27;abc%&#x27;</span> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">EXPLAIN</span>   <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span>   <span class="keyword">LEFT</span>(emp.name,<span class="number">3</span>)  = <span class="string">&#x27;abc&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="存储引擎不能使用索引中范围条件右边的列"><a href="#存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="存储引擎不能使用索引中范围条件右边的列"></a>存储引擎不能使用索引中范围条件右边的列</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span>  SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.age=<span class="number">30</span> <span class="keyword">AND</span> emp.deptId&gt;<span class="number">20</span> <span class="keyword">AND</span> emp.name = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line"><span class="comment">#需要保证范围查询的字段在最右边</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> idx_age_name_deptid <span class="keyword">ON</span> emp(age,<span class="keyword">name</span>,deptId);</span><br></pre></td></tr></table></figure>

<h4 id="mysql-在使用不等于-或者-lt-gt-的时候无法使用索引会导致全表扫描"><a href="#mysql-在使用不等于-或者-lt-gt-的时候无法使用索引会导致全表扫描" class="headerlink" title="mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描"></a>mysql 在使用不等于(!= 或者&lt;&gt;)的时候无法使用索引会导致全表扫描</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span>   emp.name &lt;&gt;  <span class="string">&#x27;abc&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="is-not-null-无法使用索引-但是is-null可以使用索引"><a href="#is-not-null-无法使用索引-但是is-null可以使用索引" class="headerlink" title="is not null 无法使用索引,但是is null可以使用索引"></a>is not null 无法使用索引,但是is null可以使用索引</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> age <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<h4 id="like以通配符开头-‘-abc…’-索引失效"><a href="#like以通配符开头-‘-abc…’-索引失效" class="headerlink" title="like以通配符开头(‘%abc…’)索引失效"></a>like以通配符开头(‘%abc…’)索引失效</h4><p>模糊查询最好明确首字母</p>
<h4 id="字符串不加单引号索引失效"><a href="#字符串不加单引号索引失效" class="headerlink" title="字符串不加单引号索引失效"></a>字符串不加单引号索引失效</h4><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> SQL_NO_CACHE * <span class="keyword">FROM</span> emp <span class="keyword">WHERE</span> emp.name=<span class="number">123</span></span><br></pre></td></tr></table></figure>

<p>注意实体类中的字段类型要与mysql中一致,否则导致自动类型转换,索引失效</p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><ul>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前Query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</li>
<li>书写sql语句时，尽量避免造成索引失效的情况</li>
</ul>
<h2 id="关联查询优化"><a href="#关联查询优化" class="headerlink" title="关联查询优化"></a>关联查询优化</h2><p><strong>驱动表与被驱动表</strong></p>
<p>1.当使用left join时，左表是驱动表，右表是被驱动表<br>2.当使用right join时，右表时驱动表，左表是驱动表<br>3.当使用join时，mysql会选择数据量比较小的表作为驱动表，大表作为被驱动表</p>
<p>在sql优化中，永远是以小表驱动大表</p>
<p>join查询在有索引条件下:<br>驱动表有索引不会使用到索引<br>被驱动表建立索引会使用到索引</p>
<p>MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。</p>
<p>驱动表的全表扫描是无法避免的,所以应该为被驱动表建立索引</p>
<p>LEFT JOIN时 数据量小的表应该作为驱动表</p>
<p>INNER JOIN时 mysql会自己选择驱动表</p>
<p>子查询尽量不要放在被驱动表，有可能使用不到索引</p>
<p>能够直接多表关联的尽量直接关联，不用子查询</p>
<p>STRAIGHT_JOIN 功能和INNER JOIN一样,但可指定前面的表为驱动表,==注意需要明确两张表的数量集==</p>
<h2 id="子查询优化"><a href="#子查询优化" class="headerlink" title="子查询优化"></a><strong>子查询优化</strong></h2><p> 尽量不要使用not in  或者 not exists<br> 用left outer join  on  xxx is null 替代</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp a <span class="keyword">WHERE</span> a.id <span class="keyword">NOT</span> <span class="keyword">IN</span></span><br><span class="line">(<span class="keyword">SELECT</span> b.CEO <span class="keyword">FROM</span> dept b <span class="keyword">WHERE</span> b.CEO <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> emp a <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> dept b <span class="keyword">ON</span> a.id = b.CEO</span><br><span class="line"><span class="keyword">WHERE</span> b.id <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h2 id="排序分组优化"><a href="#排序分组优化" class="headerlink" title="排序分组优化"></a>排序分组优化</h2><ul>
<li>无过滤 不索引 where或limit</li>
<li>顺序错，必排序(using filesort) 优化器不会调整排序字段的顺序</li>
<li>方向反 必排序(using filesort) 多个排序字段,要么都升序,要么都降序</li>
</ul>
<p>当范围筛选条件和group by 或者 order by  的字段出现二选一时 ，==优先观察条件字段的过滤数量==，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上。反之，亦然。</p>
<p>原因是所有的排序都是在条件过滤之后才执行的，所以如果条件过滤了大部分数据的话，几百几千条数据进行排序其实并不是很消耗性能，即使索引优化了排序但实际提升性能很有限。  相对的范围筛选条件如果没有用到索引的话，要对几万条的数据进行扫描，这是非常消耗性能的</p>
<p><strong>如果排序字段不在索引列上，filesort有两种算法：</strong><br>mysql就要启动双路排序和单路排序</p>
<p><strong>双路排序</strong><br>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据，<br>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出<br>从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。<br>取一批数据，要对磁盘进行了两次扫描，众所周知，I\O是很耗时的，所以在mysql4.1之后，出现了第二种改进的算法，就是单路排序。</p>
<p><strong>单路排序</strong><br>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，<br>它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，<br>因为它把每一行都保存在内存中了。</p>
<p><strong>结论及引申出的问题</strong><br>由于单路是后出的，总体而言好过双路<br>但是用单路有问题</p>
<p>在sort_buffer中，方法B比方法A要多占用很多空间，因为方法B是把所有字段都取出, 所以有可能取出的数据的总大小超出了sort_buffer的容量，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。</p>
<p>本来想省一次I/O操作，反而导致了大量的I/O操作，反而得不偿失。</p>
<p><strong>优化策略</strong></p>
<ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_length_for_sort_data参数的设置</li>
<li>减少select 后面的查询的字段。</li>
</ul>
<p><strong>Why</strong></p>
<p>提高Order By的速度</p>
<ol>
<li><p>Order by时select * 是一个大忌只Query需要的字段， 这点非常重要。在这里的影响是：<br>1.1 当Query的字段大小总和小于max_length_for_sort_data 而且排序字段不是 TEXT|BLOB 类型时，会用改进后的算法——单路排序， 否则用老算法——多路排序。<br>  1.2 两种算法的数据都有可能超出sort_buffer的容量，超出之后，会创建tmp文件进行合并排序，导致多次I/O，但是用单路排序算法的风险会更大一些,所以要提高sort_buffer_size。</p>
</li>
<li><p>尝试提高 sort_buffer_size<br>不管用哪种算法，提高这个参数都会提高效率，当然，要根据系统的能力去提高，因为这个参数是针对每个进程的  1M-8M之间调整</p>
</li>
<li><p>尝试提高 max_length_for_sort_data<br>提高这个参数， 会增加用改进算法的概率。但是如果设的太高，数据总容量超出sort_buffer_size的概率就增大，明显症状是高的磁盘I/O活动和低的处理器使用率.   1024-8192之间调整</p>
</li>
</ol>
<p><strong>GROUP BY优化</strong></p>
<p> group by 使用索引的原则几乎跟order by一致 ，唯一区别是group by 即使没有过滤条件用到索引，也可以直接使用索引。</p>
<p><strong>最后使用索引的手段：覆盖索引</strong></p>
<p>什么是覆盖索引？<br>简单说就是，select 到 from 之间查询的列 &lt;=使用的索引列+主键</p>
<p>所以最好不要使用<code>select *</code>使用明确的字段,可以使用覆盖索引</p>
<p><strong>分析GROUP BY 与临时表的关系 :</strong></p>
<p>　　1. 如果GROUP BY 的列没有索引,产生临时表.<br>　　2. 如果GROUP BY时,SELECT的列不止GROUP BY列一个,并且GROUP BY的列不是主键 ,产生临时表.<br>　　3. 如果GROUP BY的列有索引,ORDER BY的列没索引.产生临时表.<br>　　4. 如果GROUP BY的列和ORDER BY的列不一样,即使都有索引也会产生临时表.<br>　　5. 如果GROUP BY或ORDER BY的列不是来自JOIN语句第一个表.会产生临时表.<br>　　6. 如果DISTINCT 和 ORDER BY的列没有索引,产生临时表.</p>
<h2 id="查询截取分析"><a href="#查询截取分析" class="headerlink" title="查询截取分析"></a>查询截取分析</h2><p>一年之后系统变慢怎么优化?</p>
<p>开启慢查询日志一周~两周(运维),通过日志分析工具mysqldumpslow针对对访问量多的数据和慢查询进行建立索引优化</p>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。</p>
<p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</p>
<p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p>
<p>默认情况下slow_query_log的值为OFF，表示慢查询日志是禁用的，<br>可以通过设置slow_query_log的值来开启</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%slow_query_log%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>开启慢查询日志只对当前数据库生效，如果MySQL重启后则会失效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> slow_query_log=<span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>如果要永久生效，就必须修改配置文件my.cnf（其它系统变量也是如此）</p>
<p>修改my.cnf文件，[mysqld]下增加或修改参数,然后重启MySQL服务器。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">slow_query_log =1</span><br><span class="line">slow_query_log_file=/var/lib/mysql/atguigu-slow.log</span><br></pre></td></tr></table></figure>

<p>slow_query_log_file ，它指定慢查询日志文件的存放路径，系统默认会给一个缺省的文件host_name-slow.log</p>
<p>开启慢查询日志后.指定慢查询的时间阈值<code>long_query_time</code>，默认情况下long_query_time的值为10秒，</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span> <span class="keyword">LIKE</span> <span class="string">&#x27;long_query_time%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>可以使用命令修改，也可以在my.cnf参数里面修改</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> long_query_time= <span class="number">0.2</span></span><br></pre></td></tr></table></figure>

<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">my.cnf</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="string">1</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=<span class="string">/var/lib/mysql/atguigu-slow.log</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="string">3</span></span><br><span class="line"><span class="attr">log_output</span>=<span class="string">FILE</span></span><br></pre></td></tr></table></figure>

<p>在生产环境中，如果要手工分析日志，查找、分析SQL，显然是个体力活，MySQL提供了日志分析工具<strong>mysqldumpslow</strong>。</p>
<p>mysqldumpslow –help</p>
<p><img src="https://i.loli.net/2020/05/17/ZDLJeMaknrRclFx.png" alt="image-20200404101552012"></p>
<p>-a: 不将数字抽象成N，字符串抽象成S<br>-s: 是表示按照何种方式排序；<br>c: 访问次数<br>l: 锁定时间<br>r: 返回记录<br>t: 查询时间<br>al:平均锁定时间<br>ar:平均返回记录数<br>at:平均查询时间<br>-t:即为返回前面多少条的数据；<br>-g:后边搭配一个正则匹配模式，大小写不敏感的；</p>
<p>常用参考:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">得到返回记录集最多的10个SQL</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句</span><br><span class="line">mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log</span><br><span class="line"> </span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况</span><br><span class="line">mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</span><br></pre></td></tr></table></figure>

<p><strong>SHOW PROCESSLIST</strong></p>
<p>显示进程列表</p>
<p>能干什么：查询所有用户正在干什么<br>如果出现不顺眼的<br>kill [id]</p>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><p>是什么<br>  将一段查询sql封装为一个虚拟的表。<br>  这个虚拟表只保存了sql逻辑，不会保存任何查询结果。<br>作用<br>  1、封装复杂sql语句，提高复用性<br>  2、逻辑放在数据库上面，更新不需要发布程序，面对频繁的需求变更更灵活<br>适用场景<br>  很多地方可以共用的一组查询结果<br>  报表统计数据经常变化,将统计sql封装到一个视图中,与程序解耦</p>
<p>创建</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_name </span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> view_name</span><br></pre></td></tr></table></figure>

<p>更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> view_name </span><br><span class="line"><span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span> column_name(s)</span><br><span class="line"><span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> condition</span><br></pre></td></tr></table></figure>

<p>注意事项(适用5.5)<br>  mysql的视图中不允许有from 后面的子查询，但oracle可以</p>
<h1 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h1><p><strong>复制的基本原理:</strong></p>
<p><img src="https://i.loli.net/2020/05/17/b4milnOG7FyAYN3.png" alt="image-20200404103947713"></p>
<p> MySQL复制过程分成三步：<br>1 master将改变记录到二进制日志（binary log）。这些记录过程叫做二进制日志事件，binary log events；<br>2 slave将master的binary log events拷贝到它的中继日志（relay log）；<br>3 slave重做中继日志中的事件，将改变应用到自己的数据库中。 MySQL复制是异步的且串行化的</p>
<p><strong>复制的基本原则</strong><br>  每个slave只有一个master<br>  每个slave只能有一个唯一的服务器ID<br>  每个master可以有多个salve</p>
<p><strong>复制的最大问题:IO多,延时</strong></p>
<h2 id="一主一丛常见配置"><a href="#一主一丛常见配置" class="headerlink" title="一主一丛常见配置"></a>一主一丛常见配置</h2><p>mysql版本一致且后台以服务运行<br>主从都配置在<code>[mysqld]</code>结点下，都是小写</p>
<p><strong>主机</strong>修改my.ini配置文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">主服务器唯一ID</span><br><span class="line"> 	server-id&#x3D;1</span><br><span class="line">启用二进制日志</span><br><span class="line">    log-bin&#x3D;自己本地的路径&#x2F;data&#x2F;mysqlbin</span><br><span class="line">    log-bin&#x3D;D:&#x2F;devSoft&#x2F;MySQLServer5.5&#x2F;data&#x2F;mysqlbin</span><br><span class="line">设置不要复制的数据库</span><br><span class="line">    binlog-ignore-db&#x3D;mysql</span><br><span class="line">设置需要复制的数据库</span><br><span class="line">    binlog-do-db&#x3D;需要复制的主数据库名字</span><br><span class="line">设置logbin格式</span><br><span class="line">    binlog_format&#x3D;STATEMENT（默认）</span><br></pre></td></tr></table></figure>

<p>mysql主从复制起始时，从机不继承主机数据</p>
<p><img src="https://i.loli.net/2020/05/19/YmNDORcWilqZ7TU.png" alt="image-20200404104751055"></p>
<p>从机配置文件修改my.cnf的[mysqld]栏位下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server-id &#x3D; 2</span><br><span class="line">relay-log&#x3D;mysql-relay</span><br></pre></td></tr></table></figure>

<p>因修改过配置文件，请主机+从机都重启后台mysql服务,<br>主机从机都关闭防火墙</p>
<p>主机创建一个用户授权复制权限</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GRANT</span> <span class="keyword">REPLICATION</span> <span class="keyword">SLAVE</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">&#x27;slave200404&#x27;</span>@<span class="string">&#x27;%&#x27;</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">&#x27;123456&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>查看主机状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW MASTER STATUS;</span><br><span class="line">|File          | Positon | Binlog_Do_DB |Binlog_lgnore_DB</span><br><span class="line">mysqlbin.000001	   107	   mydb_200404	  mysql</span><br></pre></td></tr></table></figure>

<p>File:日志文件</p>
<p>Postion:接入点</p>
<p>Binlog_Do_DB:要复制的数据库</p>
<p>Binlog_lgnore_DB:不要复制的数据库</p>
<p>从机对照主机状态拜大哥</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CHANGE MASTER TO MASTER_HOST&#x3D;&#39;192.168.0.104&#39;,</span><br><span class="line">MASTER_USER&#x3D;&#39;slave200404&#39;,</span><br><span class="line">MASTER_PASSWORD&#x3D;&#39;123456&#39;,</span><br><span class="line">MASTER_LOG_FILE&#x3D;&#39;mysqlbin.000001&#39;,MASTER_LOG_POS&#x3D;107;</span><br></pre></td></tr></table></figure>

<p>如果之前做过需要先停止再设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">stop slave;</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure>

<p>启动从服务器复制功能</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">start slave;</span><br></pre></td></tr></table></figure>

<p>查看主从配置状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">show slave status\G;</span><br><span class="line"></span><br><span class="line">Slave_IO_Running: Yes</span><br><span class="line">Slave_SQL_Running: Yes</span><br><span class="line">成功</span><br></pre></td></tr></table></figure>

<p>主机创建相应的数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> mydb_200404;</span><br></pre></td></tr></table></figure>

<p>刷新从机出现数据库成功</p>
<h2 id="MyCat"><a href="#MyCat" class="headerlink" title="MyCat"></a>MyCat</h2><p>数据库中间件,前身是阿里的cobar,仅可以用作读写分离、以及分表分库、多数据源整合,容灾备份</p>
<p><strong>基本原理:</strong></p>
<p> Mycat 的原理中最重要的一个动词是“拦截”，它拦截了用户发送过来的 SQL 语句，首先对 SQL 语句做了<br>一些特定的分析：如分片分析、路由分析、读写分离分析、缓存分析等，然后将此 SQL 发往后端的真实数据库，<br>并将返回的结果做适当的处理，最终再返回给用户</p>
<p><img src="https://i.loli.net/2020/05/19/FpZWhv6ry5aHjQg.png" alt="image-20200404135415788"></p>
<p>这种方式把数据库的分布式从代码中解耦出来，Mycat是代理，Mycat后面就是物理数据库。和Web服务器的Nginx类似。对于使用者来说，访问的都是Mycat，不会接触到后端的数据库。</p>
<p><strong>概念</strong>:</p>
<p>0、逻辑库/表：mycat中存在的库和表</p>
<p>1、分片表：原本有大量数据的表</p>
<p>2、ER表：关系表</p>
<p>3、全局表：类似于字典表这种表，字典表和很多表都有关联，mycat采用数据冗余存储</p>
<p>4、分片节点（dataNode）：一张大表分为多个数据库上，每个数据库就是分片节点</p>
<p>5、分片主机（dataHost）：分片节点可以在不同的主机，一个或者多个节点所在的主机就是分片主机</p>
<p>6、分片规则（rule）：数据划分的规则</p>
<p>7、全局序列号：数据切分后原本的主键就无法使用了，因此需要引入一个值保证数据唯一性。</p>
<p>8、多租户（很重要）：多个环境下公用相同的系统，并且保证隔离性</p>
<p>​    8-1：独立数据库，隔离性高，但是代价比较庞大</p>
<p>​    8-2：共享一个数据库，不是完全隔离，隔离性不高，容易出错</p>
<p>​    8-3：共用数据结构，数据架构，通过ID进行区分租户数据（也就是用mycat）</p>
<h2 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a><strong>数据分片</strong></h2><p>简单来说，就是指通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）<br>上面，以达到分散单台设备负载的效果</p>
<p>数据的切分（Sharding）根据其切分规则的类型，可以分为两种切分模式。一种是按照业务将表进行分类（或者<br>Schema）来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直（纵向）切分；</p>
<p>另外一种则是根据表中的数据的逻辑关系按照某个字段的某种规则，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>linux 下可以下载 Mycat-server-xxxxx.linux.tar.gz 解压拷贝mycat目录到<code>/usr/local</code>目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp -r mycat &#x2F;usr&#x2F;local</span><br></pre></td></tr></table></figure>

<p>目录如下：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>mycat命令，启动、重启、停止等</td>
</tr>
<tr>
<td>catlet</td>
<td>catlet为Mycat的一个扩展功能</td>
</tr>
<tr>
<td>conf</td>
<td>Mycat 配置信息,重点关注</td>
</tr>
<tr>
<td>lib</td>
<td>Mycat引用的jar包，Mycat是java开发的</td>
</tr>
<tr>
<td>logs</td>
<td>日志文件，包括Mycat启动的日志和运行的日志。</td>
</tr>
</tbody></table>
<p>配置文件:</p>
<table>
<thead>
<tr>
<th>文件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>server.xml</td>
<td>Mycat的配置文件，设置账号、参数等</td>
</tr>
<tr>
<td>schema.xml</td>
<td>Mycat对应的物理数据库和数据库表的配置</td>
</tr>
<tr>
<td>rule.xml</td>
<td>Mycat分片（分库分表）规则</td>
</tr>
</tbody></table>
<p><strong>schema.xml</strong><br>定义逻辑库，表、分片节点等内容</p>
<p>将<code>&lt;/schema&gt;</code>中的内容删除,并加上<code>dataNode=&quot;dn1&quot;</code>属性指定数据节点名称</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--逻辑库    name名称,   checkSQLschema SQL检查优化       sqlMaxLimit 末尾是否要加 limit xxx--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--逻辑库    name名称,   dataHost 引用的哪个dataHost      database:对应mysql的database--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;mydb_200404&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">            	<span class="comment">&lt;!-- 心跳检测 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 写主机 can have multi write hosts --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.0.104:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">                        <span class="comment">&lt;!-- 读主机 can have multi read hosts --&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">readHost</span> <span class="attr">host</span>=<span class="string">&quot;hostS1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span> <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span> /&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>schema:</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>逻辑数据库名，与server.xml中的schema对应</td>
</tr>
<tr>
<td>checkSQLschema</td>
<td>数据库前缀相关设置，建议看文档，这里暂时设为false</td>
</tr>
<tr>
<td>sqlMaxLimit</td>
<td>select 时默认的limit，避免查询全表</td>
</tr>
</tbody></table>
<p><strong>table:</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>表名，物理数据库中表名</td>
</tr>
<tr>
<td>dataNode</td>
<td>表存储到哪些节点，多个节点用逗号分隔。节点为下文dataNode设置的name</td>
</tr>
<tr>
<td>primaryKey</td>
<td>主键字段名，自动生成主键时需要设置</td>
</tr>
<tr>
<td>autoIncrement</td>
<td>是否自增</td>
</tr>
<tr>
<td>rule</td>
<td>分片规则名，具体规则下文rule详细介绍</td>
</tr>
</tbody></table>
<p><strong>dataNode</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>节点名，与table中dataNode对应</td>
</tr>
<tr>
<td>datahost</td>
<td>物理数据库名，与datahost中name对应</td>
</tr>
<tr>
<td>database</td>
<td>物理数据库中数据库名</td>
</tr>
</tbody></table>
<p><strong>dataHost</strong></p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>name</td>
<td>物理数据库名，与dataNode中dataHost对应</td>
</tr>
<tr>
<td>balance</td>
<td>均衡负载的方式</td>
</tr>
<tr>
<td>writeType</td>
<td>写入方式</td>
</tr>
<tr>
<td>dbType</td>
<td>数据库类型</td>
</tr>
<tr>
<td>heartbeat</td>
<td>心跳检测语句，注意语句结尾的分号要加。</td>
</tr>
</tbody></table>
<p><strong>server.xml</strong><br>配置mycat用户名密码</p>
<p>schemas:数据库名，这里会和schema.xml中的配置关联，多个用逗号分开，例如需要这个用户需要管理两个数据库db1,db2，则配置db1,db2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">#修改用户名和mysql区分开</span><br><span class="line"><span class="tag">&lt;<span class="name">user</span> <span class="attr">name</span>=<span class="string">&quot;mycat&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span>&gt;</span>123456<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;schemas&quot;</span>&gt;</span>TESTDB<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>验证数据库访问情况</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p123123 -h 192.168.154.1 -P 3306</span><br><span class="line">mysql -uroot -p123123 -h 192.168.154.154 -P 3306</span><br><span class="line"></span><br><span class="line">如本机远程访问报错，请建对应用户</span><br><span class="line">grant all privileges on *.* to hzy@&#39;%&#39;  identified by &#39;000000&#39;;</span><br></pre></td></tr></table></figure>

<p><strong>启动程序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">控制台启动 ：去mycat&#x2F;bin 目录下 mycat console</span><br><span class="line">后台启动 ：去mycat&#x2F;bin 目录下 mycat start</span><br></pre></td></tr></table></figure>

<p><strong>登录</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">后台管理窗口(运维)</span><br><span class="line">    mysql -umycat -p654321 -P9066 -h192.168.67.131</span><br><span class="line">命令</span><br><span class="line">	show database</span><br><span class="line">    show @@help</span><br><span class="line">数据窗口(开发)</span><br><span class="line">    mysql -umycat -p123456 -P8066 -h192.168.107.108</span><br><span class="line">连接方式和普通数据库一样，如：jdbc:mysql:&#x2F;&#x2F;192.168.0.2:8066&#x2F;</span><br></pre></td></tr></table></figure>

<p>如果在启动时发现异常，在logs目录中查看日志。</p>
<ul>
<li>wrapper.log 为程序启动的日志，启动时的问题看这个</li>
<li>mycat.log 为脚本执行时的日志，SQL脚本执行报错后的具体错误内容,查看这个文件。mycat.log是最新的错误日志，历史日志会根据时间生成目录保存。</li>
</ul>
<p>查看库表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> show databases;</span><br><span class="line">+----------+</span><br><span class="line">| DATABASE |</span><br><span class="line">+----------+</span><br><span class="line">| TESTDB   |</span><br><span class="line">+----------+</span><br><span class="line"></span><br><span class="line">mysql&gt; use TESTDB;</span><br><span class="line"></span><br><span class="line">mysql&gt; show tables;</span><br><span class="line">+-----------------------+</span><br><span class="line">| Tables_in_mydb_200404 |</span><br><span class="line">+-----------------------+</span><br><span class="line">| mytable               |</span><br><span class="line">+-----------------------+</span><br></pre></td></tr></table></figure>

<h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">负载均衡类型，目前的取值有4 种：</span><br><span class="line">1. balance&#x3D;&quot;0&quot;, 不开启读写分离机制，所有读操作都发送到当前可用的 writeHost 上。</span><br><span class="line">2. balance&#x3D;&quot;1&quot;，全部的 readHost 与 stand by writeHost 参与 select 语句的负载均衡，简单的说，当双主双从模式(M1-&gt;S1，M2-&gt;S2，并且 M1 与 M2 互为主备)，正常情况下，M2,S1,S2 都参与 select 语句的负载均衡。</span><br><span class="line">3. balance&#x3D;&quot;2&quot;，所有读操作都随机的在 writeHost、readhost 上分发。</span><br><span class="line">4. balance&#x3D;&quot;3&quot;，所有读请求随机的分发到 readhost 执行，writerHost 不负担读压力</span><br><span class="line"> &lt;dataHost name&#x3D;&quot;host1&quot; maxCon&#x3D;&quot;1000&quot; minCon&#x3D;&quot;10&quot; balance&#x3D;&quot;2&quot;</span><br></pre></td></tr></table></figure>

<p>在主机执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT mytable(id,&#96;name&#96;) VALUES(2,@@hostname);</span><br></pre></td></tr></table></figure>

<p>重启mycat,再查询</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+------+------------+</span><br><span class="line">| id   | name       |</span><br><span class="line">+------+------------+</span><br><span class="line">|    1 | stig       |</span><br><span class="line">|    2 | dockerhost |</span><br><span class="line">+------+------------+</span><br><span class="line">2 rows in set (0.01 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from mytable;</span><br><span class="line">+------+----------------+</span><br><span class="line">| id   | name           |</span><br><span class="line">+------+----------------+</span><br><span class="line">|    1 | stig           |</span><br><span class="line">|    2 | HUAWEIMatebook |</span><br><span class="line">+------+----------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from mytable;</span><br><span class="line">+------+------------+</span><br><span class="line">| id   | name       |</span><br><span class="line">+------+------------+</span><br><span class="line">|    1 | stig       |</span><br><span class="line">|    2 | dockerhost |</span><br><span class="line">+------+------------+</span><br></pre></td></tr></table></figure>

<h2 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h2><p>按照业务将表进行分类,不需要join关系的表分开</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库配置，与server.xml中的数据库对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置表分到哪个数据节点 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分片配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders__200405&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders_200405&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">&lt;!-- 物理数据库配置 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--balance=&quot;0&quot;不配置读写分离 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.0.104:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hzy&quot;</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h2><p>schema.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mycat:schema</span> <span class="attr">xmlns:mycat</span>=<span class="string">&quot;http://io.mycat/&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 数据库配置，与server.xml中的数据库对应--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">schema</span> <span class="attr">name</span>=<span class="string">&quot;TESTDB&quot;</span> <span class="attr">checkSQLschema</span>=<span class="string">&quot;false&quot;</span> <span class="attr">sqlMaxLimit</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 配置表分到哪个数据节点 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;customer&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn2&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- dictionary写入了dn1、dn2两个节点,分片的规则为：mod-long 源于rule.xml文件中tableRule的name --&gt;</span></span><br><span class="line">            	<span class="tag">&lt;<span class="name">table</span> <span class="attr">name</span>=<span class="string">&quot;dictionary&quot;</span> <span class="attr">primaryKey</span>=<span class="string">&quot;id&quot;</span> <span class="attr">autoIncrement</span>=<span class="string">&quot;true&quot;</span> <span class="attr">dataNode</span>=<span class="string">&quot;dn1,dn2&quot;</span>  <span class="attr">rule</span>=<span class="string">&quot;mod-long&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">schema</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 分片配置 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn1&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders__200405&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dataNode</span> <span class="attr">name</span>=<span class="string">&quot;dn2&quot;</span> <span class="attr">dataHost</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">database</span>=<span class="string">&quot;orders_200405&quot;</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line">       <span class="comment">&lt;!-- 物理数据库配置 --&gt;</span></span><br><span class="line">       <span class="comment">&lt;!--balance=&quot;0&quot;不配置读写分离 --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host1&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM1&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.0.104:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;root&quot;</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line">        </span><br><span class="line"><span class="tag">&lt;<span class="name">dataHost</span> <span class="attr">name</span>=<span class="string">&quot;host2&quot;</span> <span class="attr">maxCon</span>=<span class="string">&quot;1000&quot;</span> <span class="attr">minCon</span>=<span class="string">&quot;10&quot;</span> <span class="attr">balance</span>=<span class="string">&quot;0&quot;</span></span></span><br><span class="line"><span class="tag">                          <span class="attr">writeType</span>=<span class="string">&quot;0&quot;</span> <span class="attr">dbType</span>=<span class="string">&quot;mysql&quot;</span> <span class="attr">dbDriver</span>=<span class="string">&quot;native&quot;</span> <span class="attr">switchType</span>=<span class="string">&quot;1&quot;</span>  <span class="attr">slaveThreshold</span>=<span class="string">&quot;100&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">heartbeat</span>&gt;</span>select user()<span class="tag">&lt;/<span class="name">heartbeat</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- can have multi write hosts --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">writeHost</span> <span class="attr">host</span>=<span class="string">&quot;hostM2&quot;</span> <span class="attr">url</span>=<span class="string">&quot;192.168.107.108:3306&quot;</span> <span class="attr">user</span>=<span class="string">&quot;hzy&quot;</span></span></span><br><span class="line"><span class="tag">                                   <span class="attr">password</span>=<span class="string">&quot;000000&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">writeHost</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dataHost</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mycat:schema</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>rule.xml</strong><br>定义分片规则</p>
<p>这个文件里面主要有 tableRule 和 function 这两个标签。在具体使<br>用过程中可以按照需求添加 tableRule 和 function。 </p>
<p>mod-long就是将数据平均拆分。因为是两台物理库，所以rule.xml中mod-long对应的function count为2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">tableRule</span> <span class="attr">name</span>=<span class="string">&quot;mod_rule&quot;</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">rule</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">columns</span>&gt;</span>customer_id<span class="tag">&lt;/<span class="name">columns</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">algorithm</span>&gt;</span>mod-long<span class="tag">&lt;/<span class="name">algorithm</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="name">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tableRule</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--多少数据节点 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>tableRule</strong></p>
<ul>
<li>name 属性指定唯一的名字，用于标识不同的表规则</li>
<li>内嵌的 rule 标签则指定对物理表中的哪一列进行拆分(columns)和使用什么路由算法(algorithm)</li>
</ul>
<p>algorithm 使用 function 标签中的 name 属性。连接表规则和具体路由算法。当然，多个表规则可以连接到<br>同一个路由算法上。table 标签内使用。让逻辑表使用这个规则进行分片</p>
<p><strong>function</strong></p>
<ul>
<li><p>name 指定算法的名字</p>
</li>
<li><p>class 制定路由算法具体的类名字</p>
</li>
<li><p>property 为具体算法需要用到的一些属性</p>
</li>
</ul>
<p><strong>常用分片规则</strong><br>       分片枚举（hash-int）：在配置文件中配置可能出现的枚举id，配置分片<br>       固定分片Hash算法（func1）：二进制操作的求模运算<br>       范围约定（rang-long）：提前规定好字段范围属于哪个分片<br>       取模（mod-long）：根据ID进行10进制的求模运算<br>       日期分片（sharding-by-date）：按照时间划分<br>       取模范围（sharding-by-pattern）：按照取模运算和范围运算结合<br>       应用指定（sharding-by-substring）：运行阶段有应用自主决定路由到那个分片</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;murmur&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMurmurHash&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;seed&quot;</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 默认是0 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;virtualBucketTimes&quot;</span>&gt;</span>160<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 一个实际的数据库节点被映射为这么多虚拟节点，默认是160倍，也就是虚拟节点数是物理节点数的160倍 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;weightMapFile&quot;&gt;weightMapFile&lt;/property&gt; 节点的权重，没有指定权重的节点默认是1。以properties文件的格式填写，以从0开始到count-1的整数值也就是节点索引为key，以节点权重值为值。所有权重值必须是正整数，否则以1代替 --&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- &lt;property name=&quot;bucketMapPath&quot;&gt;/etc/mycat/bucketMapPath&lt;/property&gt; </span></span><br><span class="line"><span class="comment">			用于测试时观察各物理节点与虚拟节点的分布情况，如果指定了这个属性，会把虚拟节点的murmur hash值与物理节点的映射按行输出到这个文件，没有默认值，如果不指定，就不会输出任何东西 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;crc32slot&quot;</span></span></span><br><span class="line"><span class="tag">			  <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByCRC32PreSlot&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>2<span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!-- 要分片的数据库节点数量，必须指定，否则没法分片 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;hash-int&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByFileMap&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-hash-int.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-long&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.AutoPartitionByLong&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>autopartition-long.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;mod-long&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMod&quot;</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- how many data nodes --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;count&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;func1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByLong&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionCount&quot;</span>&gt;</span>8<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;partitionLength&quot;</span>&gt;</span>128<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;latestMonth&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.LatestMonthPartion&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;splitOneDay&quot;</span>&gt;</span>24<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;partbymonth&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByMonth&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dateFormat&quot;</span>&gt;</span>yyyy-MM-dd<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sBeginDate&quot;</span>&gt;</span>2015-01-01<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;rang-mod&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByRangeMod&quot;</span>&gt;</span></span><br><span class="line">        	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapFile&quot;</span>&gt;</span>partition-range-mod.txt<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">function</span> <span class="attr">name</span>=<span class="string">&quot;jump-consistent-hash&quot;</span> <span class="attr">class</span>=<span class="string">&quot;io.mycat.route.function.PartitionByJumpConsistentHash&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;totalBuckets&quot;</span>&gt;</span>3<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">function</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>B+Tree</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis学习笔记</title>
    <url>/2020/03/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis(REmote DIctionary Server) 是一种Key-Value类型的开源缓存中间件</p>
<p>可用于数据库前端缓存,实现发布或订阅,高速队列等多种场景</p>
<a id="more"></a>

<p>提供字符串(String),哈希(Hash),列表(List),集合结构(Set, Sorted Set),流(Stream)等数据类型的直接存取</p>
<p>支持内置复制、Lua 脚本、LRU 收回、事务以及不同级别磁盘持久化功能，同时通过 Redis Sentinel 提供高可用，通过 Redis Cluster 提供自动分区。</p>
<h2 id="Redis-使用场景"><a href="#Redis-使用场景" class="headerlink" title="Redis 使用场景"></a>Redis 使用场景</h2><p>微服务以及分布式被广泛使用后，Redis 的使用场景就越来越多了，这里我罗列了主要的几种场景。</p>
<ol>
<li><strong>分布式缓存</strong>：在分布式的系统架构中，将缓存存储在内存中显然不当，因为缓存需要与其他机器共享，这时 Redis 便挺身而出了，缓存也是 Redis 使用最多的场景。</li>
<li><strong>分布式锁</strong>：在高并发的情况下，我们需要一个锁来防止并发带来的脏数据，Java 自带的锁机制显然对进程间的并发并不好使，此时可以利用 Redis 单线程的特性来实现我们的分布式锁，如何实现，可以<a href="https://www.ibm.com/developerworks/cn/java/j-spring-boot-aop-web-log-processing-and-distributed-locking/index.html">参考这篇文章</a>。</li>
<li><strong>Session 存储/共享</strong>：Redis 可以将 Session 持久化到存储中，这样可以避免由于机器宕机而丢失用户会话信息。</li>
<li><strong>发布/订阅</strong>：Redis 还有一个发布/订阅的功能，您可以设定对某一个 key 值进行消息发布及消息订阅，当一个 key 值上进行了消息发布后，所有订阅它的客户端都会收到相应的消息。这一功能最明显的用法就是用作实时消息系统。</li>
<li><strong>任务队列</strong>：Redis 的 <code>lpush+brpop</code> 命令组合即可实现阻塞队列，生产者客户端使用 <code>lrpush</code> 从列表左侧插入元素，多个消费者客户端使用 <code>brpop</code> 命令阻塞式的”抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</li>
<li><strong>限速，接口访问频率限制</strong>：比如发送短信验证码的接口，通常为了防止别人恶意频刷，会限制用户每分钟获取验证码的频率，例如一分钟不能超过 5 次。</li>
</ol>
<p>当然 Redis 的使用场景并不仅仅只有这么多，还有很多未列出的场景，如计数、排行榜等，可见 Redis 的强大。不过 Redis 说到底还是一个数据库（非关系型），那么我们还是有必要了解一下它支持存储的数据结构。</p>
<h2 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h2><ul>
<li><p>下载安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget http://download.redis.io/releases/redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tar -xvf redis-4.0.0.tar.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入redis目录, 编译并安装</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
</li>
<li><p>进入src目录, 启动</p>
 <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定端口启动的方式</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server --port 端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定端口连接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-cli -p 端口</span><br></pre></td></tr></table></figure>
</li>
<li><p>指定配置文件启动服务</p>
<p>在redis目录下有 redis.conf 配置文件, 可以编写不同的配置文件启动多个 redis 实例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">redis-server conf/redis-6379.conf</span><br><span class="line">redis-server conf/redis-6390.conf</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Redis-cli连接"><a href="#Redis-cli连接" class="headerlink" title="Redis-cli连接"></a>Redis-cli连接</h2><p>Redis服务正常运行后，可使用客户端连接，进行信息查询，以及数据读写。 Redis-cli为Redis自带的命令行界面工具，可用于日常运维，如直接登录操作，或者脚本批处理。<br>交互方式使用Redis-cli </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli -h 192.168.0.66 -p 6379 </span><br><span class="line"></span><br><span class="line">set a hello</span><br><span class="line"></span><br><span class="line">OK </span><br></pre></td></tr></table></figure>

<p>脚本命令方式使用Redis-cli </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./redis-cli -h 192.168.0.66 -p 6379 get a </span><br><span class="line"></span><br><span class="line">&quot;hello“ </span><br></pre></td></tr></table></figure>

<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>基于内存的Key-Value数据库</p>
<p>基于C语言编写,可支持多种语言的api //set每秒11万次, get 81000次</p>
<p>支持数据持久化, value可以是string, hash, list, set, sorted set</p>
<p>可以根据<strong>使用场景</strong>选择使用</p>
<ul>
<li>取最新n个数据的操作</li>
<li>排行榜, 取top n个数据</li>
<li>精确的设置过期时间</li>
<li>计数器</li>
<li>实时系统, 反垃圾系统</li>
<li>pub, sub发布订阅构建实时消息系统</li>
<li>构建消息队列</li>
<li>缓存</li>
</ul>
<h3 id="Keys操作"><a href="#Keys操作" class="headerlink" title="Keys操作"></a>Keys操作</h3><p>key是字符串类型，尽可能满足如下几点： </p>
<ul>
<li>key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率 </li>
<li>key不要太短，如果太短会降低key的可读性 </li>
<li>在项目中，key最好有一个统一的命名规范（根据企业的需求）</li>
</ul>
<p>常用的<strong>Keys键操作命令</strong>有： </p>
<ul>
<li>exists—–测试key是否存在 </li>
<li>del—–删除key </li>
<li>type—–返回key的类型 </li>
<li>keys—–匹配满足的key </li>
<li>rename——改key名 </li>
<li>dbsize—–当前数据库key的数量 </li>
<li>expire—–设置key过期时间 </li>
<li>ttl—–key剩余过期时间 </li>
<li>move—–将key移动到指定数据库 </li>
<li>flushdb—–删除当前数据库的所有key </li>
<li>flushall—–删除所有数据库的key</li>
</ul>
<h3 id="String操作"><a href="#String操作" class="headerlink" title="String操作"></a>String操作</h3><p>String：Redis 中最简单的数据结构，它既可以储存文字（比如 “hello world”），</p>
<p>又可以储存数字（比如整数 10100 和浮点数 3.14），还可以储存二进制数据（比如10010100）。</p>
<p><strong>在 Redis 中 string 表示的是一个可变的字节数组</strong>，我们初始化字符串的内容、可以拿到字符串的长度，可以获取 string 的子串，可以覆盖 string 的子串内容，可以追加子串。</p>
<p><img src="https://i.loli.net/2020/07/08/VyIuAx4RU8acQBK.png" alt="图 1. Redis 的 string 类型数据结构"></p>
<p>在 Redis 中我们初始化一个字符串时，会采用预分配冗余空间的方式来减少内存的频繁分配，如图中所示，实际分配的空间 capacity 一般要高于实际字符串长度 len。如果您看过 Java 的 ArrayList 的源码相信会对此种模式很熟悉。</p>
<p>常用的<strong>String键操作命令</strong>有： </p>
<ul>
<li>set—–设置单个key </li>
<li>mset—–批量添加key </li>
<li>mget—–批量获取 </li>
<li>incr—–key值+1 </li>
<li>decr—–key值-1 </li>
<li>incrby—–对key加指定值 </li>
<li>decrby—–对key减定值 </li>
<li>append—–在key值后追加 </li>
<li>substr—–截取字符串（包前包后）</li>
</ul>
<h3 id="Hash操作"><a href="#Hash操作" class="headerlink" title="Hash操作"></a>Hash操作</h3><p>hash 与 Java 中的 HashMap 差不多，实现上采用<strong>二维结构</strong>，第一维是数组，第二维是链表。</p>
<p>hash 的 key 与 value 都存储在链表中，而数组中存储的则是各个链表的表头。在检索时，首先计算 key 的 hashcode，然后通过 hashcode 定位到链表的表头，再遍历链表得到 value 值。可能您比较好奇为啥要用链表来存储 key 和 value，直接用 key 和 value 一对一存储不就可以了吗？其实是因为有些时候我们无法保证 hashcode 值的唯一，若两个不同的 key 产生了相同的 hashcode，我们需要一个链表在存储两对键值对，这就是所谓的 <strong>hash 碰撞</strong>。</p>
<p>Redis 中每个 hash 可以存储 232 - 1 键值对（40多亿）。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left"><strong>[HDEL key field1 field2]</strong> 删除一个或多个哈希表字段</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>HEXISTS key field</strong> 查看哈希表 key 中，指定的字段是否存在。</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>HGET key field</strong> 获取存储在哈希表中指定字段的值。</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>HGETALL key</strong> 获取在哈希表中指定 key 的所有字段和值</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>HINCRBY key field increment</strong> 为哈希表 key 中的指定字段的整数值加上增量 increment 。</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>HINCRBYFLOAT key field increment</strong> 为哈希表 key 中的指定字段的浮点数值加上增量 increment 。</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left"><strong>HKEYS key</strong> 获取所有哈希表中的字段</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left"><strong>HLEN key</strong> 获取哈希表中字段的数量</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>[HMGET key field1 field2</strong> 获取所有给定字段的值</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left"><strong>[HMSET key field1 value1 field2 value2</strong> 同时将多个 field-value (域-值)对设置到哈希表 key 中。</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left"><strong>HSET key field value</strong> 将哈希表 key 中的字段 field 的值设为 value 。</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left"><strong>HSETNX key field value</strong> 只有在字段 field 不存在时，设置哈希表字段的值。</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left"><strong>HVALS key</strong> 获取哈希表中所有值。</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left"><strong>HSCAN key cursor [MATCH pattern] [COUNT count]</strong> 迭代哈希表中的键值对。</td>
</tr>
</tbody></table>
<p><strong>hash实现购物车</strong></p>
<ul>
<li>用户id作为 key</li>
<li>商品id作为 field </li>
<li>商品数量作为 value</li>
<li>取值 : hget</li>
<li>增加或设置 : hincrby, hset</li>
<li>删除 : hdel</li>
<li>全选 : hgetall</li>
<li>总量 : hlen</li>
</ul>
<p><strong>但是这样的购物车方案,并没有提高效率, 商品信息还需要二次查询数据库</strong></p>
<ul>
<li><p>每条购物车中的商品记录 field 用于保存购买数量</p>
<ul>
<li>格式: 商品id : nums</li>
<li>数据: 购买数量</li>
</ul>
</li>
<li><p>另外新建多个 hash 用于存放不同类型的商品信息</p>
<ul>
<li>格式: 商品id: info</li>
<li>数据: json</li>
</ul>
</li>
</ul>
<h3 id="List操作"><a href="#List操作" class="headerlink" title="List操作"></a>List操作</h3><p><strong>在 Redis 中列表 list 采用的存储结构是双向链表</strong>，由此可见其随机定位性能较差，比较适合首位插入删除。像 Java 中的数组一样，Redis 中的列表支持通过下标访问，不同的是 Redis 还为列表提供了一种负下标，<code>-1</code> 表示倒数一个元素，<code>-2</code> 表示倒数第二个数，依此类推。综合列表首尾增删性能优异的特点，通常我们使用 <code>rpush/rpop/lpush/lpop</code> 四条指令将列表作为队列来使用。</p>
<p><img src="https://i.loli.net/2020/07/08/Y9VXqgu7lU6MKBz.png" alt="图 2. List 类型数据结构"></p>
<p>如上图所示，在列表元素较少的情况下会使用一块连续的内存存储，这个结构是 <strong>ziplist</strong>，也即是压缩列表。它将所有的元素紧挨着一起存储，分配的是一块连续的内存。当数据量比较多的时候才会改成 <strong>quicklist</strong>。因为普通的链表需要的附加指针空间太大，会比较浪费空间。比如这个列表里存的只是 int 类型的数据，结构上还需要两个额外的指针 prev 和 next。所以 Redis 将链表和 ziplist 结合起来组成了 quicklist。也就是将多个 ziplist 使用双向指针串起来使用。这样既满足了快速的插入删除性能，又不会出现太大的空间冗余。</p>
<p>一个列表可以包含一个或以上数量的项，每个项按照它们被推入到列表的位置来排序。列表包含的项可以重复出现，它们不一定是唯一的。</p>
<p>常用的<strong>List键操作命令</strong>有： </p>
<ul>
<li>lpush—–在list头部添加 </li>
<li>rpop—–从list尾部移出 </li>
<li>llen—–（存在对应key返回长度，反之-1，类型不对应会报错） </li>
<li>lrange—–在指定区间查找元素 </li>
<li>rpush—–从尾部增加 </li>
<li>lpop—–删除头部元素 </li>
<li>ltrim—–截取list（保留）</li>
<li>blpop key1 key2 timtout—–在规定时间内获取并移除数据(任务队列)</li>
</ul>
<h3 id="Set操作"><a href="#Set操作" class="headerlink" title="Set操作"></a>Set操作</h3><p>熟悉 Java 的同学应该知道 HashSet 的内部实现使用的是 HashMap，只不过所有的 value 都指向同一个对象。Redis 的 Set 结构也是一样，它的内部也使用 Hash 结构，所有的 value 都指向同一个内部值</p>
<p>Redis的集合（set）以无序的方式储存多个各不相同的元素。用户可以快速向集合添加元素、删除元素，也可以对多个 集合进行集合操作，比如计算并集、交集等。</p>
<p><strong>set 可实现黑白名单</strong></p>
<p>常用的<strong>Set键操作命令</strong>有： </p>
<ul>
<li>sadd—–添加set </li>
<li>srem—–删除set中的指定元素 </li>
<li>smove set1 set2—–将元素从set1转移到set2 </li>
<li>scard—–返回set中元素的个数 </li>
<li>sismember—–判断元素是否在set中 </li>
<li>sinter set1 set2 set3…—–给所定set的交集 </li>
<li>sunion set1 set2 set3…—–给所定set的并集 </li>
<li>sdiff set1 set2 set3…—–给所定set的差集 </li>
<li>smembers—–返回set所对应的全部元素</li>
<li>srandmember key [count]—–随机获取集合中指定数量的数据</li>
<li>spop key 随机获取集合中某个数据并将该数据移除</li>
</ul>
<h3 id="Sorted-Set操作"><a href="#Sorted-Set操作" class="headerlink" title="Sorted Set操作"></a>Sorted Set操作</h3><p>有时也被称作 ZSet，是 Redis 中一个比较特别的数据结构，在有序集合中我们会给每个元素赋予一个权重，其内部元素会按照权重进行排序，我们可以通过命令查询某个范围权重内的元素，这个特性在我们做一个排行榜的功能时可以说非常实用了。</p>
<p>其底层的实现使用了两个数据结构， <strong>hash 和跳跃列表</strong>，hash 的作用就是关联元素 value 和权重 score，保障元素 value 的唯一性，可以通过元素 value 找到相应的 score 值。跳跃列表的目的在于给元素 value 排序，根据 score 的范围获取元素列表。</p>
<p>每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p>
<p>有序集合的成员是唯一的,但分数(score)却可以重复。</p>
<p>其实在redis sorted sets里面当items内容大于64的时候同时使用了hash和skiplist两种设计实现。这也会为了排序和查找性能做的优化。所以如上可知： </p>
<ul>
<li><p>添加和删除都需要修改skiplist，所以复杂度为O(log(n))。 </p>
</li>
<li><p>但是如果仅仅是查找元素的话可以直接使用hash，其复杂度为O(1) </p>
</li>
<li><p>其他的range操作复杂度一般为O(log(n))</p>
</li>
</ul>
<p>当然如果是小于64的时候，因为是采用了ziplist的设计，</p>
<p>其时间复杂度为O(n)集合中最大的成员数为 232 - 1 (4294967295, 每个集合可存储40多亿个成员)。</p>
<table>
<thead>
<tr>
<th align="left">序号</th>
<th align="left">命令及描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">**[ ZADD key score1 member1 score2 member2 ]**向有序集合添加一个或多个成员，或者更新已存在成员的分数</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left"><strong>ZCARD key</strong> 获取有序集合的成员数</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left"><strong>ZCOUNT key min max</strong> 计算在有序集合中指定区间分数的成员数</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left"><strong>ZINCRBY key increment member</strong> 有序集合中对指定成员的分数加上增量 increment</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left"><strong>ZINTERSTORE destination numkeys key key …</strong> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left"><strong>ZLEXCOUNT key min max</strong> 在有序集合中计算指定字典区间内成员数量</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">**[ ZRANGE key start stop WITHSCORES ]**通过索引区间返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">**[ ZRANGEBYLEX key min max LIMIT offset count ]**通过字典区间返回有序集合的成员</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left"><strong>[ ZRANGEBYSCORE key min max WITHSCORES LIMIT ]</strong> 通过分数返回有序集合指定区间内的成员</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">**[ ZRANK key member ]**返回有序集合中指定成员的索引</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">**[ZREM key member member …]**移除有序集合中的一个或多个成员</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">**[ ZREMRANGEBYLEX key min max ]**移除有序集合中给定的字典区间的所有成员</td>
</tr>
<tr>
<td align="left">13</td>
<td align="left">**[ ZREMRANGEBYRANK key start stop ]**移除有序集合中给定的排名区间的所有成员</td>
</tr>
<tr>
<td align="left">14</td>
<td align="left">**[ ZREMRANGEBYSCORE key min max ]**移除有序集合中给定的分数区间的所有成员</td>
</tr>
<tr>
<td align="left">15</td>
<td align="left"><strong>[ ZREVRANGE key start stop [WITHSCORES ]</strong> 返回有序集中指定区间内的成员，通过索引，分数从高到低</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left"><strong>[ ZREVRANGEBYSCORE key max min WITHSCORES ]</strong> 返回有序集中指定分数区间内的成员，分数从高到低排序</td>
</tr>
<tr>
<td align="left">17</td>
<td align="left"><strong>ZREVRANK key member</strong> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td>
</tr>
<tr>
<td align="left">18</td>
<td align="left"><strong>ZSCORE key member</strong> 返回有序集中，成员的分数值</td>
</tr>
<tr>
<td align="left">19</td>
<td align="left"><strong>[ ZUNIONSTORE destination numkeys key key … ]</strong> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left"><strong>ZSCAN key cursor [MATCH pattern] [COUNT count]</strong> 迭代有序集合中的元素（包括元素成员和元素分值）</td>
</tr>
</tbody></table>
<h2 id="发布订阅功能"><a href="#发布订阅功能" class="headerlink" title="发布订阅功能"></a><strong>发布订阅功能</strong></h2><p>打开两个客户端,在其中一个客户端执行订阅,并指定一个主题为”foo”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE foo</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;foo&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<p>另一个客户端在foo发布一条消息”hahaha”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH foo hahaha</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>可以看到订阅的那个客户端就打印了这样一条消息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE foo</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;subscribe&quot;</span><br><span class="line">2) &quot;foo&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;message&quot;</span><br><span class="line">2) &quot;foo&quot;</span><br><span class="line">3) &quot;hahaha&quot;</span><br></pre></td></tr></table></figure>

<p>这就是redis的发布订阅或者说是消息队列功能</p>
<p>它还支持根据通配符的订阅方式,PSUBSCRIBE</p>
<p>比如订阅 以a开头以b结尾 的主题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE a*b</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;a*b&quot;</span><br><span class="line">3) (integer) 1</span><br></pre></td></tr></table></figure>

<p>这时候就可以发布 a一坨东西b 发布一个”haha”</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH afewrupdb haha</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>订阅的客户端也可以收到</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE a*b</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) &quot;psubscribe&quot;</span><br><span class="line">2) &quot;a*b&quot;</span><br><span class="line">3) (integer) 1</span><br><span class="line">1) &quot;pmessage&quot;</span><br><span class="line">2) &quot;a*b&quot;</span><br><span class="line">3) &quot;afewrupdb&quot;</span><br><span class="line">4) &quot;haha&quot;</span><br></pre></td></tr></table></figure>

<h2 id="incr-decr数值增减操作"><a href="#incr-decr数值增减操作" class="headerlink" title="incr/decr数值增减操作"></a>incr/decr数值增减操作</h2><p>属于 string 类型的拓展操作, 会将 string 转换类型增加或减少, 再转回来,</p>
<p>支持正整数和负整数, 不能转换或数值过大会抛异常</p>
<ul>
<li><p>设置数值数据增加指定范围的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">incr key</span><br><span class="line">incrby key increment</span><br><span class="line">incrbyfloay key increment</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置数字数据减少指定范围的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">decr key</span><br><span class="line">decrby key increment</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="与springboot整合"><a href="#与springboot整合" class="headerlink" title="与springboot整合"></a>与springboot整合</h2><ul>
<li><p><strong>添加依赖:</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置 Redis:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">springboot-learn-redis</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="string">localhost</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">database:</span> <span class="number">0</span> <span class="comment">#数据库索引(默认为0)</span></span><br><span class="line">    <span class="attr">password:</span>  <span class="comment">#服务器连接密码(默认为空)</span></span><br><span class="line">    <span class="attr">jedis:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span> <span class="comment">#连接池最大连接数（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="number">-1</span>  <span class="comment"># 连接池最大阻塞等待时间（使用负值表示没有限制）</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span>   <span class="comment"># 连接池中的最大空闲连接</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span>   <span class="comment"># 连接池中的最小空闲连接</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="RedisTemplate"><a href="#RedisTemplate" class="headerlink" title="RedisTemplate"></a>RedisTemplate</h3><ul>
<li><p>Spring Boot 的 <code>spring-boot-starter-data-redis</code> 为 Redis 的相关操作提供了一个高度封装的 <strong>RedisTemplate</strong> 类，而且对每种类型的数据结构都进行了归类，将同一类型操作封装为 operation 接口。<code>RedisTemplate</code> 对五种数据结构分别定义了操作，如下所示：</p>
<ul>
<li>操作字符串：<code>redisTemplate.opsForValue()</code></li>
<li>操作 Hash：<code>redisTemplate.opsForHash()</code></li>
<li>操作 List：<code>redisTemplate.opsForList()</code></li>
<li>操作 Set：<code>redisTemplate.opsForSet()</code></li>
<li>操作 ZSet：<code>redisTemplate.opsForZSet()</code></li>
</ul>
</li>
<li><p>但是对于 string 类型的数据，Spring Boot 还专门提供了 <code>StringRedisTemplate</code> 类，而且官方也建议使用该类来操作 String 类型的数据。那么它和 <code>RedisTemplate</code> 又有啥区别呢？</p>
<ol>
<li><code>RedisTemplate</code> 是一个泛型类，而 <code>StringRedisTemplate</code> 不是，后者只能对键和值都为 String 类型的数据进行操作，而前者则可以操作任何类型。</li>
<li>两者的数据是不共通的，<code>StringRedisTemplate</code> 只能管理 <code>StringRedisTemplate</code> 里面的数据，<code>RedisTemplate</code> 只能管理 <code>RedisTemplate</code> 中 的数据。</li>
</ol>
</li>
<li><p><strong>RedisTemplate 的配置</strong></p>
<p>一个 Spring Boot 项目中，我们只需要维护一个 <code>RedisTemplate</code> 对象和一个 <code>StringRedisTemplate</code> 对象就可以了。所以我们需要通过一个 <code>Configuration</code> 类来初始化这两个对象并且交由的 <code>BeanFactory</code> 管理。我们在 <code>config</code> 包下面新建了一个 <code>RedisConfig</code> 类，其内容如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">//仅当 BeanFactory 中不包含指定的 bean class 和/或 name 时条件匹配</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisTemplate&lt;String, Object&gt; <span class="title">redisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">        Jackson2JsonRedisSerializer&lt;Object&gt; jackson2JsonRedisSerializer = <span class="keyword">new</span> Jackson2JsonRedisSerializer&lt;Object&gt;(Object.class);</span><br><span class="line">        ObjectMapper om = <span class="keyword">new</span> ObjectMapper();</span><br><span class="line">        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);</span><br><span class="line">        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);</span><br><span class="line">        jackson2JsonRedisSerializer.setObjectMapper(om);</span><br><span class="line"></span><br><span class="line">        RedisTemplate&lt;String, Object&gt; template = <span class="keyword">new</span> RedisTemplate&lt;String, Object&gt;();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        template.setKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashKeySerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.setHashValueSerializer(jackson2JsonRedisSerializer);</span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@ConditionalOnMissingBean(StringRedisTemplate.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> StringRedisTemplate <span class="title">stringRedisTemplate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;</span><br><span class="line">        StringRedisTemplate template = <span class="keyword">new</span> StringRedisTemplate();</span><br><span class="line">        template.setConnectionFactory(redisConnectionFactory);</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="操作字符串"><a href="#操作字符串" class="headerlink" title="操作字符串"></a>操作字符串</h3><ul>
<li>设置值，对于设置值，我们可以使用 <code>opsForValue().void set(K var1, V var2)</code>;</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * set字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSet</span><span class="params">()</span></span>&#123;</span><br><span class="line"> 	stringRedisTemplate.opsForValue().set(<span class="string">&quot;testK&quot;</span>, <span class="string">&quot;Hello Redis&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取值，与 set 方法相对于 StringRedisTemplate 还提供了 <code>.opsForValue().get(Object var1)</code> 方法来获取指定 key 对应的 value 值。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * get字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(stringRedisTemplate.opsForValue().get(<span class="string">&quot;testK&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置值的时候设置过期时间。在设置缓存的时候，我们通常都会给他设置一个过期时间，让其能够达到定时刷新的效果。<code>StringRedisTemplate</code> 提供了 <code>void set(K var1, V var2, long var3, TimeUnit var5)</code> 方法来达到设置过期时间的目的，其中 <code>var3</code> 这个参数就是过期时间的数值，而 <code>TimeUnit</code> 是个枚举类型，我们用它来设置过期时间的单位，是小时或是秒等等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置过期时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stringRedisTemplate.opsForValue().set(<span class="string">&quot;testExp&quot;</span>, <span class="string">&quot;有过期时间的string&quot;</span>, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>删除数据，我们同样可以通过 StringRedisTmeplate 来删除数据， Boolean delete(K key)方法提供了这个功能。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelStr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    stringRedisTemplate.delete(<span class="string">&quot;testK&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="操作列表"><a href="#操作列表" class="headerlink" title="操作列表"></a>操作列表</h3><ol>
<li><p>leftPush(K key, V value)，往 List 左侧插入一个元素，如 从左边往数组中 push 元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     redisTemplate.opsForList().leftPush(<span class="string">&quot;TestList&quot;</span>, <span class="string">&quot;TestLeftPush&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rightPush(K key, V value)，往 List 右侧插入一个元素， 如从右边往数组中 push 元素：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRightPush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     redisTemplate.opsForList().rightPush(<span class="string">&quot;TestList&quot;</span>, <span class="string">&quot;TestRightPush&quot;</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>leftPop(K key)，从 List 左侧取出第一个元素，并移除， 如从数组头部获取并移除值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLeftPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object leftFirstElement = redisTemplate.opsForList().leftPop(<span class="string">&quot;TestList&quot;</span>);</span><br><span class="line">    System.out.println(leftFirstElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>rightPop(K key)，从 List 右侧取出第一个元素，并移除， 如从数组尾部获取并移除值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRightPop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object rightFirstElement = redisTemplate.opsForList().rightPop(<span class="string">&quot;TestList&quot;</span>);</span><br><span class="line">        System.out.println(rightFirstElement);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="操作-Hash"><a href="#操作-Hash" class="headerlink" title="操作 Hash"></a>操作 Hash</h3><ol>
<li><p>Hash 中新增元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().put(<span class="string">&quot;TestHash&quot;</span>, <span class="string">&quot;FirstElement&quot;</span>, <span class="string">&quot;Hello,Redis hash.&quot;</span>);</span><br><span class="line">        Assert.assertTrue(redisTemplate.opsForHash().hasKey(<span class="string">&quot;TestHash&quot;</span>, <span class="string">&quot;FirstElement&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>判断指定 key 对应的 Hash 中是否存在指定的 map 键，使用用法可以见上方代码所示。</p>
</li>
<li><p>获取指定 key 对应的 Hash 中指定键的值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Object element = redisTemplate.opsForHash().get(<span class="string">&quot;TestHash&quot;</span>, <span class="string">&quot;FirstElement&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;Hello,Redis hash.&quot;</span>, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除指定 key 对应 Hash 中指定键的键值对。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForHash().delete(<span class="string">&quot;TestHash&quot;</span>, <span class="string">&quot;FirstElement&quot;</span>);</span><br><span class="line">        Assert.assertFalse(redisTemplate.opsForHash().hasKey(<span class="string">&quot;TestHash&quot;</span>, <span class="string">&quot;FirstElement&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="操作集合"><a href="#操作集合" class="headerlink" title="操作集合"></a>操作集合</h3><ol>
<li><p>向集合中添加元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForSet().add(<span class="string">&quot;TestSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>, <span class="string">&quot;e3&quot;</span>);</span><br><span class="line">        <span class="keyword">long</span> size = redisTemplate.opsForSet().size(<span class="string">&quot;TestSet&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3L</span>, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>获取集合中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;String&gt; testSet = redisTemplate.opsForSet().members(<span class="string">&quot;TestSet&quot;</span>);</span><br><span class="line">        System.out.println(testSet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行上面的代码后，控制台输出的是[e1, e3, e2]，当然您可能会看到其他结果，因为 Set 是无序的，并不是按照我们添加的顺序来排序的。</p>
</li>
<li><p>获取集合的长度，在像集合中添加元素的示例代码中展示了如何获取集合长度。</p>
</li>
<li><p>移除集合中的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testRemove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        redisTemplate.opsForSet().remove(<span class="string">&quot;TestSet&quot;</span>, <span class="string">&quot;e1&quot;</span>, <span class="string">&quot;e2&quot;</span>);</span><br><span class="line">        Set testSet = redisTemplate.opsForSet().members(<span class="string">&quot;TestSet&quot;</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">&quot;e3&quot;</span>, testSet.toArray()[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="操作有序集合"><a href="#操作有序集合" class="headerlink" title="操作有序集合"></a>操作有序集合</h3><p>与 Set 不一样的地方是，ZSet 对于集合中的每个元素都维护了一个权重值，那么 RedisTemplate 提供了不少与这个权重值相关的 API。</p>
<table>
<thead>
<tr>
<th align="left"><strong>API</strong></th>
<th align="left"><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">add(K key, V value, double score)</td>
<td align="left">添加元素到变量中同时指定元素的分值。</td>
</tr>
<tr>
<td align="left">range(K key, long start, long end)</td>
<td align="left">获取变量指定区间的元素。</td>
</tr>
<tr>
<td align="left">rangeByLex(K key, RedisZSetCommands.Range range</td>
<td align="left">用于获取满足非 <code>score</code> 的排序取值。这个排序只有在有相同分数的情况下才能使用，如果有不同的分数则返回值不确定。</td>
</tr>
<tr>
<td align="left"><code>angeByLex(K key, RedisZSetCommands.Range range, RedisZSetCommands.Limit limit)</code></td>
<td align="left">用于获取满足非 <code>score</code> 的设置下标开始的长度排序取值。</td>
</tr>
<tr>
<td align="left"><code>add(K key, Set&lt;ZSetOperations.TypedTuple&lt;V&gt;&gt; tuples)</code></td>
<td align="left">通过 <code>TypedTuple</code> 方式新增数据。</td>
</tr>
<tr>
<td align="left"><code>rangeByScore(K key, double min, double max)</code></td>
<td align="left">根据设置的 score 获取区间值。</td>
</tr>
<tr>
<td align="left"><code>rangeByScore(K key, double min, double max,long offset, long count)</code></td>
<td align="left">根据设置的 <code>score</code> 获取区间值从给定下标和给定长度获取最终值。</td>
</tr>
<tr>
<td align="left"><code>rangeWithScores(K key, long start, long end)</code></td>
<td align="left">获取 RedisZSetCommands.Tuples 的区间值。</td>
</tr>
</tbody></table>
<p>以上只是简单的介绍了一些最常用的 API，<code>RedisTemplate</code> 针对字符串、数组、Hash、集合以及有序集合还提供了很多 API,具体有哪些 API，大家可以参考 <a href="https://blog.csdn.net/sinat_27629035/article/details/102652185">RedisTemplate 提供的 API 列表</a>这篇文章。</p>
<h2 id="实现分布式锁"><a href="#实现分布式锁" class="headerlink" title="实现分布式锁"></a>实现分布式锁</h2><p>上面基本列出了 <code>RedisTemplate</code> 和 <code>StringRedisTemplate</code> 两个类所提供的对 Redis 操作的相关 API，但是有些时候这些 API 并不能完成我们所有的需求，这个时候我们其实还可以在 Spring Boot 项目中直接与 Redis 交互来完成操作。比如，我们在实现分布式锁的时候其实就是使用了 <code>RedisTemplate</code> 的 <code>execute</code> 方法来执行 Lua 脚本来获取和释放锁的。</p>
<p><strong>获取锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Boolean lockStat = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;)connection -&gt;</span><br><span class="line">        connection.set(<span class="string">&quot;key&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)), <span class="string">&quot;value&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)),</span><br><span class="line">                   Expiration.from(<span class="number">10</span>, TimeUnit.MINUTES), RedisStringCommands.SetOption.SET_IF_ABSENT));</span><br></pre></td></tr></table></figure>

<p><strong>释放锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Lua</span></span><br><span class="line">String script = <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> unLockStat = stringRedisTemplate.execute((RedisCallback&lt;Boolean&gt;)connection -&gt;</span><br><span class="line">        connection.eval(script.getBytes(), ReturnType.BOOLEAN, <span class="number">1</span>,</span><br><span class="line">                  <span class="string">&quot;key&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>)), <span class="string">&quot;value&quot;</span>.getBytes(Charset.forName(<span class="string">&quot;UTF-8&quot;</span>))));</span><br></pre></td></tr></table></figure>

<h2 id="Redis的原子性"><a href="#Redis的原子性" class="headerlink" title="Redis的原子性"></a>Redis的原子性</h2><p><strong>原子性</strong></p>
<p>原子性是数据库的事务中的特性。在数据库事务的情景下，原子性指的是：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。<br>对于Redis而言，命令的原子性指的是：一个操作的不可以再分，操作要么执行，要么不执行。</p>
<p><strong>Redis操作原子性的原因</strong></p>
<p>Redis的操作之所以是原子性的，是因为Redis是==单线程==的。<br>由于对操作系统相关的知识不是很熟悉，从上面这句话并不能真正理解Redis操作是原子性的原因，进一步查阅进程与线程的概念及其区别。</p>
<p><strong>进程与线程</strong></p>
<ul>
<li>进程<br>计算机中已执行程序的实体。比如，一个启动了的php-fpm，就是一个进程。</li>
<li>线程<br>操作系统能够进行运算调度的最小单元。它被包含在进程之中，是进程的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。比如，mysql运行时，mysql启动后，该mysql服务就是一个进程，而mysql的连接、查询的操作，就是线程。</li>
</ul>
<p><strong>进程与线程的区别</strong></p>
<ul>
<li>资源（如打开文件）：进程间的资源相互独立，同一进程的各线程间共享资源。某进程的线程在其他进程不可见。</li>
<li>通信：进程间通信：消息传递、同步、共享内存、远程过程调用、管道。线程间通信：直接读写进程数据段（需要进程同步和互斥手段的辅助，以保证数据的一致性）。</li>
<li>调度和切换：线程上下文切换比进程上下文切换要快得多。<br>线程，是操作系统最小的执行单元，在单线程程序中，任务一个一个地做，必须做完一个任务后，才会去做另一个任务。</li>
</ul>
<p><strong>Redis在并发中的表现</strong></p>
<p>Redis的API是原子性的操作，那么多个命令在并发中也是原子性的吗？<br>看看下面这段代码：</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><span class="line">$redis= newRedis();</span><br><span class="line">$redis-&gt;connect(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">6379</span>);</span><br><span class="line"><span class="keyword">for</span>($i= <span class="number">0</span>;$iget(<span class="string">&#x27;val&#x27;</span>);</span><br><span class="line">$num++;</span><br><span class="line">$redis-&gt;set(<span class="string">&#x27;val&#x27;</span>,$num);</span><br><span class="line">usleep(<span class="number">10000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>用两个终端执行上面的程序，发现val的结果是小于2000的值，那么可以知道，在程序中执行多个Redis命令并非是原子性的，这也和普通数据库的表现是一样的。<br>如果想在上面的程序中实现原子性，可以将get和set改成单命令操作，比如<strong>incr</strong>，或者使用Redis的事务，或者使用Redis+Lua的方式实现。</p>
<p><strong>原子性总结</strong></p>
<p>综上所述，对Redis来说，执行get、set以及eval等API，都是一个一个的任务，这些任务都会由Redis的线程去负责执行，任务要么执行成功，要么执行失败，这就是Redis的命令是原子性的原因。</p>
<blockquote>
<p>Redis本身提供的所有API都是原子操作，Redis中的事务其实是要保证批量操作的原子性。</p>
</blockquote>
<p><strong>事务</strong></p>
<p><strong>Redis事务的特性：</strong></p>
<ul>
<li>事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>没有隔离级别，事务提交前结果不可见，事务提交执行后可见</li>
<li>不保证原子性，Redis 同一个事务中有命令执行失败，其后的命令仍然会被执行，不会回滚</li>
</ul>
<p><strong>事务三阶段：</strong></p>
<ul>
<li>开启：MULTI 指令开启一个事务</li>
<li>入队：将多个命令入队到事务中，这些命令不会立即执行，而是放到等待执行的事务队列</li>
<li>执行：由 EXEC 指令触发事务执行</li>
</ul>
<p><strong>事务的关键字</strong></p>
<ul>
<li>multi，标记一个事务块的开始，返回 ok</li>
<li>exec，执行所有事务块内，事务块内所有命令执行的先后顺序的返回值，操作被，返回空值 nil</li>
<li>discard，取消事务，放弃执行事务块内的所有命令，返回 ok</li>
<li>watch，监视 key 在事务执行之前是否被其他指令改动，若已修改则事务内的指令取消执行，返回 ok</li>
<li>unwatch，取消 watch 命令对 key 的监视，返回 ok</li>
</ul>
<p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务相关的命令。事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li><p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p>
</li>
<li><p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p>
</li>
<li><p>EXEC 命令负责触发并执行事务中的所有命令：<br>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</p>
</li>
<li><p>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。<br>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。<br>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。<br>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。<br>使用redis-check-aof程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。<br>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</p>
</li>
<li><p>一旦 EXEC 指令执行，之前加的监控锁就会取消</p>
</li>
<li><p>Watch 指令，类似乐观锁，事务提交时，如果 Key 的值已被别的客户端改变，整个事务队列都不会被执行</p>
</li>
</ul>
<p><strong>事务的语句</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>

<p><strong>为什么 Redis 不支持回滚（roll back）</strong></p>
<p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。<br>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。<br>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</li>
</ul>
<blockquote>
<p>原文连接: <a href="https://www.cnblogs.com/lori/p/9300087.html">https://www.cnblogs.com/lori/p/9300087.html</a></p>
</blockquote>
<h2 id="Redis-几个经典问题"><a href="#Redis-几个经典问题" class="headerlink" title="Redis 几个经典问题"></a>Redis 几个经典问题</h2><h3 id="缓存与数据库一致性问题"><a href="#缓存与数据库一致性问题" class="headerlink" title="缓存与数据库一致性问题"></a>缓存与数据库一致性问题</h3><p>对于既有数据库操作又有缓存操作的接口，一般分为两种执行顺序。</p>
<ol>
<li>先操作数据库，再操作缓存。这种情况下如果数据库操作成功，缓存操作失败就会导致缓存和数据库不一致。</li>
<li>第二种情况就是先操作缓存再操作数据库，这种情况下如果缓存操作成功，数据库操作失败也会导致数据库和缓存不一致。</li>
</ol>
<p>大部分情况下，我们的缓存理论上都是需要可以从数据库恢复出来的，所以基本上采取第一种顺序都是不会有问题的。针对那些必须保证数据库和缓存一致的情况，通常是不建议使用缓存的。</p>
<h3 id="缓存击穿问题"><a href="#缓存击穿问题" class="headerlink" title="缓存击穿问题"></a>缓存击穿问题</h3><p>缓存击穿表示恶意用户频繁的模拟请求缓存中不存在的数据，以致这些请求短时间内直接落在了数据库上，导致数据库性能急剧下降，最终影响服务整体的性能。这个在实际项目很容易遇到，如抢购活动、秒杀活动的接口 API 被大量的恶意用户刷，导致短时间内数据库宕机。对于缓存击穿的问题，有以下几种解决方案，这里只做简要说明。</p>
<ol>
<li>使用互斥锁排队。当从缓存中获取数据失败时，给当前接口加上锁，从数据库中加载完数据并写入后再释放锁。若其它线程获取锁失败，则等待一段时间后重试。</li>
<li>使用布隆过滤器。将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及 DB 挂掉。</li>
</ol>
<h3 id="缓存雪崩问题"><a href="#缓存雪崩问题" class="headerlink" title="缓存雪崩问题"></a>缓存雪崩问题</h3><p>在短时间内有大量缓存失效，如果这期间有大量的请求发生同样也有可能导致数据库发生宕机。在 Redis 机群的数据分布算法上如果使用的是传统的 hash 取模算法，在增加或者移除 Redis 节点的时候就会出现大量的缓存临时失效的情形。</p>
<ol>
<li>像解决缓存穿透一样加锁排队。</li>
<li>建立备份缓存，缓存 A 和缓存 B，A 设置超时时间，B 不设值超时时间，先从 A 读缓存，A 没有读 B，并且更新 A 缓存和 B 缓存。</li>
<li>计算数据缓存节点的时候采用一致性 hash 算法，这样在节点数量发生改变时不会存在大量的缓存数据需要迁移的情况发生。</li>
</ol>
<h3 id="缓存并发问题"><a href="#缓存并发问题" class="headerlink" title="缓存并发问题"></a>缓存并发问题</h3><p>这里的并发指的是多个 Redis 的客户端同时 set 值引起的并发问题。比较有效的解决方案就是把 set 操作放在队列中使其串行化，必须得一个一个执行。</p>
<blockquote>
<p>原文地址: <a href="https://developer.ibm.com/zh/articles/know-redis-and-use-it-in-springboot-projects/">https://developer.ibm.com/zh/articles/know-redis-and-use-it-in-springboot-projects/</a></p>
</blockquote>
<h2 id="redis高可用集群"><a href="#redis高可用集群" class="headerlink" title="redis高可用集群"></a>redis高可用集群</h2><p>Redis 集群是一个提供在多个 Redis 节点间共享数据的程序集。</p>
<p>Redis 集群并不支持处理多个 keys 的命令,因为这需要在不同的节点间移动数据，从而达不到像 Redis 那样的性能，在高负载的情况下可能会导致不可预料的错误.</p>
<p>Redis 集群通过分区来提供一定程度的可用性，在实际环境中当某个节点宕机或者不可达的情况下继续处理命令。</p>
<p>Redis 集群的优势:</p>
<ul>
<li>自动分割数据到不同的节点上。</li>
<li>整个集群的部分节点失败或者不可达的情况下能够继续处理命令。</li>
</ul>
<p>Redis 集群没有使用一致性 hash, 而是引入了哈希槽的概念。Redis 集群有 16384 个哈希槽，每个 key 通过 CRC16 校验后对 16384 取模来决定放置哪个槽，集群的每个节点负责一部分 hash 槽。</p>
<h3 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h3><p>启动三个redis容器</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run --name redis-6379 -p 6379:6379 -d redis</span><br><span class="line">docker run --name redis-6380 -p 6380:6379 -d redis</span><br><span class="line">docker run --name redis-6390 -p 6381:6379 -d redis</span><br></pre></td></tr></table></figure>

<p>选一个作为主机,查看ip地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID</span><br></pre></td></tr></table></figure>

<p>从机配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">docker exec -it 容器ID /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">使用客户端</span></span><br><span class="line">redis-cli</span><br><span class="line"><span class="meta">#</span><span class="bash">设置为某台机器的从机</span></span><br><span class="line">SLAVEOF 主机ip 6379</span><br><span class="line"><span class="meta">#</span><span class="bash">查看主从复制信息</span></span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>

<p> 在主机使用 info replication 命令，验证主从关系是否配置成功 </p>
<p>修改配置文件的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">slaveof host port</span><br></pre></td></tr></table></figure>

<p>映射配置文件<code>-v 外部目录/redis: /data redis-serer 配置文件.conf</code></p>
<h3 id="哨兵-sentinel"><a href="#哨兵-sentinel" class="headerlink" title="哨兵(sentinel)"></a>哨兵(<strong>sentinel</strong>)</h3><p>redis的sentinel系统用于管理多个redis服务器，该系统主要执行三个任务：监控、提醒、自动故障转移。</p>
<p>1、<strong>监控</strong>（Monitoring）： Redis Sentinel实时监控主服务器和从服务器运行状态，并且实现自动切换。</p>
<p>2、<strong>提醒</strong>（Notification）：当被监控的某个 Redis 服务器出现问题时， Redis Sentinel 可以向系统管理员发送通知， 也可以通过 API 向其他程序发送通知。</p>
<p>3、<strong>自动故障转移</strong>（Automatic failover）： 当一个主服务器不能正常工作时，Redis Sentinel 可以将一个从服务器升级为主服务器， 并对其他从服务器进行配置，让它们使用新的主服务器。当应用程序连接Redis 服务器时， Redis Sentinel会告之新的主服务器地址和端口。</p>
<p><strong>主观下线和客观下线：</strong></p>
<p>1、主观下线状态：当一个sentinel认为一个redis服务连接不上的时候，会给这个服务打个标记为下线状态。</p>
<p>2、客观下线状态：当多个sentinel认为一个redids连接不上的时候，则认为这个redis服务确实下线了。这里的多个sentinel的个数可以在配置文件中设置。</p>
<p><strong>三个定时监控任务</strong></p>
<p>sentinel通过三个定时监控任务实现对各个节点的发现和监控。</p>
<ul>
<li><strong>每隔10秒</strong>，每个sentinel节点都会向主节点和从节点发送info命令获取对应节点的信息(对主节点执行info replication命令可以获取从节点的信息，所以sentinel中只需要配置主节点信息就可以获取所有从节点信息)。</li>
<li><strong>每隔2秒</strong>，每个sentinel节点会向Redis数据节点的<em>sentinel</em>:hello频道上发送该节点对于主节点状态的判断以及自己的信息。sentinel连接redis实例时，会创建两个连接，一个是commands命令连接和一个pub/sub发布订阅连接。每个sentinel也会订阅<em>sentinel</em>:hello这个频道，用于接收其它sentinel发布的消息以了解其它sentinel节点对于主节点状态的判断(为主节点客观下线做依据)以及其它sentinel节点的信息(用于发现新的sentinel节点)。</li>
<li><strong>每隔1秒</strong>，每个sentinel节点会向主节点、从节点、其它sentinel节点发送一个ping命令做心跳检测，来确认这些节点是否可达。</li>
</ul>
<h4 id="sentinel配置"><a href="#sentinel配置" class="headerlink" title="sentinel配置"></a>sentinel配置</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 后台启动</span></span><br><span class="line">daemonize yes</span><br><span class="line"><span class="comment">#哨兵监控的主机ip 端口</span></span><br><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点响应sentinel的最大时间间隔，超过这个时间，sentinel认为主节点下线，默认30秒  </span></span><br><span class="line">sentinel down-after-milliseconds mymaster <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进行故障转移时，设置最多有多少个slave同时复制新的master</span></span><br><span class="line"><span class="comment"># 由于slave在复制时，会处于不可用的状态(要先清空数据，然后再加载主节点的数据)</span></span><br><span class="line"><span class="comment"># 所以设置一次允许一个slave去复制master</span></span><br><span class="line">sentinel parallel-syncs master <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主节点如果设置了密码，就在这里配置</span></span><br><span class="line">sentinel auth-<span class="keyword">pass</span> mymaster <span class="number">123456</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># log文件的位置</span></span><br><span class="line">logfile /var/log/redis/sentinel1.log</span><br></pre></td></tr></table></figure>

<p><code>&lt;quorum&gt;</code>参数为需要判定客观下线所需的主观下线sentinel个数，这个参数不可以大于sentinel个数。</p>
<h4 id="快速搭建"><a href="#快速搭建" class="headerlink" title="快速搭建"></a>快速搭建</h4><p>1.启动三个容器并配置主从复制</p>
<p>接下来直接进入3台redis容器内部进行配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec -ti 容器id &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>进入根目录创建sentinel.conf文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F; &amp;&amp; touch sentinel.conf</span><br></pre></td></tr></table></figure>

<p>修改文件内容为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &#39;sentinel monitor mymaster 172.17.0.2 6379 1&#39; &gt;&gt; &#x2F;sentinel.conf</span><br></pre></td></tr></table></figure>

<p>最后，启动Redis哨兵：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">使用 redis-sentinel &#x2F;sentinel.conf 启动Redis哨兵监控</span><br><span class="line">退出容器,使用 ps –ef |grep redis 命令，可以看到redis-server和redis-sentinel正在运行</span><br></pre></td></tr></table></figure>

<p>至此，Sentinel哨兵配置完毕。</p>
<p><strong>测试</strong></p>
<p>查看哨兵监控情况</p>
<ul>
<li><code>SENTINEL masters</code> ：列出所有被监视的主服务器，以及这些主服务器的当前状态。</li>
<li><code>SENTINEL slaves </code> ：列出给定主服务器的所有从服务器，以及这些从服务器的当前状态。</li>
</ul>
<p>尝试关闭主机</p>
<p>再查看剩余2个从机，这里会自动选举产生新的主机</p>
<p>然后，我们再次将刚才停止的主机启动起来，发现启动后其自动成为从机</p>
<h2 id="Redis实例配置参数"><a href="#Redis实例配置参数" class="headerlink" title="Redis实例配置参数"></a>Redis实例配置参数</h2><p><strong>操作场景</strong>：<br>Redis的配置参数可以通过<code>CONFIG SET</code>命令直接修改，无需重启服务。 修改命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; config set parameter value</span><br></pre></td></tr></table></figure>

<p><code>config get parameter value</code>可查看具体参数值</p>
<p><strong>实例要求</strong> :</p>
<ul>
<li><p>实例状态必须是“运行中”。 </p>
</li>
<li><p>对于Redis实例，目前只支持“单机”和“主备”实例修改运行参数，“集群”实例暂不支持。</p>
</li>
</ul>
<p>实例的各配置参数如下所示。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>参数解释</th>
<th>取值范围</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>timeout</td>
<td>客户端与服务端连接空闲超时断开时间，参数设为 0表示连接永不断开。</td>
<td>0~7200，单位：秒。</td>
<td>0</td>
</tr>
<tr>
<td>maxmemory-policy</td>
<td>内存使用达到上限时对缓存数据管理策略。<br/>参数说明请参考<a href="https://redis.io/topics/lru-cache">https://redis.io/topics/lru-cache</a></td>
<td>• volatile-lru • allkeys-lru • volatile-random • allkeys-random • volatile-ttl • noeviction</td>
<td>noeviction</td>
</tr>
<tr>
<td>hash-max-ziplist-entries</td>
<td>当hash表中记录数少于参数值，使用ziplist编码格式， 节约内存。</td>
<td>1~10000</td>
<td>512</td>
</tr>
<tr>
<td>hash-max-ziplist-value</td>
<td>当hash表中各字段长度的最大值小于参数值时，使 用ziplist编码格式，节约内存</td>
<td>1~10000</td>
<td>64</td>
</tr>
<tr>
<td>list-max-ziplist-entries</td>
<td>当列表中记录数少于参数值，使用ziplist编码格式， 节约内存。</td>
<td>1~10000</td>
<td>512</td>
</tr>
<tr>
<td>list-max-ziplist-value</td>
<td>当列表中各字段长度的最大值小于参数值时，使用 ziplist编码格式，节约内存。</td>
<td>1~10000</td>
<td>64</td>
</tr>
<tr>
<td>set-max-intset-entries</td>
<td>当一个集合仅包含字符串且整形元素数量少于参数 值时，使用intset编码格式，节约内存。</td>
<td>1~10000</td>
<td>512</td>
</tr>
<tr>
<td>zset-max-ziplist-entries</td>
<td>当有序集合中记录数少于参数值，使用ziplist编码格 式，节约内存。</td>
<td>1~10000</td>
<td>128</td>
</tr>
<tr>
<td>zset-max-ziplist-value</td>
<td>当有序集合中各字段长度的最大值小于参数值时， 使用ziplist编码格式，节约内存。</td>
<td>1~10000</td>
<td>64</td>
</tr>
<tr>
<td>latency-monitor-threshold</td>
<td>延时监控的采样时间阈值（最小值）。<br/>当阈值设置为0时，不做监控，也不采样；当阈值 设置为大于0时，将监控并记录执行耗时大于阈值 的操作。<br/>用户可以通过LATENCY等命令获取统计数据和配 置、执行采样监控。详情参考Redis官网说明： <a href="https://redis.io/topics/latency-monitor%E3%80%82">https://redis.io/topics/latency-monitor。</a></td>
<td>0~86400000，单位：毫秒。</td>
<td>0</td>
</tr>
<tr>
<td>reserved-memory</td>
<td>预留内存，主备实例才有此配置。<br/>预留内存将被分配给实例所在虚拟机，保证DCS缓 存实例后台进程在做持久化和主从同步等任务时拥 有足够的内存。<br/>预留内存大小可以调高或者调低，但不能超过实例 当前剩余的可用内存，以及最大可用内存的50%。 其中实例最大可用内存可参考《分布式缓存服务产 品介绍》。</td>
<td>实例最大可用内存数的050%，同时不能超过实例 当前剩余的可用内存，具 体以界面提示为准，单位： MB。</td>
<td>0</td>
</tr>
<tr>
<td>notify-keyspace-events</td>
<td>键空间通知，配置该参数后客户端可以通过Redis的 订阅与发布功能，来接收那些以某种方式改动了 Redis数据集的事件。</td>
<td>可配置表格下方指定的任 意组合，指定服务器发送 哪些类型的通知。</td>
<td>Ex</td>
</tr>
</tbody></table>
<p><strong>notify-keyspace-events参数说明</strong><br>说明： notify-keyspace-events参数的取值范围如下： </p>
<p>K：键空间通知，所有通知以__keyspace@__为前缀。 </p>
<p>E：键事件通知，所有通知以__keyevent@__为前缀。 </p>
<p>g：DEL、EXPIRE、RENAME等类型无关的通用命令的通知。 </p>
<p>$：字符串命令的通知。 </p>
<p>l：列表命令的通知。 </p>
<p>s：集合命令的通知。</p>
<p> h：哈希命令的通知。 </p>
<p>z：有序集合命令的通知。</p>
<p>x：过期事件：每当有过期键被删除时发送。 </p>
<p>e：驱逐(evict)事件：每当有键因为maxmemory政策而被删除时发送。</p>
<p><strong>案例场景</strong><br>用户在Redis实例使用过程中，禁用了客户端空闲N秒后关闭连接的功能，当用户在线访问量大时，造成新用户无法接入。<br><strong>解决方案</strong><br>首先，开启客户端空闲关闭连接的功能。即将timeout设置为非0的值，例如可以设置成客户端空闲5分钟（即N=300）后 自动关闭连接。<br>其次，需要删除即将过期的键值</p>
<h2 id="Redis实例常用命令"><a href="#Redis实例常用命令" class="headerlink" title="Redis实例常用命令"></a>Redis实例常用命令</h2><p>Info 是Redis提供的一个非常有用的查看状态信息的命令,使用redis-cli连接Redis, 输入 <code>info all</code>命令, redis-server就会返回Redis的状态信息, 详细内容如下:</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>server</td>
<td>获取 server 信息，包括 version, OS, port 等信息</td>
</tr>
<tr>
<td>clients</td>
<td>获取 clients 信息，如客户端连接数等</td>
</tr>
<tr>
<td>memory</td>
<td>获取 server 的内存信息，包括当前内存消耗、内存使用峰值</td>
</tr>
<tr>
<td>persistence</td>
<td>获取 server 的持久化配置信息</td>
</tr>
<tr>
<td>stats</td>
<td>获取 server 的一些基本统计信息，如处理过的连接数量等</td>
</tr>
<tr>
<td>replication</td>
<td>获取 server 的主从配置信息</td>
</tr>
<tr>
<td>cpu</td>
<td>获取 server 的 CPU 使用信息</td>
</tr>
<tr>
<td>keyspace</td>
<td>获取 server 中各个 DB 的 key 的数量</td>
</tr>
<tr>
<td>cluster</td>
<td>获取集群节点信息，仅在开启集群后可见</td>
</tr>
<tr>
<td>commandstats</td>
<td>获取每种命令的统计信息</td>
</tr>
</tbody></table>
<p>其中 memory、stats、clients、keyspace 是 Redis 运行时经常要关注的信息，接下来我们重点对这四项进行解读。</p>
<h3 id="Info-memory"><a href="#Info-memory" class="headerlink" title="Info memory"></a>Info memory</h3><p>对于 Redis 来说，内存是最重要的资源</p>
<ul>
<li><strong>used_memory</strong>：Redis 分配器分配的内存量，也就是实际存储数据的内存总量 </li>
<li><strong>used_memory_human</strong>：以可读格式显示 used_memory  used_memory_rss：以操作系统的角度，显示 Redis 进程占用的总物理内存 </li>
<li><strong>used_memory_rss_human</strong>：以可读格式显示 used_memory_rss </li>
<li><strong>mem_fragmentation_ratio</strong>：used_memory_rss /used_memory 比值，表示内存碎片率</li>
</ul>
<p><strong>used_memory</strong> 反映了当前 Redis 存储数据的内存使用情况，当内存使用率达到Redis 设置的 maxmemory 时，Redis 就会根据设置内存数据逐出策略，以不同的方式移除存储在内存中的数据。比如，如果设置的策略为 noeviction，那么 Redis 会直接返回错误提示。</p>
<p><strong>mem_fragmentation_ratio</strong> 表示的内存碎片率，理解这一指标，对优化 Redis 实例的资源性能是非常重要的。内存碎片 率稍大于 1 是比较合理的范围，此时内存碎片率还比较低，同时也说明 Redis 没有发生 swap。但如果内存碎片率的值 超过了 1.5，那就说明Redis消耗了实际需要物理内存的 150%，其中有 50%是内存碎片率，可以直接判定为Redis内 存碎片过大。内存碎片率是不是越低就越好呢？答案是否定的。当内存碎片率低于 1 时，说明 Redis 内存分配超出了物理 内存，操作系统正在进行 swap，Redis 可能会把部分数据交换到硬盘上。swap 会严重影响 Redis 的性能，造成极大的延迟。</p>
<h3 id="Info-stats"><a href="#Info-stats" class="headerlink" title="Info stats"></a>Info stats</h3><p>stats 可以统计 Redis 的基础信息，比如 Redis 的连接数、命令、网络、同步状态等非常重要的信息。下面介绍几个比较 重要的信息：</p>
<ul>
<li><strong>total_connections_received</strong>：连接过的客户端总数 </li>
<li><strong>total_commands_processed</strong>：处理过的命令总数 </li>
<li><strong>instantaneous_ops_per_sec</strong>：每秒处理的命令数</li>
<li><strong>keyspace_hits</strong>：keyspace命中次数  </li>
<li><strong>keyspace_misses</strong>：keyspace未命中次数 </li>
<li><strong>rejected_connections</strong>：由于maxclients 限制而拒绝的连接数量 </li>
<li><strong>expired_keys</strong>：key 过期事件的总数 </li>
<li><strong>evicted_keys</strong>：由于 maxmemory 限制，而被回收内存的 key 的总数</li>
</ul>
<p><strong>total_connections_received</strong> 和 total_commands_processed 反映了 Redis 服务器自从启动以来，所有处理过的连接数 和命令数。</p>
<p><strong>instantaneous_ops_per_sec</strong> 反应了 Redis 服务器的忙碌状态。当 rejected_connections 的值不为 0 时，说 明应用的连接数过多， 或者 maxclients 配置的太小。</p>
<p>对于应用来说， <strong>keyspace_hits</strong> 和 <strong>keyspace_misses</strong>这两项指标是非常关键的。Redis 对其所有的命令都设置了专门的 标识属性，如“只读”，“写”或者“管理命令”之类，在 Redis 源码中，查看一下 redisCommand 结构体中 sflags 成 员属性字段，就可以知道这个命令是具有哪些属性。<br>比如，w 表示一个写命令（如 set，del 命令），r 表示是一个只读命令（ get ， hmget 命令）， a 则表示一个管理命 令(config,shutdown) 。其中keyspace_hits 和 keyspace_misses 都是针对具备只读属性的 Redis 操作命令做统计，如果 info 统计出来的 keyspace_misses 值过高，或者在过去一段时间内增长很快，那么就说明这一段时间从 Redis 中获取数 据都没有拿到，这时也许就需要检查一下应用数据在Redis 中的存放和访问情况了。如果 key 在明确的时间周期内被使用， 或者旧的 key 将来可能不会被使用，就可以用 Redis 过期时间命令(expire,expireat, pexpire, pexpireat 等)去设置过期时 间，这样 Redis 就会在 key 过期时自动删除 key，这个信息可以通过expired_keys 去查看。当内存使用达到设置的最 大阀值 maxmemory 时，Redis 则会根据设置的 key 逐出策略，淘汰 Redis 中存储的数据，这个信息可以根据 evicted_keys 查看。</p>
<h3 id="Info-clients"><a href="#Info-clients" class="headerlink" title="Info clients"></a>Info clients</h3><p>Redis连接数的意义</p>
<ul>
<li>clients 包含了连接数，输入输出缓冲和阻塞命令连接数等情况  </li>
<li>connected_clients：客户端连接的数量 </li>
<li>client_longest_output_list：当前的客户端连接之中最长的输出列表 </li>
<li>client_biggest_input_buf：当前的客户端连接之中最大的输入缓冲区 </li>
<li>blocked_clients：由于阻塞调用（BLPOP、BRPOP、BRPOPLPUSH）而等待的客户端的数量</li>
</ul>
<p>连接数其实对于 Redis 来说可以看做是一种有限资源，一般 Redis 都配置有最大连接数限制 ，因此了解这个对于确保 应用正常连接也是相当重要的 。 client_longest_output_list 过高则很可能说明现在 Redis 出现了异常，可能要结合 clients list 来排查客户端连接情况。使用了阻塞命令时，blocked_clients也需要重点关注。</p>
<h3 id="Info-keyspace"><a href="#Info-keyspace" class="headerlink" title="Info keyspace"></a>Info keyspace</h3><p>Keyspace 主要提供关于每个 Redis 数据库的主字典的统计数据。这些统计数据包括键的数量、具有过期时间的 key 的 数量和平均生存时间。<br>对于每个数据库来说，keyspace 栏显示的每行信息格式如下所示：</p>
<p>dbX: keys=X,expires=X,avg_ttl=X 其中，</p>
<p>第一个 X 表示数据库的编号，</p>
<p>第二个 X 表示键的数量，</p>
<p>第三个 X 表示具有过期时间的键的数量，</p>
<p>第四个 X 表示 键的平均生存时间。举个例子：</p>
<p>db0:keys=6,expires=0,avg_ttl=0：这就表示当前数据库 0 的 key 总数有 6 个，带有 过期时间的 key 总数 0 个，平均存活时间为 0。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ学习笔记</title>
    <url>/2020/03/26/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>大多应用中,可以通过消息服务中间件来提升系统<strong>异步通信,拓展解耦</strong>能力</p>
<p>消息服务中两个重要概念:</p>
<ul>
<li><p>**消息代理(message broker) **</p>
</li>
<li><p><strong>目的地(destination)</strong></p>
</li>
</ul>
<p>当消息发送者发送消息以后,将由消息代理接管,消息代理保证消息传递到指定目的地.</p>
<p>消息队列主要有两种形式的目的地,对应两种通信方式:</p>
<ul>
<li>**队列(queue):**点对点消息通信(point-to-point)</li>
<li>**主题(topic):**发布(publish) 订阅(subscribe) 消息通信</li>
</ul>
<a id="more"></a>

<p><strong>点对点式:</strong></p>
<p>消息发送者发送消息,消息代理将其放入一个队列中,消息接收者从中获取消息内容,消息读取后被移出队列;消息只有唯一的发送者和接受者,但并不是说只能有一个接收者.(多个接收者来拿这个消息,只能有一个拿到)</p>
<p><strong>发布订阅式:</strong></p>
<p>发送者发布消息到主题,多个接收者订阅这个主题,那么就会在消息到达时同时收到消息.</p>
<p><strong>JMS(Java Message Service) JAVA消息服务:</strong></p>
<p>基于JVM消息代理的规范. ActiveMQ.HornetMQ是JMS实现</p>
<p><strong>AMQP(Advanced Message Queuing Protocol):</strong></p>
<p>高级消息队列协议,也是消息代理的规范,兼容JMS,RabbitMQ是AMQP的实现</p>
<p><strong>spring-jms和spring-rabbit提供了以上两种规范的支持</strong></p>
<ul>
<li><p>需要<code>ConnectionFactory</code>的实现来连接消息代理</p>
</li>
<li><p>提供<code>JmsTemplate,RabbitTemplate</code>来发送消息</p>
</li>
<li><p><code>@JmsListener,@RabbitListener</code>注解在方法上监听消息代理发布的消息</p>
</li>
<li><p><code>@EnableJms,@EnableRabbit</code>开启支持</p>
</li>
<li><p>自动配置类:<code> JmsAutoConfiguration,RabbitAutoConfiguration</code></p>
</li>
</ul>
<p><strong>RabbitMQ是由erlang开发的AMQP的开源实现</strong></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h2><ul>
<li><p><strong>Message</strong></p>
<p>消息,消息是不具名的,它由消息头和消息体组成;消息体是不透明的,而消息头则由一系列的可选属性组成,这些属性包括routing-key(路由键),priority(相对于其他消息的优先权),delivery-mode(指出该消息可能需要持久化存储)等.</p>
</li>
<li><p><strong>Publisher</strong></p>
<p>消息的生产者,也是一个向交换器发布消息的客户端程序.</p>
</li>
<li><p><strong>Exchange</strong></p>
<p>交换器,用来接收生产者发送的消息,并将这些消息路由给服务器中的队列;<strong>Exchange有4种类型</strong>,不同类型的Exchange转发消息的策略有所区别.</p>
<ul>
<li>direct(默认):通过指定路由键点对点方式与队列绑定</li>
<li>fanout:广播模式,将消息发送到所有队列</li>
<li>topic:允许对路由键制定模糊匹配,单词之间用点隔开,#匹配0个或多个单词,*匹配一个单词</li>
<li>headers 和默认基本一致,且性能不佳</li>
</ul>
</li>
<li><p><strong>Queue</strong></p>
<p>消息队列,用来保存消息直到发送给消费者;它是消息的容器,也是消息的终点;一个消息可投入一个或多个队列;消息一直在队列里面,等待消费者连接到这个队列将其取走.</p>
</li>
<li><p><strong>Binding</strong></p>
<p>绑定,用于消息队列和交换器之间的关联;一个绑定器就是基于路由键将交换器和消息队列连接起来的路由规则,所以可以将交换器理解成一个由绑定构成的路由表.Exchange和Queue的绑定可以是多对多的关系.</p>
</li>
<li><p><strong>Connection</strong></p>
<p>网络连接,比如一个TCP连接.</p>
</li>
<li><p><strong>Channel</strong></p>
<p>信道,多路复用连接中的一条独立的双向数据流通道;信道是建立在真实的TCP连接内的虚拟连接,AMQP命令都是通过信道发送出去的,不管是发布消息,订阅队列还是接收消息,这些动作由是通过信道完成;因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销,所以引入了信道的概念,以复用一条TCP连接.</p>
</li>
<li><p><strong>Consumer</strong></p>
<p>消息的消费者,表示一个从消息队列中取得消息的客户端应用程序.</p>
</li>
<li><p><strong>Virtual Host</strong></p>
<p>虚拟主机,表示一批交换器,消息队列和相关对象;虚拟主机是共享相同的身份认证和加密环境的独立服务器域;每个vhost本质上就是一个mini版的RabbitMQ服务器,拥有自己的队列,交换器,绑定和权限机制;vhost是AMQP概念的基础,必须在连接时指定,RabbitMQ默认的vhost是<code>/</code>.</p>
</li>
<li><p><strong>Broker</strong></p>
<p>表示消息队列服务器实体</p>
<p><img src="https://i.loli.net/2020/05/16/4Kc9AqTyrR28wlM.png" alt="broker 2020-03-27 131401"></p>
</li>
</ul>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>rabbitmq和erlang版本对照:<a href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p><strong>windows</strong></p>
<ul>
<li><p><strong>下载erlang</strong>:<a href="http://erlang.org/download/otp_win64__21.3.exe">http://erlang.org/download/otp_win64__21.3.exe</a></p>
</li>
<li><p><strong>下载rbbitmq</strong>:<a href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></p>
</li>
<li><p>在rabbitmq/sbin目录下执行<code>  set ERLANG_HOME=erlang的安装路径</code><strong>设置erlang环境变量</strong></p>
</li>
<li><p><strong>并输入以下命令启动管理功能</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用rabbitmq Service -start.exe程序启动</strong></p>
</li>
<li><p>访问:<a href="http://localhost:15672/">http://localhost:15672/</a> 账号密码:guest guest</p>
</li>
</ul>
<p><strong>Linux</strong></p>
<ul>
<li><p>准备：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载&amp;安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line">wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line">wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先安装erlang</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">socat密钥</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm </span><br><span class="line"><span class="meta">#</span><span class="bash">然后rabbitmq-server</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm </span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app</span><br><span class="line">比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,删除尖括号和引号只保留[guest]</span><br></pre></td></tr></table></figure>

<p>env下可修改端口号等环境变量:</p>
<p><img src="https://i.loli.net/2020/07/02/FdftApo9y8eu3ms.png" alt="image-20200702120334702"></p>
</li>
<li><p>服务启动和停止：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">启动 rabbitmq-server start &amp;</span><br><span class="line">停止 rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>启用管理插件：<code>rabbitmq-plugins enable rabbitmq_management</code><br>访问地址：<a href="http://192.168.107.132:15672/">http://192.168.107.132:15672/</a></p>
<p>如果启动失败可查看端口占用情况: <code>lsof -i:5672</code></p>
<h2 id="命令行与管控台操作"><a href="#命令行与管控台操作" class="headerlink" title="命令行与管控台操作"></a>命令行与管控台操作</h2><ul>
<li><p>服务启动: <code>rabbitmqctl start_app</code></p>
</li>
<li><p>服务停止: <code>rabbitmqctl stop_app</code></p>
</li>
<li><p>节点状态: <code>rabbitmqctl status</code></p>
</li>
<li><p>创建虚拟主机: <code>rabbitmqctl add_vhost &lt; vhostpath &gt;</code></p>
</li>
<li><p>查看所有虚拟主机:<code> rabbitmqctl list_vhosts</code></p>
</li>
<li><p>查看所有队列: <code>rabbitmqctl list_queues</code></p>
</li>
<li><p>清除队列里的消息: <code>rabbitmqctl -p vhostpath purge_queue blue</code></p>
</li>
<li><p>移除所有数据: <code>rabbitmqctl reset</code> (要在服务停止之后使用)</p>
</li>
<li><p>组成集群命令: <code>rabbitmqctl join_cluster &lt; clusternode&gt; [--ram]</code>存储模式</p>
</li>
<li><p>修改集群节点的存储模式: <code>rabbitmqctl change_cluster_node_type disc | ram</code></p>
</li>
<li><p>摘除节点:<code>rabbitmqctl forget_cluster_node [--offline]</code></p>
</li>
</ul>
<p>管控台可以管理监控 连接(Connections),信道(Channels),交换器(Exchanges),队列(Queues) ;</p>
<p>Admin中可监控和添加虚拟主机(Virtual Host)</p>
<h2 id="与springboot整合"><a href="#与springboot整合" class="headerlink" title="与springboot整合"></a>与springboot整合</h2><p>创建springboot项目选择依赖web,rabbitMQ</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-starter-amqp</code>引入了<code>spring-messaging</code>, <code>spring-rabbit</code></p>
<p>自动配置类:<code>RabbitAutoConfiguration</code></p>
<p>配置了<code>rabbitConnectionFactory</code>连接工厂</p>
<p><code>RabbitPtoperties</code>封装了RabbitMQ的配置</p>
<p><code>RabbitTemplate</code>用来发送和接受消息</p>
<p><code>AmqpAdmin</code>RabbitMQ系统管理功能组件</p>
<p><strong>相关配置</strong>:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">#rabbit主机地址</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.107.108</span></span><br><span class="line"><span class="comment">#用户名 密码 端口</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment">#虚拟主机地址</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="comment"># 支持发布确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 支持发布返回</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 虚拟主机名称</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="comment"># 采用手动应答</span></span><br><span class="line"><span class="comment"># spring.rabbitmq.listener.acknowledge-mode=manual</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mq-api</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.107</span><span class="number">.132</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">      <span class="attr">listener:</span></span><br><span class="line">        <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动ack</span></span><br></pre></td></tr></table></figure>

<p>在测试类中注入<code>RabbitTemplate</code>,有<strong>两种发送消息的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Message需要自己构造,可定制消息体内容和消息头</span></span><br><span class="line">rabbitTemplate.send(exchange,routeKey,message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//object默认作为消息体,只需要传入要发送的对象,自动序列化发送给rabbitmq</span></span><br><span class="line">rabbitTemplate.convertAndSend(exchange,routeKey,object);</span><br></pre></td></tr></table></figure>

<p>使用<code>AmqpAdmin</code>组件可以编码的方式创建和管理<strong>Queue,Bindings以及Exchange</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * declareXXX()用来创建组件</span></span><br><span class="line"><span class="comment">     * removeXXX(),deleteXXX()用来删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//传入对应类型的实现类</span></span><br><span class="line">        amqpAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;amqpadmin.exchange&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;创建完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//名字 是否持久化</span></span><br><span class="line">        amqpAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;amqpadmin.queue&quot;</span>,<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建绑定规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBindings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//绑定目的地 目的地类型 Exchange Routing key 参数</span></span><br><span class="line">        amqpAdmin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">&quot;amqpadmin.queue&quot;</span>, 	                                       Binding.DestinationType.QUEUE,</span><br><span class="line">                  <span class="string">&quot;amqpadmin.exchange&quot;</span>,<span class="string">&quot;amqp.haha&quot;</span>,<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exchange接口的实现类</strong>:</p>
<p><img src="D:\study\Markdown\images\FHCNqzekvLl8jBX.png" alt="image-20200514172523355"></p>
<p><strong>例子</strong>:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 点对点方式 发送</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是第一个消息&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;data&quot;</span>, Arrays.asList(<span class="string">&quot;helloWorld&quot;</span>,<span class="number">123</span>,<span class="keyword">true</span>));</span><br><span class="line">       <span class="comment">//对象被默认序列化后发送出去</span></span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.direct&quot;</span>,<span class="string">&quot;user.news&quot;</span>,map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Object o = rabbitTemplate.receiveAndConvert(<span class="string">&quot;user.news&quot;</span>);</span><br><span class="line">       System.out.println(o.getClass());</span><br><span class="line">       System.out.println(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 广播</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.fanout&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JSON序列化</strong>:</p>
<p><code>RabbitTemplate</code>中的<code>MessageConverter</code>的实现默认为<code>SimpleMessageConverter</code>也就是jdk序列化的方式</p>
<p>将<code>MessageConverter</code>的实现改成<code>Jackson2JsonMessageConverter</code>,数据就会以JSON的格式发送了</p>
<p>==注意实现Serializable接口==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAMQPConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter(objectMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RabbitListener</code><strong>监听队列自动接收消息</strong></p>
<p>在<strong>启动类</strong>加上<code>@EnableRabbit</code>注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 监听指定的队列,多个用逗号分隔</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;user.news&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span>+book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * message对象可获得消息头和消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive02</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(message.getBody());</span><br><span class="line">        System.out.println(message.getMessageProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建生产者-amp-消费者"><a href="#构建生产者-amp-消费者" class="headerlink" title="构建生产者&amp;消费者"></a>构建生产者&amp;消费者</h2><h3 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h3><ul>
<li><p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;test001&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//设置channel 队列名称, autoAck, consumer</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="comment">//在Broker接收到该Consumer的ack前,</span></span><br><span class="line">        <span class="comment">//Consumer在同一个时间点最多被分配qos个Message</span></span><br><span class="line">        channel.basicQos(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拓展DefaultConsumer</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(channel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理消息的逻辑</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动消费者后查看管控台,发现connection,channel已成功连接,队列已成功创建</p>
</li>
<li><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line">        <span class="comment">//使用默认exchange 发布消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// exchange, routeKey, properties, message</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test001&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>测试</strong></p>
<ul>
<li>启动消费者后运行生产者,收到消息</li>
<li>运行生产者后消息未被消费,再启动消费者后收到消息</li>
</ul>
</li>
<li><p><strong>tip: QueueingConsumer已被废弃</strong></p>
<p>QueueingConsumer内部用LinkedBlockingQueue来存放消息的内容，而LinkedBlockingQueue：一个由链表结构组成的有界队列，照先进先出的顺序进行排序 ，未指定长度的话，默认 此队列的长度为Integer.MAX_VALUE，那么问题来了，如果生产者的速度远远大于消费者的速度，也许没等到队列阻塞的条件产生（长度达到Integer.MAX_VALUE）内存就完蛋了，在老的版本你可以通过设置 rabbitmq的prefetch属性channel.basicQos(prefetch)来处理这个问题如果不设置可能出现内存问题（比如因为网络问题只能向rabbitmq生产不能消费，消费者恢复网络之后就会有大量的数据涌入，出现内存问题,oom fgc等）。</p>
<p>而且写法很不合理不符合事件驱动，什么时候停止while循环也不能写的很优雅，所以在更高的版本直接被移除。取而代之的是DefaultConsumer，你可以通过扩展DefaultConsumer来实现消费者</p>
</li>
</ul>
<h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring-boot"></a><em>spring-boot</em></h3><ul>
<li><p><strong>消费者</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mq-api</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.107</span><span class="number">.132</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">      <span class="attr">listener:</span></span><br><span class="line">        <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动ack</span></span><br><span class="line">          <span class="attr">concurrency:</span> <span class="number">5</span> <span class="comment">#消费者的最小数量</span></span><br><span class="line">          <span class="attr">max-concurrency:</span> <span class="number">10</span> <span class="comment">#消费者的最大数量</span></span><br></pre></td></tr></table></figure>

<p>消费者核心注解: <code>@RabbitListener</code>, <code>@RabbitHandler</code></p>
<p>@RabbitListener是一个组合注解, 与@QueueBinding, @Queue, @Exchange 组合使用, 一次性搞定消费端交换机, 队列, 绑定, 路由, 并且配置监听功能等, ==配置信息建议从配置文件动态加载==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;queue_1&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;exchange_1&quot;,</span></span><br><span class="line"><span class="meta">                durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                type = &quot;topic&quot;,</span></span><br><span class="line"><span class="meta">                ignoreDeclarationExceptions = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;springboot.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费端: &quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    Long deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">//手动ack</span></span><br><span class="line">    channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用</p>
<p>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;consumer_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Payload</code>和<code>@Headers</code>注解用来指定消息体, 和接受消息头参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(<span class="meta">@Payload</span> OrderMessage orderMessage, Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="meta">@Headers</span> Map&lt;String, Object&gt; Headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费端: &quot;</span> + orderMessage.getContent());</span><br><span class="line">    Long deliveryTag = (Long) Headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">    <span class="comment">//手动ack</span></span><br><span class="line">    channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生产者</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line"><span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RabbitTemplate.ConfirmCallback confirmCallback = <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步监听 消息是否到达 exchange</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 包含消息的唯一标识的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack             true 标识 ack，false 标识 nack</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause           nack 的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----confirmCallback-----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData: &quot;</span> + correlationData);</span><br><span class="line">            System.out.println(<span class="string">&quot;ack: &quot;</span> + ack);</span><br><span class="line">            System.out.println(<span class="string">&quot;cause: &quot;</span> + cause);</span><br><span class="line">            <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">                <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递成功</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//log.error(&quot;消息投递失败,ID为: &#123;&#125;,错误信息: &#123;&#125;&quot;, correlationData.getId(), cause);</span></span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RabbitTemplate.ReturnCallback returnCallback = <span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步监听 消息是否到达 queue</span></span><br><span class="line"><span class="comment">         * 触发回调要满足的条件有两个：</span></span><br><span class="line"><span class="comment">         * 1.消息已经到达了 exchange </span></span><br><span class="line"><span class="comment">         * 2.消息无法到达 queue (比如 exchange 找不到跟 routingKey 对应的 queue)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message    返回的消息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyCode  回复 code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyText  回复 text</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(org.springframework.amqp.core.Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----returnCallback-----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + message);</span><br><span class="line">            System.out.println(<span class="string">&quot;replyCode: &quot;</span> + replyCode + <span class="string">&quot;, replyText: &quot;</span> + replyText);</span><br><span class="line">            System.out.println(<span class="string">&quot;exchange: &quot;</span> + exchange + <span class="string">&quot;, routingKey: &quot;</span> + routingKey);</span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//消息头</span></span><br><span class="line">        MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        properties.getHeaders().put(<span class="string">&quot;send_time&quot;</span>, LocalDateTime.now());</span><br><span class="line">        properties.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        <span class="comment">//构建消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(msg.getBytes(), properties);</span><br><span class="line">        <span class="comment">//指定confirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">        <span class="comment">//指定returnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">        <span class="comment">//指定唯一id</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(OrderMessage orderMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//指定confirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">        <span class="comment">//指定returnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">        <span class="comment">//id + 时间戳</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;exchange_2&quot;</span>, <span class="string">&quot;springboot.def&quot;</span>, orderMessage, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h2><p>用来接收生产者发送的消息,并将这些消息路由给服务器中的队列;</p>
<p><strong>Exchange有4种类型</strong>,不同类型的Exchange转发消息的策略有所区别:</p>
<ul>
<li>direct(默认): 通过指定路由键点对点方式与队列绑定</li>
<li>fanout: 广播模式,将消息发送到所有队列</li>
<li>topic: 允许对路由键制定模糊匹配,单词之间用点隔开,#匹配0个或多个单词,*匹配一个单词</li>
<li>headers: 和默认基本一致,且性能不佳</li>
</ul>
<p><strong>交换机属性</strong></p>
<ul>
<li>Name: 交换机名称</li>
<li>Durability: 是否持久化</li>
<li>AutoDelete: 当最后一个绑定到Exchange上的队列被删除后,自动删除该Exchange</li>
<li>Internal: 当前Exchange是否用于RabbitMQ内部使用,默认false</li>
<li>Arguments: 拓展参数, 用于拓展AMQP协议自定制化使用</li>
</ul>
<p><strong>测试三种类型的交换器</strong></p>
<ol>
<li><p>点击管控台的<strong>Add a new exchange</strong>创建交换机</p>
<p>Durability:是否持久化选择Durable</p>
<p><code>exchange.direct</code>交换器,Type为direct</p>
<p><code>exchange.fanout</code>交换器,Type为fanout</p>
<p><code>exchange.topic</code>交换器,Type为topic</p>
</li>
<li><p><strong>Add a new queue</strong>添加消息队列</p>
<p>user  user.news  user.orders  edc.news</p>
</li>
<li><p>给队列<strong>绑定交换器</strong></p>
<p>exchange.direct/<strong>Bindings **选择 **To Queue</strong>,使用Routing key同名字分别绑定,点击Unbind可解绑,fanout与之同理</p>
<p>topic用通配符绑定</p>
<table>
<thead>
<tr>
<th>*.news</th>
<th>user.#</th>
</tr>
</thead>
<tbody><tr>
<td>user.news</td>
<td>user</td>
</tr>
<tr>
<td>edc.news</td>
<td>user.news</td>
</tr>
<tr>
<td></td>
<td>user.orders</td>
</tr>
</tbody></table>
</li>
<li><p>接着分别在三个Exchange发送消息测试</p>
<p>Exchanges中点击<strong>Publish message</strong> ,输入Routing key发送消息,如:direct.exchange.msg.helloWorld</p>
<p>在Queues中点击对应的queue,点击<strong>Get Message</strong>获取消息,Ack Mode选择Ack message requeue false会清除上一次的消息</p>
</li>
</ol>
<p><strong>结果:</strong></p>
<ul>
<li><p>direct通过指定路由键点对点方式与队列绑定,所以只有完全匹配Routing key的队列才会收到消息.</p>
</li>
<li><p>fanout会将消息广播发送到所有队列</p>
</li>
<li><p>topic会有选择的模糊匹配Routing key对应的队列</p>
</li>
</ul>
<h2 id="Message自定义消息属性"><a href="#Message自定义消息属性" class="headerlink" title="Message自定义消息属性"></a>Message自定义消息属性</h2><ol>
<li><p><strong>构建BasicProperties</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义headers属性</span></span><br><span class="line">        HashMap&lt;String, Object&gt; attr = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        attr.put(<span class="string">&quot;status&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        attr.put(<span class="string">&quot;detail&quot;</span>, <span class="string">&quot;这是附加属性&quot;</span>);</span><br><span class="line">        <span class="comment">//构建消息属性</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>) <span class="comment">//1:不持久化消息, 2:持久化消息</span></span><br><span class="line">                .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>) <span class="comment">//字符集</span></span><br><span class="line">                .expiration(<span class="string">&quot;10000&quot;</span>) <span class="comment">//过期时间</span></span><br><span class="line">                .headers(attr) <span class="comment">//自定义属性</span></span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发布时指定properties</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String msg = <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line"><span class="comment">//使用默认exchange 发布消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// exchange, routeKey, properties, message</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test001&quot;</span>, properties, msg.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取properties</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//处理消息的逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">    System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">    System.out.println(properties.getHeaders().get(<span class="string">&quot;detail&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="AMQP事务"><a href="#AMQP事务" class="headerlink" title="AMQP事务"></a>AMQP事务</h2><p>我们知道可以通过持久化（交换机、队列和消息持久化）来保障我们在服务器崩溃时，重启服务器消息数据不会丢失。</p>
<p>但是我们无法确认当消息的发布者在将消息发送出去之后，消息到底有没有正确到达Broker代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达Broker的。如果在消息到达Broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，这个是没有办法进行持久化的，那么当我们遇到这个问题又该如何去解决呢？</p>
<p>RabbitMQ中的消息确认机制，通过消息确认机制我们可以确保我们的消息可靠送达到我们的用户手中，即使消息丢失掉，我们也可以通过进行重复分发确保用户可靠收到消息。</p>
<p><strong>RabbitMQ提供了两种消息确认方式：</strong></p>
<ul>
<li>通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案；</li>
<li>通过将channel设置成confirm模式来实现；</li>
</ul>
<p><strong>RabbitMQ中与事务有关的主要有三个方法：</strong></p>
<ul>
<li>txSelect() : 主要用于将当前channel设置成transaction模式</li>
<li>txCommit() : 用于提交事务</li>
<li>txRollback() : txRollback用于回滚事务</li>
</ul>
<p>当我们使用txSelect提交开始事务之后，我们就可以发布消息给Broke代理服务器，如果txCommit提交成功了，则消息一定到达了Broke了，如果在txCommit执行之前Broker出现异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback方法进行回滚事务了。</p>
<p>所以RabbitMQ事务中的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    channel.txSelect();</span><br><span class="line">    <span class="comment">// 往队列中发出一条消息，使用rabbitmq默认交换机</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// 事务回滚</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭频道和连接</span></span><br><span class="line">	channel.close();</span><br><span class="line">	connection.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行事务提交，然后开始发送消息，最后提交事务。</p>
<p>在使用事务时，在application.properties中，需要将确认模式更改为false。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支持发布确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h2 id="消息可靠性投递"><a href="#消息可靠性投递" class="headerlink" title="消息可靠性投递"></a>消息可靠性投递</h2><ul>
<li>保障消息成功发出</li>
<li>保障MQ节点的成功接收</li>
<li>发送端收到MQ节点Broker确认答应</li>
<li>完善的消息补偿机制</li>
</ul>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a><strong>解决方案一</strong></h3><p><img src="https://i.loli.net/2020/07/03/cd2OwDpFlTIHCUj.png" alt="image-20200703124116225"></p>
<p><strong>消息落库, 对消息状态进行打标</strong></p>
<ol>
<li>生产者首先将自己的业务数据落库(如订单),然后将生成的消息落库,发送状态为<strong>待发送</strong>(status:0), 如果持久化失败,将进行快速失败</li>
<li>发送消息到MQ Broker</li>
<li>异步监听Broker收到消息后返回的确认答应</li>
<li>更新数据库信息状态为<strong>已发送</strong>(status:1)</li>
<li>如果超过最大发送时限仍然没有收到Borker的答应,使用分布式定时任务获取所有状态为待发送的信息记录<ul>
<li>分布式任务重复获取的问题,需要保证同一时间只有一个定时任务在获取消息记录</li>
<li>可能消息刚刚入库就被获取,造成不必要的重发,需要设置消息超时的最大容忍限制</li>
</ul>
</li>
<li>尝试重新发送</li>
<li>超过最大重试次数仍然没有答应,消息状态更新为坏消息(status:2),需要人工干预</li>
</ol>
<p><strong>缺点</strong>: 数据库操作频繁,高并发场景不适合</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a><strong>解决方案二</strong></h3><p><strong>消息的延迟投递, 做二次确认, 回调检查</strong></p>
<ul>
<li>Upstream: 上游服务,消息生产者</li>
<li>Downstream: 下游服务,消息消费者</li>
<li>MQ Broker: MQ集群</li>
<li>Callback: 回调服务</li>
</ul>
<p><img src="https://i.loli.net/2020/07/03/KPQEMhxgL6qe5m1.png" alt="image-20200703131009257"></p>
<ol>
<li>上游服务将自己的业务数据持久化之后,进行第一次消息投递</li>
<li>延迟消息投递检查, 在第一次消息发送后几分钟进行第二次投递,对应check队列,被Callback服务监听</li>
<li>下游服务监听消息并处理消息</li>
<li>如果消息被成功处理,发送确认信息到confirm队列,被Callback服务监听</li>
<li>Callback监听到confirm队列中消息被正确处理的答应,将消息记录入库</li>
<li>如果下游服务没有返回答应消息,MSG DB中就没有该消息的记录,此时check队列中延迟消息到达,检查DB中是否存在此条消息记录,也就是验证该消息是否在之前被正确处理,如果没有Callback服务将发送RPC通知上游服务,将该消息对应的业务数据进行重新一轮发送</li>
</ol>
<p><strong>优点</strong>: 减少了数据库操作,补偿服务和主业务解耦</p>
<h2 id="消费端-冥等性保障"><a href="#消费端-冥等性保障" class="headerlink" title="消费端-冥等性保障"></a>消费端-冥等性保障</h2><p><strong>冥等性</strong></p>
<p>任意多次执行操作对资源本身所产生的影响均与一次执行的影响相同</p>
<p><strong>解决的问题:</strong></p>
<p>在高并发情况下,难免会发送消息的重复投递</p>
<p><strong>在海量订单产生的业务高峰期,如何避免消息的重复消费问题?</strong></p>
<p><strong>消费端实现冥等性,就意味着,我们的消息永远不会被消费多次,即使我们收到了多条一样的消息</strong></p>
<h3 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>唯一ID + 指纹码机制, 利用数据库主键去重</strong></p>
<ul>
<li>生成全局唯一ID + 指纹码(可能是某种业务规则,或第三方提供的唯一标识),利用数据库主键唯一性去重</li>
<li><code>SELETE COUNT(1) FROM T_ORDER WHERE ID = 唯一ID + 指纹码</code>,查到数据库没有此条记录,再进行Insert并消费,否则说明此条记录已经被操作了,丢弃</li>
</ul>
<p><strong>优点</strong>: 实现简单</p>
<p><strong>缺点</strong>: 高并发下存在数据库写入的性能瓶颈</p>
<p><strong>解决方案</strong>: 根据ID进行分库分表进行路由算法分摊压力 </p>
<h3 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>利用Redis的原子性实现冥等</p>
<p><strong>需要考虑的问题:</strong></p>
<ul>
<li>我们是否要进行数据落库, 如果落库的话, 关键解决的问题是数据库和缓存如何做到原子性?</li>
<li>如果不进行落库,那么都存储到缓存中, 如何设置定时同步的策略?</li>
</ul>
<h2 id="confirm消息确认机制"><a href="#confirm消息确认机制" class="headerlink" title="confirm消息确认机制"></a>confirm消息确认机制</h2><p>消息的确认,是指生产者投递消息后, 如果Broker收到消息,则会给生产者一个答应</p>
<p>生产者进行接收答应,用来确定这条消息是否正常的发送到Broker,这种方式也是消息可靠性投递的核心保障</p>
<p><img src="https://i.loli.net/2020/07/01/9kqbnH6uVGvh1jE.png" alt="Producer-Confirm"></p>
<blockquote>
<p>默认情况下rabbitmq的消费者采用平均分配的方式消费队列中的消息,而且默认开启autoAck自动答应机制,消费者在接受到消息后就会向rabbitmq发送消息已被消费的信号,此时消息将被删除,如果消费者消费到一半的时候宕机,便导致了业务无法正常完成;</p>
<p>为了保证消息不会丢失,如果一个消费者宕机,我们希望将未被处理的消息交给另一个消费者</p>
</blockquote>
<p><strong>实现原理：</strong></p>
<p>==生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个<strong>唯一的ID</strong>(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了==，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中<strong>delivery-tag</strong>域包含了确认消息的序列号，此外broker也可以设置basic.ack的<strong>multiple</strong>域，表示到这个序列号之前的所有消息都已经得到了处理；</p>
<p>confirm模式最大的好处在于他是<strong>异步</strong>的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条<strong>nack</strong>消息，生产者应用程序同样可以在回调方法中处理该nack消息；</p>
<p><strong>开启confirm模式的方法：</strong></p>
<ul>
<li>在channel上开启确认模式: <code>channel.confirmSelect()</code></li>
<li>在channel上添加监听: <code>addConfirmListener</code>, 监听成功和失败的返回结果,根据具体的结果对消息进行重新发送,或记录日志等后续处理</li>
</ul>
<p>生产者通过调用channel的<code>confirmSelect</code>方法将channel设置为confirm模式，(注意一点，已经在transaction事务模式的channel是不能再设置成confirm模式的，即这两种模式是不能共存的)，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的，而且我也没找到我们自己能够设置no-wait标志的方法)；</p>
<p>注意：<strong>发布确认和事务。(两者不可同时使用)在channel为事务时，不可引入确认模式；同样channel为确认模式下，不可使用事务</strong></p>
<h3 id="原生API-1"><a href="#原生API-1" class="headerlink" title="原生API"></a>原生API</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消费端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.confirm.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;confirm.#&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange和队列</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定exchange和队列</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//设置channel 队列名称, autoAck, consumer</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费端: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.confirm.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;confirm.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ Send confirm message!&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----添加确认监听----</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 成功答应</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> deliveryTag 消息唯一标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> multiple 是否批量</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----------------ack!--------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否认答应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;----------------no ack--------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="spring-boot-1"><a href="#spring-boot-1" class="headerlink" title="spring-boot"></a><em>spring-boot</em></h3><p><strong>配置:</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line">  <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">    <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p><strong>消息实体:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单的消息实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务id，在业务系统中的唯一。比如 订单id、支付id、商品id ，消息消费端可以通过该 id 避免消息重复消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他业务字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送消息并异步监听:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息并异步监听 ack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMessageSendAsync</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(OrderMessageSendAsync.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造函数注入 RabbitTemplate 依赖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderMessageSendAsync</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="comment">// 设置消息到达 exchange 时，要回调的方法，每个 RabbitTemplate 只支持一个 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 设置消息无法到达 queue 时，要回调的方法</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String exchange, String routingKey, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造包含消息的唯一id的对象，id 必须在该 channel 中始终唯一</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        logger.info(<span class="string">&quot;ID为: &#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        <span class="comment">// todo 先将业务数据入库，在将 message 的数据库ID 、message的消息id message的初始状态(发送中)等信息入库</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成 数据落库，消息状态打标后，就可以安心发送 message</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message, correlationData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;发送消息的线程处于休眠状态， confirm 和 returnedMessage 方法依然处于异步监听状态&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听 消息是否到达 exchange</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 包含消息的唯一标识的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             true 标识 ack，false 标识 nack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           nack 的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;消息投递成功,ID为: &#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递成功</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;消息投递失败,ID为: &#123;&#125;,错误信息: &#123;&#125;&quot;</span>, correlationData.getId(), cause);</span><br><span class="line">        <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听 消息是否到达 queue</span></span><br><span class="line"><span class="comment">     * 触发回调要满足的条件有两个：1.消息已经到达了 exchange 2.消息无法到达 queue (比如 exchange 找不到跟 routingKey 对应的 queue)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    返回的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode  回复 code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText  回复 text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// correlationId 就是发消息时设置的 id</span></span><br><span class="line">        String correlationId = message.getMessageProperties().getHeaders().get(<span class="string">&quot;spring_returned_message_correlation&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;没有找到对应队列，消息投递失败,ID为: &#123;&#125;, replyCode &#123;&#125; , replyText &#123;&#125;, exchange &#123;&#125; routingKey &#123;&#125;&quot;</span>,</span><br><span class="line">                correlationId, replyCode, replyText, exchange, routingKey);</span><br><span class="line">        <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.wqlm.rabbitmq.send.MessageSend.OrderMessageSendAsync;</span><br><span class="line"><span class="keyword">import</span> com.wqlm.rabbitmq.send.message.OrderMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMessageSendAsync orderMessageSendAsync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试发送消息并异步接收响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        OrderMessage orderMessage = <span class="keyword">new</span> OrderMessage(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;订单123&quot;</span>);</span><br><span class="line">        <span class="comment">// 序列化成json ，OrderMessage 也可以 implements Serializable 这样就不需要序列化成json</span></span><br><span class="line">        String message = JSONObject.toJSONString(orderMessage);</span><br><span class="line">        orderMessageSendAsync.sendMsg(<span class="string">&quot;exchangeName&quot;</span>, <span class="string">&quot;routingKeyValue&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="springAMQP"><a href="#springAMQP" class="headerlink" title="springAMQP"></a>springAMQP</h2><h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a><em>SimpleMessageListenerContainer</em></h3><p><strong>简单消息监听容器:</strong> 我们使用SimpleMessageListenerContainer容器设置消费队列监听，然后设置具体的监听Listener进行消息消费具体逻辑的编写</p>
<ul>
<li>SimpleMessageListenerContainer可监听多个队列</li>
<li>设置事务特性, 事务管理器, 事务属性, 事务容量, 回滚消息等</li>
<li>设置消费者数量, 最小最大数量, 批量消费</li>
<li>设置消息签收模式 NONE, AUTO, MANUAL</li>
<li>是否重回队列, 异常捕获handler函数</li>
<li>设置消费则标签生成策略, 是否独占模式, 消费者属性等</li>
<li>设置具体监听器, 转换器</li>
</ul>
<p>注意: SimpleMessageListenerContainer可以在运行中动态的改变其消费者数量的大小, 接收消息的模式等; 很多基于RabbitMQ的自定制后台管理在进行动态设置的时候, 也是根据SpringAMQP这一特性取实现的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.ack&quot;</span>, <span class="string">&quot;test.order.queue&quot;</span>); <span class="comment">//监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); //监听的队列, 注入方式</span></span><br><span class="line">    container.setConcurrentConsumers(<span class="number">1</span>); <span class="comment">//当前的消费者数量</span></span><br><span class="line">    container.setMaxConcurrentConsumers(<span class="number">5</span>); <span class="comment">//最大消费者数量</span></span><br><span class="line">    container.setDefaultRequeueRejected(<span class="keyword">false</span>); <span class="comment">//默认不重回队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">//手动ack模式</span></span><br><span class="line">    <span class="comment">//container.setAfterReceivePostProcessors(MessagePostProcessor); 在接收到消息之前做什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费端标签生成策略 (可lambda)</span></span><br><span class="line">    container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue + <span class="string">&quot;_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息监听处理</span></span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt;&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===监听到消息===&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.getMessageProperties().getHeaders().get(<span class="string">&quot;err&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===消息已确认===&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===拒绝消息===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MessageListenerAdapter"><a href="#MessageListenerAdapter" class="headerlink" title="MessageListenerAdapter"></a><em>MessageListenerAdapter</em></h3><p><strong>消息监听适配器:</strong> 允许你自定义MessageListener, 通过MessageListenerAdapter来适配</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.ack&quot;</span>, <span class="string">&quot;test.order.queue&quot;</span>); <span class="comment">//监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); //监听的队列, 注入方式</span></span><br><span class="line">    container.setConcurrentConsumers(<span class="number">1</span>); <span class="comment">//当前的消费者数量</span></span><br><span class="line">    container.setMaxConcurrentConsumers(<span class="number">5</span>); <span class="comment">//最大消费者数量</span></span><br><span class="line">    container.setDefaultRequeueRejected(<span class="keyword">false</span>); <span class="comment">//默认不重回队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">//手动ack模式</span></span><br><span class="line">    <span class="comment">//container.setAfterReceivePostProcessors(MessagePostProcessor); 在接收到消息之前做什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费端标签生成策略 (可lambda)</span></span><br><span class="line">    container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue + <span class="string">&quot;_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配自定义消息监听处理</span></span><br><span class="line">    MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageDelegate());</span><br><span class="line">    adapter.setDefaultListenerMethod(<span class="string">&quot;consumeMessage&quot;</span>); <span class="comment">//改变默认方法</span></span><br><span class="line">    adapter.setMessageConverter(<span class="keyword">new</span> TextMessageConverter()); <span class="comment">//消息转换器</span></span><br><span class="line">    <span class="comment">//设置消息监听器</span></span><br><span class="line">    container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义消息监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String messageBody)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法, 消息内容: &quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(<span class="keyword">byte</span>[] messageBody)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字节数组方法, 消息内容: &quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==自定义消息监听器的处理方法名称, 定义在MessageListenerAdapter中==:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractAdaptableMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; queueOrTagToMethodName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORIGINAL_DEFAULT_LISTENER_METHOD = <span class="string">&quot;handleMessage&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    <span class="keyword">private</span> String defaultListenerMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageListenerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queueOrTagToMethodName = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.defaultListenerMethod = <span class="string">&quot;handleMessage&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.delegate = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);</code>==修改负责消息监听处理的方法, 以适配不同的消息处理方式==</p>
<hr>
<p><strong>consumeMessage的入参是byte[]类型, 假设我们发送的消息是String类型就会抛出异常, 可使用自定义MessageConvert来转换类型</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextMessageConverter</span> <span class="keyword">implements</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 转 Message</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">toMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message(object.toString().getBytes(), messageProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Message 转 Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">        String contentType = message.getMessageProperties().getContentType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != contentType &amp;&amp; contentType.contains(<span class="string">&quot;text&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>adapter.setMessageConverter(new TextMessageConverter());</code>==指定消息转换器, 并在发送消息时指定ContentType;==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//消息头</span></span><br><span class="line">MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">properties.getHeaders().put(<span class="string">&quot;send_time&quot;</span>, LocalDateTime.now());</span><br><span class="line">properties.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>可以设置多个队列通过队列名或Tag与不同方法的映射绑定</strong></p>
<p><em>queueOrTagToMethodName</em>: 队列标识与方法名称组成的集合</p>
<p>==即指定队列里的消息会被所绑定的方法所接收处理==</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageDelegate());</span><br><span class="line">HashMap&lt;String, String&gt; queueOrTagToMethodName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">queueOrTagToMethodName.put(<span class="string">&quot;order.queue&quot;</span>, <span class="string">&quot;handleOrder&quot;</span>);</span><br><span class="line">queueOrTagToMethodName.put(<span class="string">&quot;product&quot;</span>, <span class="string">&quot;handleProduct&quot;</span>);</span><br><span class="line"><span class="comment">//设置队列与监听处理方法的映射绑定</span></span><br><span class="line">adapter.setQueueOrTagToMethodName(queueOrTagToMethodName); </span><br><span class="line">container.setMessageListener(adapter);</span><br></pre></td></tr></table></figure>

<h2 id="消息监听器处理Ack"><a href="#消息监听器处理Ack" class="headerlink" title="消息监听器处理Ack"></a>消息监听器处理Ack</h2><ul>
<li>消息<strong>通过 ACK 确认是否被正确接收</strong>，每个 Message 都要被确认（acknowledged），可以手动去 ACK 或自动 ACK</li>
<li>自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息</li>
<li>如果消息已经被处理，但后续代码抛出异常，使用 Spring 进行管理的话消费端业务逻辑会进行回滚，这也同样造成了实际意义的消息丢失</li>
<li>如果手动确认则当消费者调用 ack、nack、reject 几种方法进行确认，手动确认可以在业务失败后进行一些操作，如果消息未被 ACK 则会发送到下一个消费者</li>
<li><strong>如果某个服务没有 ACK ，则 RabbitMQ 不会再发送数据给它，因为 RabbitMQ 认为该服务的处理能力有限</strong></li>
<li>ACK 机制还可以起到限流作用，比如在接收到某条消息时休眠几秒钟</li>
<li>消息确认模式有：<ul>
<li>AcknowledgeMode.NONE：自动确认</li>
<li>AcknowledgeMode.AUTO：根据情况确认</li>
<li>AcknowledgeMode.MANUAL：手动确认</li>
</ul>
</li>
</ul>
<h3 id="确认消息（局部方法处理消息）"><a href="#确认消息（局部方法处理消息）" class="headerlink" title="确认消息（局部方法处理消息）"></a>确认消息（局部方法处理消息）</h3><ul>
<li><p>默认情况下消息消费者是自动 ack （确认）消息的，如果要手动 ack（确认）则需要修改确认模式为 manual</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或在 RabbitListenerContainerFactory 中进行开启手动 ack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory)&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);             <span class="comment">//开启手动 ack</span></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认消息 @RabbitHandler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(String message,Channel channel,<span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag,<span class="keyword">false</span>); <span class="comment">// 确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的 basicAck 方法需要传递两个参数</p>
<ul>
<li><strong>deliveryTag（唯一标识 ID）</strong>：当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， <strong>它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID</strong>，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel</li>
<li><strong>multiple</strong>：为了减少网络流量，手动确认可以被批处理，<strong>当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</strong></li>
</ul>
</li>
</ul>
<h3 id="手动否认-拒绝消息"><a href="#手动否认-拒绝消息" class="headerlink" title="手动否认 拒绝消息"></a>手动否认 拒绝消息</h3><ul>
<li><p>发送一条错误消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(String exchange, String routeKey, String body)</span></span>&#123;</span><br><span class="line">        MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        properties.getHeaders().put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;这是一条错误的消息&quot;</span>);</span><br><span class="line">        properties.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(body.getBytes(), properties);</span><br><span class="line">        rabbitTemplate.send(exchange, routeKey, message);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送了错误信息&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者获取消息时检查到头部包含 error 则 nack 消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;test.ack&quot;)</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String message, Channel channel,<span class="meta">@Headers</span> Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (map.get(<span class="string">&quot;error&quot;</span>)!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;错误的消息&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>,<span class="keyword">true</span>);      <span class="comment">//否认消息</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>);            <span class="comment">//确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时控制台重复打印，说明该消息被 nack 后一直重新入队列然后一直重新消费</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以拒绝该消息，消息会被丢弃，不会重回队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.basicReject((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>); <span class="comment">//拒绝消息</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="确认消息（全局处理消息）"><a href="#确认消息（全局处理消息）" class="headerlink" title="确认消息（全局处理消息）"></a>确认消息（全局处理消息）</h3><ul>
<li><p><strong>自动确认</strong>涉及到一个问题就是如果在处理消息的时候抛出异常，消息处理失败，但是因为自动确认而导致 Rabbit 将该消息删除了，造成消息丢失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//NONE</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);                 <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.NONE);     <span class="comment">// NONE 代表自动确认</span></span><br><span class="line">    container.setMessageListener((MessageListener) message -&gt; &#123;         <span class="comment">//消息监听处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="comment">//相当于自己的一些消费逻辑抛错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;consumer fail&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动确认消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//MANUAL</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>); <span class="comment">// 监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); // 监听的队列, 注入方式</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">// 手动确认</span></span><br><span class="line">    </span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt; &#123;      <span class="comment">//消息处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====监听到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="keyword">if</span>(message.getMessageProperties().getHeaders().get(<span class="string">&quot;error&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已经确认&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AcknowledgeMode 除了 NONE 和 MANUAL 之外还有 <strong>AUTO</strong> ，它会根据方法的执行情况来决定是否确认还是拒绝（是否重新入queue）</p>
<ul>
<li>如果消息成功被消费（成功的意思是在消费的过程中没有抛出异常），则自动确认</li>
<li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且 requeue = false（不重新入队列）</li>
<li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会被确认</li>
<li>其他的异常，则消息会被拒绝，且 requeue = true（==如果此时只有一个消费者监听该队列，则有发生死循环的风险，多消费端也会造成资源的极大浪费，这个在开发过程中一定要避免的==）。可以通过 setDefaultRequeueRejected（默认是true）去设置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//AUTO</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);              <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.AUTO);     <span class="comment">// 根据情况确认消息</span></span><br><span class="line">    container.setMessageListener((MessageListener) (message) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="comment">//抛出NullPointerException异常则重新入队列</span></span><br><span class="line">        <span class="comment">//throw new NullPointerException(&quot;消息消费失败&quot;);</span></span><br><span class="line">        <span class="comment">//当抛出的异常是AmqpRejectAndDontRequeueException异常的时候，则消息会被拒绝，且requeue=false</span></span><br><span class="line">        <span class="comment">//throw new AmqpRejectAndDontRequeueException(&quot;消息消费失败&quot;);</span></span><br><span class="line">        <span class="comment">//当抛出ImmediateAcknowledgeAmqpException异常，则消费者会被确认</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ImmediateAcknowledgeAmqpException(<span class="string">&quot;消息消费失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息可靠总结</strong></p>
<ul>
<li>持久化<ul>
<li>exchange要持久化</li>
<li>queue要持久化</li>
<li>message要持久化</li>
</ul>
</li>
<li>消息确认<ul>
<li>启动消费返回（@ReturnList注解，生产者就可以知道哪些消息没有发出去）</li>
<li>生产者和Server（broker）之间的消息确认</li>
<li>消费者和Server（broker）之间的消息确认</li>
</ul>
</li>
</ul>
<h2 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h2><p>Return Listener 用于处理一些不可路由的消息</p>
<p>我们的消息生产者,通过指定一个Exchange和Routingkey,把消息送达到某一个队列中取,然后我们的消费者监听队列,进行消费处理操作</p>
<p>但是在某些情况下,如果我们在发送消息的时候,当前的exchange不存在或者指定的路由key路由不到,这个时候需要监听这种不可达的消息,就要使用Return Listener</p>
<p><strong>关键配置项:</strong></p>
<ul>
<li><em>Mandatory</em>: 如果为true, 则监听器会接收到路由不可达的消息,然后进行后续处理; 如果为false, 那么broker端自动删除改消息</li>
</ul>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.return.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;return.#&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.return.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//指定channel的消费者 autoAck</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.return.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;return.save&quot;</span>;</span><br><span class="line">        String routingKeyError = <span class="string">&quot;abc.save&quot;</span>;</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ Return Listener!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---添加return listener---</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 监听不可达消息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyCode 响应码</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyText 响应文本</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> exchange 交换器</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> basicProperties 属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------handle return---------------&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;replyCode: &quot;</span> + replyCode);</span><br><span class="line">                System.out.println(<span class="string">&quot;replyText: &quot;</span> + replyText);</span><br><span class="line">                System.out.println(<span class="string">&quot;exchange: &quot;</span> + exchange);</span><br><span class="line">                System.out.println(<span class="string">&quot;routingKey: &quot;</span> + routingKey);</span><br><span class="line">                System.out.println(<span class="string">&quot;properties: &quot;</span> + basicProperties.getMessageId());</span><br><span class="line">                System.out.println(<span class="string">&quot;body: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Mandatory = true 才能使监听起效! */</span></span><br><span class="line">        <span class="comment">//发送消息 exchange, routingKey, Mandatory, properties, body</span></span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        <span class="comment">//发送消息到不存在的routingKey</span></span><br><span class="line">        channel.basicPublish(exchangeName, routingKeyError, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息到不存在的routingKey,将会触发handleReturn回调,打印信息如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">------------------handle <span class="keyword">return</span>---------------</span><br><span class="line">replyCode: <span class="number">312</span></span><br><span class="line">replyText: NO_ROUTE</span><br><span class="line">exchange: test.return.exchange</span><br><span class="line">routingKey: abc.save</span><br><span class="line">properties: <span class="keyword">null</span></span><br><span class="line">body: Hello RabbitMQ Return Listener!</span><br></pre></td></tr></table></figure>

<p>==Mandatory = true 才能使监听起效!==</p>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><blockquote>
<p>假设一个场景, 首先我们RabbitM服务器有上万条未处理的消息,此时开启一个消费端,会出现下面的情况:</p>
<p>巨量的消息瞬间被推送过来,单个消费端无法同时处理这么多的数据,造成服务的崩溃</p>
</blockquote>
<p>RabbitMQ提供了一种qos(服务治理保证)功能, 即在非自动确认消息的前提下,如果一定数目的消息(通过基于consume或者channel设置Qos的值) 未被确认前,不进行消费新的消息</p>
<p>实际开发中 <em>autoAck</em> 一定是false</p>
<p><code>void BasicQos(int prefetchSize, short prefetchConut, bool global)</code></p>
<ul>
<li>prefetchSize: 消息大小的限制, 一般设置为0不限制</li>
<li>prefetchConut: 在Broker接收到该Consumer的ack之前,Consumer在同一个时间点最多被分配最多处理消息数量</li>
<li>global: true应用在监听此channel的所有consume, false仅应用在当前consume</li>
</ul>
<p>prefetchSize和global这两项,rabbitmq没有实现,暂且不研究;</p>
<p>prefetchConut只在no_ask=false的情况下生效</p>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.qos.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.qos.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;qos.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----QOS限流, 每次处理1条消息----</span></span><br><span class="line">        channel.basicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//设置consumer 设置autoAck false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            <span class="comment">//ack答应</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将basicAck注释掉,consumer将只会收到第一条信息</p>
<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.qos.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;qos.save&quot;</span>;</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ QOS Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送5条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费端Ack与重回队列"><a href="#消费端Ack与重回队列" class="headerlink" title="消费端Ack与重回队列"></a>消费端Ack与重回队列</h2><p><strong>ack的三种答应:</strong></p>
<ul>
<li>basicAck : 返回正确的答应</li>
<li>basicNack: 返回否定的答应,且 requeue = true 消息会重回队列,循环重发</li>
<li>basicReject: 返回拒绝的答应, 消息会被丢弃</li>
</ul>
<p><strong>消费端的重回队列:</strong></p>
<ul>
<li>消费端重回队列是为了对没有处理成功的消息, 把消息重新回递给Broker</li>
<li>一般在实际应用中,都会关闭重回队列,也就是false</li>
</ul>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.ack.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.ack.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;ack.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer autoAck = false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((Integer)properties.getHeaders().get(<span class="string">&quot;num&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//否定答应 消息唯一标识, 是否批量处理, 是否重回队列</span></span><br><span class="line">                channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;重回队列, DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//ack答应</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>num为0的消息被否认ack,接着处理完其他几条消息后, num为0的消息不断的重回队列</p>
<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReQueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.ack.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.ack.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;ack.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ ACK Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送5条信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            HashMap&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            headers.put(<span class="string">&quot;num&quot;</span>, i);</span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .deliveryMode(<span class="number">2</span>) <span class="comment">//持久化</span></span><br><span class="line">                    .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                    .expiration(<span class="string">&quot;20000&quot;</span>)</span><br><span class="line">                    .headers(headers)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h2><p>TTL是 Time To Live 的缩写, 也就是生存时间</p>
<p><strong>RabbitMQ支持消息的过期时间, 在发送消息时可以进行指定</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .expiration(<span class="string">&quot;20000&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>RabbitMQ支持队列级消息的过期时间, 从消息入队开始计算, 只要超过了队列的超时时间配置, 那么消息会自动的清除</strong></p>
<p><img src="https://i.loli.net/2020/07/04/lCcxyu75zB9Jm8f.png" alt="image-20200704160309883"></p>
<p>在创建时可指定 Arguments 下面的参数:</p>
<ul>
<li>message-ttl : 消息过期时间, 毫秒</li>
<li>max-length: 消息最大长度</li>
<li>…</li>
</ul>
<p><strong>测试TTL队列</strong></p>
<ul>
<li><p>新建exchange, 指定路由键为 ttl.abc 绑定到上面创建的 exp.queue 队列</p>
</li>
<li><p>发送一条消息</p>
<img src="https://i.loli.net/2020/07/04/e5BYpEGWguiQSRZ.png" alt="image-20200704161110566" style="zoom: 80%;" />
</li>
<li><p>10秒之后这条消息会被清除</p>
<p><img src="https://i.loli.net/2020/07/04/cDnTC5M2sZBqxtP.png" alt="image-20200704161315752"></p>
</li>
</ul>
<h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><p><strong>死信队列: Dead-Letter-Exchange</strong></p>
<p>RabbitMQ中的死信队列是和exchange息息相关的</p>
<p>利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange,  这个Exchange就是DLX</p>
<p><strong>消息变成死信有以下几种情况</strong></p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p><strong>死信处理过程</strong></p>
<ul>
<li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</li>
<li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</li>
<li>可以监听这个队列中的消息做相应的处理。</li>
</ul>
<p><strong>死信队列设置</strong></p>
<ol>
<li><p>设置死信队列的exchange和queue, 然后进行绑定:</p>
<p>Exchange: dlx.exchange</p>
<p>Queue: dlx.queue </p>
<p>RoutingKey: #</p>
</li>
<li><p>然后正常声明交换机, 队列, 绑定, 只不过需要在队列上加一个参数设置死信交换机:</p>
<p>arguments.put(“x-dead-letter-exchange”, “dlx.exchange”);</p>
</li>
</ol>
<p>如此, ==消息在过期, 无法requeue, 或达到队列最大长度时, 消息可以直接路由到死信队列==</p>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通的交换机和队列以及路由</span></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.order.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.order.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;order.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----设置死信队列exchange----</span></span><br><span class="line">        String DLX_exchange = <span class="string">&quot;dlx.exchange&quot;</span>;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DLX_exchange);</span><br><span class="line">        <span class="comment">//创建一个队列 设置arguments</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----声明死信队列和exchange并绑定----</span></span><br><span class="line">        String DLX_queue = <span class="string">&quot;dlx.queue&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(DLX_exchange, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(DLX_queue, <span class="keyword">true</span>, <span class="keyword">false</span> ,<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(DLX_queue, DLX_exchange, <span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer autoAck = false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            <span class="comment">//NACK否认答应</span></span><br><span class="line">            channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.order.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;order.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ DLX Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .deliveryMode(<span class="number">2</span>) <span class="comment">//持久化</span></span><br><span class="line">                    .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                    .expiration(<span class="string">&quot;10000&quot;</span>)  <span class="comment">//过期时间10秒</span></span><br><span class="line">                    .build();</span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Cloud-Stream整合"><a href="#Spring-Cloud-Stream整合" class="headerlink" title="Spring Cloud Stream整合"></a>Spring Cloud Stream整合</h2><p><img src="https://i.loli.net/2020/07/07/MDodcWSTBwZ8bKe.png" alt="img"></p>
<p><strong>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</strong></p>
<p>Spring Cloud Stream相当于是一个消息的中间代理, 消息的生产与消费, 可以使用不同的消息中间件</p>
<p>Spring Cloud Stream 为 Kafka 和 Rabbit MQ 提供了 Binder 实现</p>
<p><strong>Spring Cloud Stream 中的几个重要概念</strong>:</p>
<ul>
<li><p><em>Destination Binders</em>：目标绑定器，目标指的是 kafka 还是 RabbitMQ，绑定器就是封装了目标中间件的包。如果操作的是 kafka 就使用 kafka binder ，如果操作的是 RabbitMQ 就使用 rabbitmq binder。</p>
</li>
<li><p><em>Destination Bindings</em>：外部消息传递系统和应用程序之间的桥梁，提供消息的“生产者”和“消费者”（由目标绑定器创建）</p>
</li>
<li><p><em>Message</em>：一种规范化的数据结构，生产者和消费者基于这个数据结构通过外部消息系统与目标绑定器和其他应用程序通信。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Middleware</td>
<td>中间件,目前只支持RabbitMQ和Kafka</td>
</tr>
<tr>
<td>Binder</td>
<td>Binder是应用与消息中间件之间的封装,可以很方便的连接,动态的改变消息类型</td>
</tr>
<tr>
<td>@Input</td>
<td>表示输入通道,通过该输入通道接收到的消息进入应用程序</td>
</tr>
<tr>
<td>@Output</td>
<td>表示输出通道,发布的消息将通过该通道离开应用程序</td>
</tr>
<tr>
<td>@StreamListener</td>
<td>监听队列,用于消费者队列的消息接收</td>
</tr>
<tr>
<td>@EnableBinding</td>
<td>指信道channel和exchange绑定在一起</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MQ</category>
      </categories>
  </entry>
  <entry>
    <title>Vue学习笔记</title>
    <url>/2019/03/26/Vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p>Vue是一套用于构建用户界面的<strong>渐进式框架</strong></p>
<p>官网: <a href="https://cn.vuejs.org/">https://cn.vuejs.org</a></p>
<p>特点为: 渐进式, 虚拟DOM, 响应式, 双向绑定, 组件化</p>
<a id="more"></a>

<p><strong>MVVM</strong></p>
<p><img src="https://gitee.com/hanzhengyu/picture-bed-2021/raw/master/20210428170907.png" alt="img"></p>
<ol>
<li><p>各部分之间的通信，都是双向的。</p>
</li>
<li><p>View 与 Model 不发生联系，都通过 Presenter 传递。</p>
</li>
<li><p>View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。</p>
</li>
<li><p>它采用双向绑定（data-binding）：ViewModel能够观察到数据的变化,并对视图对应的内容进行更新; ViewModel能够监听到视图的变化,并能够通知数据发生改变,<a href="https://angularjs.org/">Angular</a> 和 <a href="http://emberjs.com/">Ember</a> 都采用这种模式。</p>
</li>
</ol>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html">http://www.ruanyifeng.com/blog/2015/02/mvcmvp_mvvm.html</a></p>
</blockquote>
<h2 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a><strong>安装Vue</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#安装最新稳定版</span><br><span class="line">npm install vue</span><br></pre></td></tr></table></figure>

<p><strong>引入Vue.js</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;vue.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="创建Vue实例"><a href="#创建Vue实例" class="headerlink" title="创建Vue实例"></a><strong>创建Vue实例</strong></h2><p>每个 Vue 应用都是通过用 <code>Vue</code> 函数创建一个新的 <strong>Vue 实例</strong>开始的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  	<span class="comment">// 选项</span></span><br><span class="line">    el: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    </span><br><span class="line">    data: &#123;</span><br><span class="line">        message: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>el</code>:挂载点,Vue通过元素的id接管了一个元素</p>
<p>当创建一个 Vue 实例时，你可以传入一个<strong>选项对象</strong>,创建你想要的行为, <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">API 参考</a></p>
<p><strong>数据和方法</strong></p>
<p>当一个 Vue 实例被创建时，它将 <code>data</code> 对象中的所有的 property 加入到 Vue 的<strong>响应式系统</strong>中。当这些 property 的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象</span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得这个实例上的 property</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段</span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 property 也会影响到原始数据</span></span><br><span class="line">vm.a = <span class="number">2</span></span><br><span class="line">data.a <span class="comment">// =&gt; 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然</span></span><br><span class="line">data.a = <span class="number">3</span></span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>

<p>当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时就已经存在于 <code>data</code> 中的 property 才是<strong>响应式</strong>的。也就是说如果你添加一个新的 property，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">vm.b = <span class="string">&#x27;hi&#x27;</span></span><br></pre></td></tr></table></figure>

<p>那么对 <code>b</code> 的改动将不会触发任何视图的更新。如果你知道你会在晚些时候需要一个 property，但是一开始它为空或不存在，那么你仅需要设置一些初始值。比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  newTodoText: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  visitCount: <span class="number">0</span>,</span><br><span class="line">  hideCompletedTodos: <span class="literal">false</span>,</span><br><span class="line">  todos: [],</span><br><span class="line">  error: <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里唯一的例外是使用 <code>Object.freeze()</code>，这会阻止修改现有的 property，也意味着响应系统无法再<em>追踪</em>变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.freeze(obj)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: obj</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 这里的 `foo` 不会更新！ --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;foo = &#x27;baz&#x27;&quot;</span>&gt;</span>Change it<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>除了数据 property，Vue 实例还暴露了一些有用的实例 property 与方法。它们都有前缀 <code>$</code>，以便与用户定义的 property 区分开来。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line">  data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">&#x27;example&#x27;</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">&#x27;a&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">    <span class="built_in">console</span>.log(newValue, oldValue);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>以后你可以在 <a href="https://cn.vuejs.org/v2/api/#%E5%AE%9E%E4%BE%8B-property">API 参考</a>中查阅到完整的实例 property 和方法的列表。</p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125; //插值表达式</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;Hello Vue!&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-if-条件判断"><a href="#v-if-条件判断" class="headerlink" title="v-if 条件判断"></a>v-if 条件判断</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-3&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-if</span>=<span class="string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app3 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-3&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    seen: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>还可使用v-show控制元素的显示与否,区别在于v-show会改变元素的display属性而不是直接删除元素再创建,性能会强一些</p>
<ul>
<li><code>v-else</code></li>
</ul>
<p>你可以使用 <code>v-else</code> 指令来表示 <code>v-if</code> 的“else 块”：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;Math.random() &gt; 0.5&quot;</span>&gt;</span></span><br><span class="line">  Now you see me</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Now you don&#x27;t</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-else</code> 元素必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素的后面，否则它将不会被识别。</p>
<ul>
<li><code>v-else-if</code></li>
</ul>
<p>顾名思义，充当 <code>v-if</code> 的“else-if 块”，可以连续使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span></span><br><span class="line">  A</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span></span><br><span class="line">  B</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span></span><br><span class="line">  C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  Not A/B/C</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>类似于 <code>v-else</code>，<code>v-else-if</code> 也必须紧跟在带 <code>v-if</code> 或者 <code>v-else-if</code> 的元素之后。</p>
<h3 id="v-for-循环遍历"><a href="#v-for-循环遍历" class="headerlink" title="v-for 循环遍历"></a><strong>v-for</strong> 循环遍历</h3><p>我们可以用 <code>v-for</code> 指令基于一个数组来渲染一个列表,</p>
<p>其中 <code>todos</code> 是源数据数组，而 <code>todo</code> 则是被迭代的数组元素的<strong>别名</strong>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-4&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;todo in todos&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app4 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-4&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    todos: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 JavaScript&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;学习 Vue&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;整个牛项目&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>可以访问所有父作用域的 property,还可以使用每一项的index</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(todo, index) in todos&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123; todo.text &#125;&#125; - &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>你也可以用 <code>v-for</code> 来遍历一个对象的 property。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;v-for-object&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in object&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123; value &#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#v-for-object&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    object: &#123;</span><br><span class="line">      title: <span class="string">&#x27;How to do lists in Vue&#x27;</span>,</span><br><span class="line">      author: <span class="string">&#x27;Jane Doe&#x27;</span>,</span><br><span class="line">      publishedAt: <span class="string">&#x27;2016-04-10&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并且可以提供第二个的参数为 property 名称 (也就是键名)：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) of person&quot;</span>&gt;</span></span><br><span class="line">			&#123;&#123;key&#125;&#125; : &#123;&#123;value&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">person: &#123;</span><br><span class="line">    name: <span class="string">&#x27;edc&#x27;</span>,</span><br><span class="line">    age: <span class="number">22</span>,</span><br><span class="line">    msg: <span class="string">&#x27;狗咬狗&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>:key</code></li>
</ul>
<p>当 Vue 正在更新使用 <code>v-for</code> 渲染的元素列表时，它默认使用“就地更新”的策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是就地更新每个元素</p>
<p>这个默认的模式是高效的，但是<strong>只适用于不依赖子组件状态或临时 DOM 状态 (例如：表单输入值) 的列表渲染输出</strong>。</p>
<p>为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 <code>key</code> attribute：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span> <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 内容 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>建议尽可能在使用 <code>v-for</code> 时提供 <code>key</code> attribute, key属性只能使用number或String</p>
<ul>
<li><code>filter()</code>过滤列表</li>
</ul>
<p>可以创建一个计算属性，来返回过滤或排序后的数组。</p>
<p>不会变更原始数组，而<strong>总是返回一个新数组</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Vue-for filter实现<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    Filter Key<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;keyword&quot;</span>&gt;</span>   </span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in filterShoppingList&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; item &#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span>     </span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app5 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	    el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	    data: &#123;</span><br><span class="line">	        shoppingList: [</span><br><span class="line">	            <span class="string">&quot;Milk&quot;</span>, <span class="string">&quot;Donuts&quot;</span>, <span class="string">&quot;Cookies&quot;</span>, <span class="string">&quot;Chocolate&quot;</span>, <span class="string">&quot;Peanut Butter&quot;</span>, <span class="string">&quot;Pepto Bismol&quot;</span>, <span class="string">&quot;Pepto Bismol (Chocolate flavor)&quot;</span>, <span class="string">&quot;Pepto Bismol (Cookie flavor)&quot;</span></span><br><span class="line">	        ],</span><br><span class="line">	        keyword: <span class="string">&quot;&quot;</span></span><br><span class="line">	    &#125;,</span><br><span class="line">	    computed: &#123;</span><br><span class="line">	        filterShoppingList: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	            <span class="comment">// `this` points to the vm instance</span></span><br><span class="line">	            <span class="keyword">var</span> keyword = <span class="built_in">this</span>.keyword;</span><br><span class="line">	            <span class="keyword">var</span> shoppingList = <span class="built_in">this</span>.shoppingList;</span><br><span class="line">	            <span class="keyword">return</span> shoppingList.filter(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">	                <span class="keyword">return</span> item.toLowerCase().indexOf(keyword.toLowerCase()) != <span class="number">-1</span></span><br><span class="line">	            &#125;);</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>

<p>这样就做到了根据关键字过滤列表,还可以使用<code>return item.match(&#39;C&#39;);</code>匹配单个字符</p>
<h3 id="操作数组的方法"><a href="#操作数组的方法" class="headerlink" title="操作数组的方法"></a>操作数组的方法</h3><ul>
<li><p><code>concat()</code>向数组末尾添加元素,不会改变当前数组,<strong>返回当前数组的副本</strong></p>
</li>
<li><p><code>push()</code>向数组末尾添加元素</p>
</li>
<li><p><code>pop()</code>弹出末尾的元素</p>
</li>
<li><p><code>unshift()</code>向数组首部添加元素</p>
</li>
<li><p><code>shift()</code>移除首部的元素</p>
</li>
<li><p><code>sort()/reverse()</code> 排序/反转,下面是例子</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;person in personArr&quot;</span>&gt;</span></span><br><span class="line">        &#123;&#123; person &#125;&#125;</span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sortArr&quot;</span>&gt;</span>sort<span class="tag">&lt;/<span class="name">button</span>&gt;</span>        // 1、sort 按钮，并定义了 click 事件</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;reverseArr&quot;</span>&gt;</span>reverse<span class="tag">&lt;/<span class="name">button</span>&gt;</span>  //    reverse 按钮，也定义了 click 事件</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    personArr: [<span class="string">&#x27;张三&#x27;</span>, <span class="string">&#x27;李四&#x27;</span>, <span class="string">&#x27;王二麻子&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;    <span class="comment">// 2、事件要在 methods 中定义</span></span><br><span class="line">    sortArr() &#123;                      </span><br><span class="line">      <span class="built_in">this</span>.personArr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b.length - a.length    <span class="comment">// 3、为了效果，我写的 b.length - a.length，你也可以调换顺序试试</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    reverseArr() &#123;</span><br><span class="line">      <span class="built_in">this</span>.personArr.reverse()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>splice(index,len,[item])</code></li>
</ul>
<p>它也可以用来替换/删除/添加数组内某一个或者几个值（该方法会改变原始数组）</p>
<p><code>index</code>:数组开始下标    </p>
<p><code>len</code>: 替换/删除的长度    </p>
<p><code>item</code>:替换的值，删除操作的话 item为空</p>
<p><strong>删除</strong>:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//删除起始下标为1，长度为1的一个值(len设置1，如果为0，则数组不变)</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);  </span><br><span class="line"><span class="comment">//[&#x27;a&#x27;,&#x27;c&#x27;,&#x27;d&#x27;]; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除起始下标为1，长度为2的一个值(len设置2)</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>]</span><br><span class="line">arr2.splice(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2); </span><br><span class="line"><span class="comment">//[&#x27;a&#x27;,&#x27;d&#x27;]</span></span><br></pre></td></tr></table></figure>

<p><strong>替换：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//替换起始下标为1，长度为1的一个值为‘ttt’，len设置的1</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">1</span>,<span class="string">&#x27;ttt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);     </span><br><span class="line"><span class="comment">//[&#x27;a&#x27;,&#x27;ttt&#x27;,&#x27;c&#x27;,&#x27;d&#x27;] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//替换起始下标为1，长度为2的两个值为‘ttt’，len设置的1</span></span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr2.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="string">&#x27;ttt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr2);    </span><br><span class="line"><span class="comment">//[&#x27;a&#x27;,&#x27;ttt&#x27;,&#x27;d&#x27;] </span></span><br></pre></td></tr></table></figure>

<p><strong>添加：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在下标为1处添加一项&#x27;ttt&#x27;</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">0</span>,<span class="string">&#x27;ttt&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr);     </span><br><span class="line"><span class="comment">//[&#x27;a&#x27;,&#x27;ttt&#x27;,&#x27;b&#x27;,&#x27;c&#x27;,&#x27;d&#x27;] </span></span><br></pre></td></tr></table></figure>

<h3 id="v-model-双向绑定"><a href="#v-model-双向绑定" class="headerlink" title="v-model 双向绑定"></a>v-model 双向绑定</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-6&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>实现表单输入和应用状态之间的双向绑定</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app6 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-6&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="v-on-事件监听器"><a href="#v-on-事件监听器" class="headerlink" title="v-on 事件监听器"></a><strong>v-on</strong> 事件监听器</h3><p>通过它调用在 Vue 实例中定义的方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-5&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;reverseMessage&quot;</span>&gt;</span>反转消息<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> app5 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-5&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;Hello Vue.js!&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reverseMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">this</span>.message = <span class="built_in">this</span>.message.split(<span class="string">&#x27;&#x27;</span>).reverse().join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 阻止单击事件继续传播 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 提交事件不再重载页面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>=<span class="string">&quot;onSubmit&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 修饰符可以串联 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.stop.prevent</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只有修饰符 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">v-on:submit.prevent</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.capture</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-on:click.self</span>=<span class="string">&quot;doThat&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 点击事件将只会触发一次 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-on:click.once</span>=<span class="string">&quot;doThis&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 <code>v-on:click.prevent.self</code> 会阻止<strong>所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
<p>在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 <code>v-on</code> 在监听键盘事件时添加按键修饰符：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">v-on:keyup.enter</span>=<span class="string">&quot;submit&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="计算器"><a href="#计算器" class="headerlink" title="计算器"></a>计算器</h3><p><code>computed</code>可以返回一个data中属性相计算后的属性</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	姓: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span><br><span class="line">	名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>并且在没有改变data中属性的值的情况下,<code>computed</code>会返回上一次计算的缓存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el   : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">	data : &#123;</span><br><span class="line">		firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">		lastName: <span class="string">&#x27;&#x27;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>getter/setter</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">      <span class="built_in">this</span>.firstName = names[<span class="number">0</span>]</span><br><span class="line">      <span class="built_in">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<p>现在再运行 <code>vm.fullName = &#39;John Doe&#39;</code> 时，setter 会被调用，<code>vm.firstName</code> 和 <code>vm.lastName</code> 也会相应地被更新。</p>
<h3 id="侦听器"><a href="#侦听器" class="headerlink" title="侦听器"></a>侦听器</h3><p><code>watch</code>当data或计算器中的属性值发生改变时,执行对应的方法</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	姓: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;firstName&quot;</span> /&gt;</span></span><br><span class="line">	名: <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;lastName&quot;</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el   : <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">	data : &#123;</span><br><span class="line">		firstName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">		lastName: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">		count: <span class="number">0</span></span><br><span class="line">	&#125;,</span><br><span class="line">	computed: &#123;</span><br><span class="line">		fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	watch: &#123;</span><br><span class="line">		fullName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">			<span class="built_in">this</span>.count ++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="CSS与style"><a href="#CSS与style" class="headerlink" title="CSS与style"></a><strong>CSS与style</strong></h3><p><strong>对象语法</strong></p>
<p>我们可以传给 <code>v-bind:class</code> 一个对象，以动态地切换 class：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面的语法表示 <code>active</code> 这个 class 存在与否将取决于数据 property <code>isActive</code> 的 <a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy">truthiness</a>(真值)。</p>
<p>你可以在对象中传入更多字段来动态切换多个 class。此外，<code>v-bind:class</code> 指令也可以与普通的 class attribute 共存。当有如下模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:class</span>=<span class="string">&quot;&#123; active: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>和如下 data：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: &#123;</span><br><span class="line">  <span class="attribute">isActive</span>: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当 <code>isActive</code> 或者 <code>hasError</code> 变化时，class 列表将相应地更新。例如，如果 <code>hasError</code> 的值为 <code>true</code>，class 列表将变为 <code>&quot;static active text-danger&quot;</code>。</p>
<p>绑定的数据对象不必内联定义在模板里：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  classObject: &#123;</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    <span class="string">&#x27;text-danger&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染的结果和上面一样。我们也可以在这里绑定一个返回对象的<a href="https://cn.vuejs.org/v2/guide/computed.html">计算属性</a>。这是一个常用且强大的模式：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;div v-bind:<span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;classObject&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: <span class="literal">true</span>,</span><br><span class="line">  error: &#123;</span><br><span class="line">      hasError: <span class="literal">true</span>,</span><br><span class="line">      type: <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">computed: &#123;</span><br><span class="line">  classObject: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: <span class="built_in">this</span>.isActive &amp;&amp; !<span class="built_in">this</span>.error,</span><br><span class="line">      <span class="string">&#x27;text-danger&#x27;</span>: <span class="built_in">this</span>.error.hasError &amp;&amp; <span class="built_in">this</span>.error.type === <span class="string">&#x27;fatal&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>数组语法</strong></p>
<p>我们可以把一个数组传给 <code>v-bind:class</code>，以应用一个 class 列表:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[activeClass, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  activeClass: <span class="string">&#x27;active&#x27;</span>,</span><br><span class="line">  errorClass: <span class="string">&#x27;text-danger&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>渲染为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果你也想根据条件切换列表中的 class，可以用三元表达式：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这样写将始终添加 <code>errorClass</code>，但是只有在 <code>isActive</code> 是 truthy时才添加 <code>activeClass</code>。</p>
<p>不过，当有多个条件 class 时这样写有些繁琐。所以在数组语法中也可以使用对象语法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">&quot;[&#123; active: isActive &#125;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>v-bind:style</code> 的数组语法可以将多个样式对象应用到同一个元素上：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;[baseStyles, overridingStyles]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>内联样式</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">&quot;styleObject&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  styleObject: &#123;</span><br><span class="line">    color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">    fontSize: <span class="string">&#x27;13px&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 <code>key</code> 管理可复用的元素</h3><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么在上面的代码中切换 <code>loginType</code> 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，不会被替换掉——仅仅是替换了它的 <code>placeholder</code>。</p>
<p>这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 <code>key</code> attribute 即可：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-if</span>=<span class="string">&quot;loginType === &#x27;username&#x27;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your username&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span>&gt;</span>Email<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">placeholder</span>=<span class="string">&quot;Enter your email address&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email-input&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>现在，每次切换时，输入框都将被重新渲染。请看：</p>
<p>注意，元素仍然会被高效地复用，因为它们没有添加 <code>key</code> attribute。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做<strong>生命周期钩子</strong>的函数，这给了用户在不同阶段添加自己的代码的机会。</p>
<p>比如 <a href="https://cn.vuejs.org/v2/api/#created"><code>created</code></a> 钩子可以用来在一个实例被创建之后执行代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    a: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  created: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// `this` 指向 vm 实例</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;a is: &#x27;</span> + <span class="built_in">this</span>.a)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// =&gt; &quot;a is: 1&quot;</span></span><br></pre></td></tr></table></figure>

<p>也有一些其它的钩子，在实例生命周期的不同阶段被调用，如 <a href="https://cn.vuejs.org/v2/api/#mounted"><code>mounted</code></a>、<a href="https://cn.vuejs.org/v2/api/#updated"><code>updated</code></a> 和 <a href="https://cn.vuejs.org/v2/api/#destroyed"><code>destroyed</code></a>。生命周期钩子的 <code>this</code> 上下文指向调用它的 Vue 实例。</p>
<blockquote>
<p>不要在选项 property 或回调上使用<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>，比如</p>
<p> <code>created: () =&gt; console.log(this.a)</code> 或 <code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())</code>。</p>
<p>因为箭头函数并没有 <code>this</code>，<code>this</code> 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p>
</blockquote>
<p><strong>生命周期图示</strong></p>
<p><img src="https://gitee.com/hanzhengyu/picture-bed-2021/raw/master/20210428171152.png" alt="1158910-20180321144509069-1773072070"></p>
<h2 id="组件化应用构建"><a href="#组件化应用构建" class="headerlink" title="组件化应用构建"></a>组件化应用构建</h2><p><img src="D:\study\Markdown\images\image-20200521195722921.png" alt="image-20200521195722921"></p>
<p>在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例。在 Vue 中注册组件很简单：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义名为todo-item的组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">  template: <span class="string">&#x27;&lt;li&gt;这是个待办项&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(...)</span><br></pre></td></tr></table></figure>

<p>现在你可以用它构建另一个组件模板：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 创建一个 todo-item 组件的实例 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">todo-item</span>&gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>但是这样会为每个待办项渲染同样的文本，这看起来并不炫酷。我们应该能从父作用域将数据传到子组件才对。让我们来修改一下组件的定义，使之能够接受一个 <a href="https://cn.vuejs.org/v2/guide/components.html#%E9%80%9A%E8%BF%87-Prop-%E5%90%91%E5%AD%90%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE">prop</a>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// todo-item 组件现在接受一个</span></span><br><span class="line">  <span class="comment">// &quot;prop&quot;，类似于一个自定义 attribute。</span></span><br><span class="line">  <span class="comment">// 这个 prop 名为 todo。</span></span><br><span class="line">  props: [<span class="string">&#x27;todo&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>现在，我们可以使用 <code>v-bind</code> 指令将待办项传到循环输出的每个组件中：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app-7&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">      现在我们为每个 todo-item 提供 todo 对象</span></span><br><span class="line"><span class="comment">      todo 对象是变量，即其内容可以是动态的。</span></span><br><span class="line"><span class="comment">      我们也需要为每个组件提供一个“key”</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-for</span>=<span class="string">&quot;item in groceryList&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:todo</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">v-bind:key</span>=<span class="string">&quot;item.id&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>, &#123;</span><br><span class="line">  props: [<span class="string">&#x27;todo&#x27;</span>],</span><br><span class="line">  template: <span class="string">&#x27;&lt;li&gt;&#123;&#123; todo.text &#125;&#125;&lt;/li&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app7 = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app-7&#x27;</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    groceryList: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">0</span>, <span class="attr">text</span>: <span class="string">&#x27;蔬菜&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">text</span>: <span class="string">&#x27;奶酪&#x27;</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">text</span>: <span class="string">&#x27;随便其它什么人吃的东西&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>子单元通过 prop 接口与父单元进行了良好的解耦</p>
<h3 id="子组件事件分发"><a href="#子组件事件分发" class="headerlink" title="子组件事件分发"></a><strong>子组件事件分发</strong></h3><p>在子组件methods中可使用<code>$emit</code>函数声明事件,接收两个参数: 1.事件的名称, 2.传递的参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;todo-item&#x27;</span>,&#123;</span><br><span class="line">    props: [<span class="string">&#x27;content&#x27;</span>, <span class="string">&#x27;index&#x27;</span>],</span><br><span class="line">    template: <span class="string">&#x27;&lt;li @click=&quot;handleClick&quot;&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;&#x27;</span>,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.$emit(<span class="string">&#x27;delete&#x27;</span>, <span class="built_in">this</span>.index);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>然后可以在父组件中定义这个事件的执行逻辑</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">&#x27;#root&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        inputValue: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">        list: []</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleSubmit: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.list.push(<span class="built_in">this</span>.inputValue);</span><br><span class="line">            <span class="built_in">this</span>.inputValue = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        handleDelete: <span class="function"><span class="keyword">function</span>(<span class="params">index</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.list.splice(index, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>并在模板上使用它</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">v-model</span>=<span class="string">&quot;inputValue&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;handleSubmit&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">todo-item</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">v-for</span>=<span class="string">&quot;(item, index) of list&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:content</span>=<span class="string">&quot;item&quot;</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">:index</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">                   @<span class="attr">delete</span>=<span class="string">&quot;handleDelete&quot;</span></span></span><br><span class="line"><span class="tag">                   &gt;</span><span class="tag">&lt;/<span class="name">todo-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a><strong>局部注册</strong></h3><p>全局注册往往是不够理想的。比如，如果你使用一个像 webpack 这样的构建系统，全局注册所有的组件意味着即便你已经不再使用一个组件了，它仍然会被包含在你最终的构建结果中。这造成了用户下载的 JavaScript 的无谓的增加。</p>
<p>在这些情况下，你可以通过一个普通的 JavaScript 对象来定义组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ComponentA = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentB = &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="keyword">var</span> ComponentC = &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>components</code> 选项中定义你想要使用的组件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    <span class="string">&#x27;component-a&#x27;</span>: ComponentA,</span><br><span class="line">    <span class="string">&#x27;component-b&#x27;</span>: ComponentB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>对于 <code>components</code> 对象中的每个 property 来说，其 property 名就是自定义元素的名字，其 property 值就是这个组件的选项对象。</p>
<h3 id="props"><a href="#props" class="headerlink" title="props"></a><strong>props</strong></h3><p>可以指定prop的数据类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">  title: <span class="built_in">String</span>,</span><br><span class="line">  likes: <span class="built_in">Number</span>,</span><br><span class="line">  isPublished: <span class="built_in">Boolean</span>,</span><br><span class="line">  commentIds: <span class="built_in">Array</span>,</span><br><span class="line">  author: <span class="built_in">Object</span>,</span><br><span class="line">  callback: <span class="built_in">Function</span>,</span><br><span class="line">  contactsPromise: <span class="built_in">Promise</span> <span class="comment">// or any other constructor</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a><strong>插槽</strong></h3><p>Vue 实现了一套内容分发的 API，这套 API 的设计灵感源自 <a href="https://github.com/w3c/webcomponents/blob/gh-pages/proposals/Slots-Proposal.md">Web Components 规范草案</a>，将 `` 元素作为承载分发内容的出口。</p>
<p>它允许你像这样合成组件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>然后你在 `` 的模板中可能会写为：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-bind:href</span>=<span class="string">&quot;url&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;nav-link&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>当组件渲染的时候，`` 将会被替换为“Your Profile”。插槽内可以包含任何模板代码，包括 HTML：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation-link</span> <span class="attr">url</span>=<span class="string">&quot;/profile&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个 Font Awesome 图标 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;fa fa-user&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  Your Profile</span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>甚至其它的组件..</p>
<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。</p>
</blockquote>
<p>如果<code>&lt;slot&gt;</code>在模板定义中包含内容,在使用时没有指定内容的话就会渲染默认的内容,否则将替换你指定的内容</p>
<p>同一个模板中的插槽可以<strong>name属性标识</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">books</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">book-title</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:title</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">book-title</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">book-chapter</span> </span></span><br><span class="line"><span class="tag">		<span class="attr">slot</span>=<span class="string">&quot;chapter&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">v-for</span>=<span class="string">&quot;(cur, index) of chapter&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">:item</span>=<span class="string">&quot;cur&quot;</span></span></span><br><span class="line"><span class="tag">		<span class="attr">:key</span>=<span class="string">&quot;index&quot;</span></span></span><br><span class="line"><span class="tag">		&gt;</span><span class="tag">&lt;/<span class="name">book-chapter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;books&#x27;</span>,&#123;</span><br><span class="line">			template: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">							&lt;slot name=&quot;title&quot;&gt;这是插槽&lt;/slot&gt;</span></span><br><span class="line"><span class="string">							</span></span><br><span class="line"><span class="string">							&lt;strong&gt;</span></span><br><span class="line"><span class="string">								&lt;slot name=&quot;chapter&quot;&gt;这是插槽&lt;/slot&gt;</span></span><br><span class="line"><span class="string">							&lt;/strong&gt;</span></span><br><span class="line"><span class="string">					   &lt;/div&gt;`</span></span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 书籍标题组件模板</span></span><br><span class="line">		Vue.component(<span class="string">&#x27;book-title&#x27;</span>,&#123;</span><br><span class="line">			props: [<span class="string">&#x27;title&#x27;</span>],</span><br><span class="line">			template: <span class="string">`&lt;div&gt;&#123;&#123; title &#125;&#125;&lt;/div&gt;`</span></span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 书籍章节列表模板</span></span><br><span class="line">		Vue.component(<span class="string">&#x27;book-chapter&#x27;</span>,&#123;</span><br><span class="line">			props: [<span class="string">&#x27;item&#x27;</span>],</span><br><span class="line">			template: <span class="string">`&lt;li&gt;&#123;&#123; item &#125;&#125;&lt;/li&gt;`</span></span><br><span class="line">		&#125;)</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Vue(&#123;</span><br><span class="line">			el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">			data: &#123;</span><br><span class="line">				name: <span class="string">&#x27;Java成神之路&#x27;</span>,</span><br><span class="line">				chapter: [<span class="string">&#x27;chapter01-集合框架&#x27;</span>, <span class="string">&#x27;chapter02-数据结构&#x27;</span>, <span class="string">&#x27;chapter03-JVM&#x27;</span>, <span class="string">&#x27;chapter04-JUC&#x27;</span>]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h2><p>Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中。</p>
<p><strong>特性</strong></p>
<ul>
<li>从浏览器中创建 <a href="https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest">XMLHttpRequests</a></li>
<li>从 node.js 创建 <a href="http://nodejs.org/api/http.html">http</a> 请求</li>
<li>支持 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 <a href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">XSRF</a></li>
</ul>
<p><strong>本地模拟数据使用示例:</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">		[v-cloak]&#123; //防止页面闪烁未渲染完成的表达式</span><br><span class="line">			display: none;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span> <span class="attr">v-cloak</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;(value, key) of info&quot;</span>&gt;</span></span><br><span class="line">			&#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125;</span><br><span class="line">		<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">           </span><br><span class="line">           <span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:href</span>=<span class="string">&quot;info.url&quot;</span>&gt;</span>主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>发送一个get请求,得到response交给vue渲染页面</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	data: &#123;</span><br><span class="line">		info: &#123;</span><br><span class="line">			<span class="string">&quot;name&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="string">&quot;url&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="string">&quot;address&quot;</span>: &#123;</span><br><span class="line">				<span class="string">&quot;city&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">				<span class="string">&quot;country&quot;</span>: <span class="literal">null</span></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;links&quot;</span>: []</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">	mounted() &#123;</span><br><span class="line">		axios.get(<span class="string">&#x27;./data.json&#x27;</span>).then(<span class="function"><span class="params">response</span> =&gt;</span>(<span class="built_in">this</span>.info = response.data));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>下载axios</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在项目路径下打开终端执行以下内容</span><br><span class="line">npm install axios --save</span><br></pre></td></tr></table></figure>

<p><strong>在 main.js 中引入 axios</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br></pre></td></tr></table></figure>

<p>这时候如果在其它的组件中，是无法使用 axios 命令的。所以我们将 axios 改写为 Vue 的原生属性</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Vue.prototype.<span class="variable">$axios</span> = axios</span><br></pre></td></tr></table></figure>

<p>在 main.js 中添加了这两行代码之后，就能直接在组件的 methods 中使用 <code>this.$axios</code>命令</p>
<p>再此之前需要解决<strong>跨域问题</strong></p>
<p>在项目根目录下创建<code>vue.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">// webpack-dev-server 相关配置</span></span><br><span class="line">    devServer: &#123;</span><br><span class="line">        proxy: &#123;</span><br><span class="line">            <span class="string">&#x27;/api&#x27;</span>: &#123;</span><br><span class="line">                target: <span class="string">&#x27;http://129.204.206.237&#x27;</span>,</span><br><span class="line">                ws: <span class="literal">true</span>,</span><br><span class="line">                changeOrigin: <span class="literal">true</span>,</span><br><span class="line">                pathRewrite: &#123;</span><br><span class="line">                    <span class="string">&#x27;^/api&#x27;</span>: <span class="string">&#x27;&#x27;</span>  <span class="comment">//通过pathRewrite重写地址，将前缀/api转为/</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>GET请求</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">this</span>.$axios.get(<span class="string">&#x27;/getList&#x27;</span>).then(response =&gt;&#123; </span><br><span class="line">    <span class="keyword">this</span>.userList = response.data</span><br><span class="line">&#125;).<span class="keyword">catch</span>(error =&gt;&#123;</span><br><span class="line">    console.log(error)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>POST请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//post</span></span><br><span class="line"><span class="comment">//form-data 表单提交(文件上传)</span></span><br><span class="line"><span class="comment">//application/json </span></span><br><span class="line"><span class="keyword">let</span> data = &#123;</span><br><span class="line">    id: <span class="number">12</span>,</span><br><span class="line">    name: <span class="string">&#x27;edc&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">axios.post(<span class="string">&#x27;/post&#x27;</span>,data).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$axios(&#123;</span><br><span class="line">    method:<span class="string">&quot;POST&quot;</span>,</span><br><span class="line">    url:<span class="string">&#x27;/user&#x27;</span>,</span><br><span class="line">    data:&#123;</span><br><span class="line">      name:<span class="string">&quot;virus&quot;</span>,</span><br><span class="line">      age: <span class="number">20</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>DELETE请求</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//delete</span></span><br><span class="line">axios.delete(<span class="string">&#x27;/delete&#x27;</span>,&#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">        id: <span class="number">12</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>如果参数命名为<code>params</code>将会携带在url中,命名为<code>data</code>则在请求体中</p>
<p><strong>一次性发送多个请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//并发请求</span></span><br><span class="line"><span class="comment">//axios.all() axios.spread()</span></span><br><span class="line">axios.all([</span><br><span class="line">    axios.get(<span class="string">&#x27;/data.json&#x27;</span>),</span><br><span class="line">    axios.get(<span class="string">&#x27;/city.json&#x27;</span>)</span><br><span class="line">]).then(</span><br><span class="line">    axios.spread(<span class="function">(<span class="params">dataRes, CityRes</span>) =&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(dataRes, CityRes)</span><br><span class="line">    &#125;)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserAccount</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUserPermissions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> axios.get(<span class="string">&#x27;/user/12345/permissions&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.$axios.all([getUserAccount(),getUserPermissions()])</span><br><span class="line">  .then(axios.spread(<span class="function"><span class="keyword">function</span>(<span class="params">acct,perms</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//当这两个请求都完成的时候会触发这个函数，两个参数分别代表两个请求返回的结果</span></span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>

<p>完整的请求还应当包括 .then 和 .catch</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.then(<span class="function"><span class="params">res</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>当请求成功时，会执行 .then，否则执行 .catch, 这两个回调函数都有各自独立的作用域，如果直接在里面访问 this，无法访问到 Vue 实例,这时只要添加一个 .bind(this) 就能解决这个问题。(如果你使用的是es6箭头函数就不存在这样的问题)。</p>
<p><strong>支持的请求</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios.request(config);</span><br><span class="line"></span><br><span class="line">axios.get(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.delete(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.head(url[,config]);</span><br><span class="line"></span><br><span class="line">axios.post(url[,data[,config]]);</span><br><span class="line"></span><br><span class="line">axios.put(url[,data[,config]])</span><br><span class="line"></span><br><span class="line">axios.patch(url[,data[,config]])</span><br></pre></td></tr></table></figure>

<h3 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h3><p>当后端接口有多个地址,并且超时时间可能不一样,就需要创建axios实例</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;</span><br><span class="line">				baseURL: <span class="string">&#x27;http://localhost:8080&#x27;</span>,</span><br><span class="line">				timeout: <span class="number">1000</span> <span class="comment">//超时返回401</span></span><br><span class="line">			&#125;)</span><br><span class="line">			instance.get(<span class="string">&#x27;/data.json&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">				<span class="built_in">console</span>.log(res)</span><br><span class="line">			&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance2 = axios.create(&#123;</span><br><span class="line">				<span class="comment">//基本地址</span></span><br><span class="line">				baseURL: <span class="string">&#x27;http://192.168.107.1:9090&#x27;</span>,</span><br><span class="line">				<span class="comment">//超时时间</span></span><br><span class="line">				timeout: <span class="number">5000</span>,</span><br><span class="line">				<span class="comment">//请求路径</span></span><br><span class="line">				url: <span class="string">&#x27;/data.json&#x27;</span>,</span><br><span class="line">				<span class="comment">//请求方式</span></span><br><span class="line">				method: <span class="string">&#x27;post&#x27;</span>,</span><br><span class="line">				<span class="comment">//设置请求头</span></span><br><span class="line">				headers: &#123;</span><br><span class="line">					token: <span class="string">&#x27;&#x27;</span></span><br><span class="line">				&#125;,</span><br><span class="line">				<span class="comment">//url参数</span></span><br><span class="line">				params: &#123;&#125;,</span><br><span class="line">				<span class="comment">//请求体参数</span></span><br><span class="line">				data: &#123;&#125;</span><br><span class="line">			&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>axios全局配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios全局配置</span></span><br><span class="line">axios.defaults.timeout = <span class="number">1000</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://..&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>axios请求配置</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//axios请求配置</span></span><br><span class="line">axios.get(<span class="string">&#x27;/data.json&#x27;</span>,&#123;</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>==请求配置 &gt; 实例配置 &gt; 全局配置==, 实际开发中常用实例配置,发送请求时可根据实际情况使用请求配置</p>
<h3 id="axios拦截器"><a href="#axios拦截器" class="headerlink" title="axios拦截器"></a>axios拦截器</h3><p>在请求或响应被处理前拦截它们</p>
<p><strong>请求拦截器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求拦截器</span></span><br><span class="line">axios.interceptors.request.use</span><br><span class="line">(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//在发送请求前做些什么</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//在请求错误的时候做些什么</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>响应拦截器</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//响应拦截器</span></span><br><span class="line">axios.interceptors.response.use</span><br><span class="line">(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求成功对响应数据做处理</span></span><br><span class="line">    <span class="comment">//处理后返回到 .then()</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//响应错误做些什么</span></span><br><span class="line">    <span class="comment">//处理后返回到 .catch()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>请求头传递token</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实例 (需要登录的接口)</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;&#125;)</span><br><span class="line"><span class="comment">//定义拦截器</span></span><br><span class="line">instance.interceptors.request.use</span><br><span class="line">(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    config.headers.token = <span class="string">&#x27;c7f9932ffac58fc0534d14b43e3a97fe&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//不需要登录的接口</span></span><br><span class="line"><span class="keyword">let</span> newInstance = axios.create(&#123;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>为请求添加一个等待样式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> instance_phone = axios.create(&#123;&#125;)</span><br><span class="line">instance_phone.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    $(<span class="string">&#x27;#modal&#x27;</span>).show()</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;)</span><br><span class="line">instance_phone.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    $(<span class="string">&#x27;#modal&#x27;</span>).hide()</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>错误处理</strong></p>
<p>在实际开发中一般都会需要一个统一的错误处理,以简化<code>.carch()</code>的处理</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建实例</span></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(&#123;&#125;)</span><br><span class="line"><span class="comment">//请求拦截器</span></span><br><span class="line">instance.interceptors.request</span><br><span class="line">(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//请求错误 一般以4开头</span></span><br><span class="line">    $(<span class="string">&#x27;#modal&#x27;</span>).show()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;#modal&#x27;</span>).hide()</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//响应拦截器</span></span><br><span class="line">instance.interceptors.response</span><br><span class="line">(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//响应错误 一般以5开头</span></span><br><span class="line">    $(<span class="string">&#x27;#modal&#x27;</span>).show()</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        $(<span class="string">&#x27;#modal&#x27;</span>).hide()</span><br><span class="line">    &#125;,<span class="number">2000</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(err)</span><br><span class="line">&#125;)</span><br><span class="line">发送请求</span><br><span class="line">instance.get(<span class="string">&#x27;/data.json&#x27;</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="Vant移动端组件库"><a href="#Vant移动端组件库" class="headerlink" title="Vant移动端组件库"></a>Vant移动端组件库</h3><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i vant -S</span><br></pre></td></tr></table></figure>

<p>组件导入插件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i babel-plugin-import -D</span><br></pre></td></tr></table></figure>



<blockquote>
<p><a href="https://youzan.github.io/vant-weapp/#/quickstart">https://youzan.github.io/vant-weapp/#/quickstart</a></p>
</blockquote>
<h2 id="Vue-cli"><a href="#Vue-cli" class="headerlink" title="Vue-cli"></a>Vue-cli</h2><p>Vue 提供了一个<a href="https://github.com/vuejs/vue-cli">官方的 CLI</a>，为单页面应用 (SPA) 快速搭建繁杂的脚手架。它为现代前端工作流提供了 batteries-included 的构建设置。只需要几分钟的时间就可以运行起来并带有热重载、保存时 lint 校验，以及生产环境可用的构建版本。更多详情可查阅 <a href="https://cli.vuejs.org/">Vue CLI 的文档</a>。</p>
<p>构建<a href="https://cn.vuejs.org/v2/guide/">指南</a></p>
<p>实际的开发当中Vue要基于NodeJS, 采用vue-cli脚手架开发, vue-router路由, vuex做状态管理(session); Vue UI界面一般使用ElementUI(饿了么),或者ICE(阿里巴巴)</p>
<p><strong>安装NodeJS</strong></p>
<p><a href="http://nodejs.cn/download/">http://nodejs.cn/download/</a> <code>node -v</code>,<code>npm -v</code>验证安装</p>
<p><strong>下载vue-cli</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> -g代表全局安装</span></span><br></pre></td></tr></table></figure>

<p>安装完成后检测版本<code>vue -version</code></p>
<p><strong>卸载旧版本</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall -g vue-cli</span><br></pre></td></tr></table></figure>

<p><strong>vue -V 不是内部或外部命令，也不是可运行的程序…</strong></p>
<p><code>npm config list</code> 查看一下npm 的配置信息</p>
<p><code>prefix = &quot;&quot;</code>的路径是下载的路径</p>
<p>如果下载成功应该包含vue.cmd,将这个路径配置到环境变量Path</p>
<h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a><strong>初始化项目</strong></h3><p>新建一个工作空间目录,以webpack的方式初始化一个项目</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue init webpack vue-cli-example01</span><br></pre></td></tr></table></figure>

<p>==新版本使用<code>vue create hello-world</code>==</p>
<blockquote>
<p><a href="https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create">https://cli.vuejs.org/zh/guide/creating-a-project.html#vue-create</a></p>
</blockquote>
<ul>
<li><code>Project name</code>, <code>Project description</code>:项目名称和项目描述,回车使用默认的就可以</li>
<li><code>Author</code>:作者</li>
<li><code>Vue build</code>:构建方式,选择运行时编译<code>Runtime + Compiler: recommended for most users</code></li>
<li><code>Install vue-router? (Y/n)</code>:是否安装vue-router,选择NO (手动安装)</li>
<li><code>? Use ESLint to lint your code? No</code>: 是否使用ESlint做代码检查 (手动安装)</li>
<li><code>? Set up unit tests No</code>: 单元测试相关 (手动安装)</li>
<li><code>? Setup e2e tests with Nightwatch? No</code> 单元测试相关 (手动安装)</li>
<li><code>Should we run </code>npm install<code> for you after the project has been created? (recommended)</code>: 创建完成后自动初始化,下载依赖 选择NO (手动操作)</li>
</ul>
<p><strong>手动初始化并运行</strong></p>
<ol>
<li>进入项目目录<code>cd vue-cli-example01</code></li>
<li><code>npm install</code>安装所有依赖(根据package.json)</li>
<li>导入编辑器</li>
<li><code>npm run dev</code>启动时会自动打包</li>
<li>访问<a href="http://localhost:8080/">http://localhost:8080</a></li>
<li>启动自动运行:在package.json中找到<code>&quot;scripts&quot;</code>在<code>&quot;dev&quot;</code>属性中添加–open参数即可</li>
</ol>
<p><img src="https://i.loli.net/2020/05/29/7fEseMN8bTP31m5.png" alt="image-20200529132058365"></p>
<p><strong>目录结构</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|-- build                            &#x2F;&#x2F; 项目构建(webpack)相关代码</span><br><span class="line">|   |-- build.js                     &#x2F;&#x2F; 生产环境构建代码</span><br><span class="line">|   |-- check-version.js             &#x2F;&#x2F; 检查node、npm等版本</span><br><span class="line">|   |-- utils.js                     &#x2F;&#x2F; 构建工具相关</span><br><span class="line">|   |-- vue-loader.conf.js           &#x2F;&#x2F; webpack loader配置</span><br><span class="line">|   |-- webpack.base.conf.js         &#x2F;&#x2F; webpack基础配置</span><br><span class="line">|   |-- webpack.dev.conf.js          &#x2F;&#x2F; webpack开发环境配置,构建开发本地服务器</span><br><span class="line">|   |-- webpack.prod.conf.js         &#x2F;&#x2F; webpack生产环境配置</span><br><span class="line">|-- config                           &#x2F;&#x2F; 项目开发环境配置</span><br><span class="line">|   |-- dev.env.js                   &#x2F;&#x2F; 开发环境变量</span><br><span class="line">|   |-- index.js                     &#x2F;&#x2F; 项目一些配置变量</span><br><span class="line">|   |-- prod.env.js                  &#x2F;&#x2F; 生产环境变量</span><br><span class="line">|-- src                              &#x2F;&#x2F; 源码目录</span><br><span class="line">|   |-- components                   &#x2F;&#x2F; vue公共组件</span><br><span class="line">|   |-- router                       &#x2F;&#x2F; vue的路由管理</span><br><span class="line">|   |-- App.vue                      &#x2F;&#x2F; 页面入口文件</span><br><span class="line">|   |-- main.js                      &#x2F;&#x2F; 程序入口文件，加载各种公共组件</span><br><span class="line">|-- static                           &#x2F;&#x2F; 静态文件，比如一些图片，json数据等</span><br><span class="line">|-- .babelrc                         &#x2F;&#x2F; ES6语法编译配置</span><br><span class="line">|-- .editorconfig                    &#x2F;&#x2F; 定义代码格式</span><br><span class="line">|-- .gitignore                       &#x2F;&#x2F; git上传需要忽略的文件格式</span><br><span class="line">|-- .postcsssrc                       &#x2F;&#x2F; postcss配置文件</span><br><span class="line">|-- README.md                        &#x2F;&#x2F; 项目说明</span><br><span class="line">|-- index.html                       &#x2F;&#x2F; 入口页面</span><br><span class="line">|-- package.json                     &#x2F;&#x2F; 项目基本信息,包依赖信息等</span><br></pre></td></tr></table></figure>

<p>在项目中每个组件都是一个<code>.vue</code>文件包含vue示例样式和模板,通过<code>export</code>导出供其他组件使用<code>import</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;HelloWorld&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      msg: <span class="string">&#x27;Welcome to Your Vue.js App&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  name: <span class="string">&#x27;App&#x27;</span>,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><p><em>webpack</em> 是一个现代 JavaScript 应用程序的<em>静态模块打包器(module bundler)<em>。当 webpack 处理应用程序时，它会递归地构建一个</em>依赖关系图(dependency graph)*，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 *bundle</em>。</p>
<p>它能把各种资源,如 JS, JSX, ES6, SASS, LESS,图片等都作为模块来处理和使用;</p>
<p>因为大部分浏览器停留在ES5版本,webpack可以把ES6的代码编译成ES5以支持浏览器</p>
<blockquote>
<p>文档: <a href="https://www.webpackjs.com/concepts/">https://www.webpackjs.com/concepts/</a></p>
<p>教程:<a href="https://lookroot.cn/course/webpack/#%E4%BB%80%E4%B9%88%E6%98%AFwebpack">https://lookroot.cn/course/webpack/#%E4%BB%80%E4%B9%88%E6%98%AFwebpack</a></p>
</blockquote>
<p><strong>安装</strong>,以管理员身份打开cmd执行如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install webpack -g #打包工具</span><br><span class="line">npm install webpack-cli -g #客户端</span><br></pre></td></tr></table></figure>

<p><strong>验证</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">webpack -version</span><br><span class="line">webpack-cli -version</span><br></pre></td></tr></table></figure>

<p><strong>核心配置文件</strong><code>webpack.config.js</code></p>
<ul>
<li>entry: 入口文件,指定webpack用哪个文件作为项目的入口</li>
<li>output: 输出,指定webpack把处理完成的文件放到指定路径</li>
<li>module: 模块,用于处理各种类型的文件</li>
<li>plugins: 插件,如热更新,代码重用等</li>
<li>resolve: 设置路径指向</li>
<li>watch: 监听,用于设置文件改动后直接打包</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: <span class="string">&quot;&quot;</span>,</span><br><span class="line">	output: &#123;</span><br><span class="line">		path: <span class="string">&quot;&quot;</span>,</span><br><span class="line">		filename: <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;,</span><br><span class="line">	<span class="built_in">module</span>: &#123;</span><br><span class="line">		loaders: [</span><br><span class="line">			&#123;<span class="attr">test</span>: <span class="regexp">/\.js$/</span>, loader: <span class="string">&quot;&quot;</span>&#125;</span><br><span class="line">		]</span><br><span class="line">	&#125;,</span><br><span class="line">	plugins: &#123;&#125;,</span><br><span class="line">	resolve: &#123;&#125;,</span><br><span class="line">	watch: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用webpack</strong></p>
<ol>
<li>创建项目目录<code>/webpack-example01</code></li>
<li>其中创建一个名为<code>modules</code>的目录,用于方式JS模块等资源文件</li>
<li>新建<code>modules/hello.js</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴露一个方法</span></span><br><span class="line"><span class="built_in">exports</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">&quot;&lt;h1&gt;你 好&lt;/h1&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新建<code>modules/main.js</code></li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接收方法</span></span><br><span class="line"><span class="keyword">var</span> hello = <span class="built_in">require</span>(<span class="string">&quot;./hello&quot;</span>);</span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">hello.sayHi();</span><br></pre></td></tr></table></figure>

<p>5.更目录新建<code>webpack.config.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">	entry: <span class="string">&#x27;./modules/main.js&#x27;</span>, <span class="comment">//程序入口</span></span><br><span class="line">	output: &#123;</span><br><span class="line">		filename: <span class="string">&#x27;./js/bundle.js&#x27;</span> <span class="comment">//打包位置</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在项目终端下运行<code>webpack</code>命令打包</li>
</ol>
<p><img src="https://i.loli.net/2020/05/29/C5THkwxfiqVL43m.png" alt="image-20200529142632446"></p>
<ol start="7">
<li>新建<code>index.html</code>,访问页面就会执行sayHi()</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./dist/js/bundle.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="Vue-router"><a href="#Vue-router" class="headerlink" title="Vue-router"></a>Vue-router</h2><p>官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<p><strong>安装</strong>,可以先查看<code>node_modules</code>中是否存在<code>vue-router</code></p>
<p>进入项目目录执行如下命令:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure>

<h3 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h3><p>安装成功后新建<code>router/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//引入vue和router</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="comment">//引入需要跳转的组件</span></span><br><span class="line"><span class="keyword">import</span> Content <span class="keyword">from</span> <span class="string">&#x27;../components/Content&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&#x27;../components/Main&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示声明使用router</span></span><br><span class="line">Vue.use(VueRouter)</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置导出路由</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//路由路径</span></span><br><span class="line">      path: <span class="string">&#x27;/content&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;content-router&#x27;</span>,</span><br><span class="line">      <span class="comment">//跳转的组件</span></span><br><span class="line">      component: Content</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//路由路径</span></span><br><span class="line">      path: <span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      name: <span class="string">&#x27;main-router&#x27;</span>,</span><br><span class="line">      <span class="comment">//跳转的组件</span></span><br><span class="line">      component: Main</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">		path: <span class="string">&#x27;/contactList&#x27;</span>,</span><br><span class="line">		name: <span class="string">&#x27;ContactList&#x27;</span>,</span><br><span class="line">		component: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;../views/ContactList.vue&#x27;</span>) <span class="comment">//延迟加载</span></span><br><span class="line">	&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>新建<code>Content.vue</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>Content<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三个<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;Content&quot;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span><span class="xml"> <span class="comment">&lt;!-- scoped代表样式只在该组件的作用域起效 --&gt;</span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>新建<code>Main.vue</code>组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Main<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置入口<code>main.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span> <span class="comment">//自动扫描里面的路由配置</span></span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">//配置路由</span></span><br><span class="line">  router,</span><br><span class="line">  components: &#123; App &#125;,</span><br><span class="line">  template: <span class="string">&#x27;&lt;App/&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在主页使用<code>&lt;router-linke&gt;</code>和<code>&lt;router-view&gt;</code>展示要跳转的组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用 router-link 组件来导航. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 通过传入 `to` 属性指定链接. --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;router-link&gt; 默认会被渲染成一个 `&lt;a&gt;` 标签 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/content&quot;</span>&gt;</span>内容页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/main&quot;</span>&gt;</span>入口页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由出口 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 路由匹配到的组件将渲染在这里 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>js方式</strong></p>
<p><code>this.$router.push(&quot;&quot;);</code></p>
<p>该方法的参数可以是一个字符串路径，或者一个描述地址的对象</p>
<h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a><strong>传参</strong></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="comment">//定义路由</span></span><br><span class="line">    path: <span class="string">&#x27;/profile/:username&#x27;</span>,</span><br><span class="line">    name: <span class="string">&#x27;Profile&#x27;</span>,</span><br><span class="line">    props: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传递参数</span></span><br><span class="line"><span class="built_in">this</span>.$router.push(<span class="string">&quot;/profile/&quot;</span> + <span class="built_in">this</span>.username);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用参数</span></span><br><span class="line">props: [<span class="string">&quot;username&quot;</span>]</span><br><span class="line">&#123;&#123; username &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a><strong>路由模式</strong></h3><ul>
<li>hash: 路径带 # 符号 (默认)</li>
<li>history: 路径不带 # 符号</li>
</ul>
<p>通过mode属性指定</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  routes: [</span><br><span class="line">      </span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>定义404页面</strong></p>
<ul>
<li>新建<code>view/NotFoud.vue</code></li>
<li>导入路由配置</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> NotFound <span class="keyword">from</span> <span class="string">&#x27;../views/NotFoud&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">    path: <span class="string">&#x27;*&#x27;</span>,</span><br><span class="line">    component: NotFound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Element-UI"><a href="#Element-UI" class="headerlink" title="Element UI"></a>Element UI</h3><p>基于VUE2.0的UI框架</p>
<ul>
<li><p><strong>初始化一个项目</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vue init webpack element-ui-example01</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装vue-router</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vue-router --save</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装Element UI</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm i element-ui -S</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装依赖</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>安装SASS加载器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>配置路由</strong><code>router/index.js</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Main <span class="keyword">from</span> <span class="string">&#x27;../views/Main&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Login <span class="keyword">from</span> <span class="string">&#x27;../views/Login&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Router);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      component: Main <span class="comment">//component 不加s</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">      component: Login</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在 main.js 中引入Element UI</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;./router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ElementUI <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(ElementUI)</span><br><span class="line">Vue.use(router)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App) <span class="comment">//ElementUI</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>App.vue</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;./assets/logo.png&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/login&quot;</span>&gt;</span>login<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/main&quot;</span>&gt;</span>main<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Main.vue &amp; Login.vue</code></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;Main&quot;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;form&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">el-form</span> <span class="attr">:model</span>=<span class="string">&quot;ruleForm2&quot;</span> <span class="attr">status-icon</span> <span class="attr">:rules</span>=<span class="string">&quot;rules2&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;ruleForm2&quot;</span> <span class="attr">label-width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">class</span>=<span class="string">&quot;demo-ruleForm&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">h3</span>&gt;</span>欢迎登录<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;账号&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;ruleForm2.username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户名/手机号/邮箱&quot;</span> <span class="attr">auto-complete</span>=<span class="string">&quot;off&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-form-item</span> <span class="attr">label</span>=<span class="string">&quot;密码&quot;</span> <span class="attr">prop</span>=<span class="string">&quot;pass&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;ruleForm2.pass&quot;</span> <span class="attr">auto-complete</span>=<span class="string">&quot;off&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">el-input</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;submitForm(&#x27;ruleForm2&#x27;)&quot;</span>&gt;</span>提交<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">el-button</span> @<span class="attr">click</span>=<span class="string">&quot;resetForm(&#x27;ruleForm2&#x27;)&quot;</span>&gt;</span>重置<span class="tag">&lt;/<span class="name">el-button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">el-form-item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">el-form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;Login&quot;</span>,</span></span><br><span class="line">    data() &#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> validateName = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(value === <span class="string">&#x27;&#x27;</span>)&#123;</span></span><br><span class="line"><span class="javascript">          callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入账号&#x27;</span>));</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> validatePass = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (value === <span class="string">&#x27;&#x27;</span>) &#123;</span></span><br><span class="line"><span class="javascript">          callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;请输入密码&#x27;</span>));</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$refs.ruleForm2.validateField(<span class="string">&#x27;checkPass&#x27;</span>);</span></span><br><span class="line">          callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        ruleForm2: &#123;</span><br><span class="line"><span class="javascript">          username: <span class="string">&#x27;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          pass: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">        &#125;,</span><br><span class="line">        rules2: &#123;</span><br><span class="line">          pass: [</span><br><span class="line"><span class="javascript">            &#123; <span class="attr">validator</span>: validatePass, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span></span><br><span class="line">          ],</span><br><span class="line">          username: [</span><br><span class="line"><span class="javascript">            &#123; <span class="attr">validator</span>: validateName, <span class="attr">trigger</span>: <span class="string">&#x27;blur&#x27;</span> &#125;</span></span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      submitForm(formName) &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$refs[formName].validate(<span class="function">(<span class="params">valid</span>) =&gt;</span> &#123;</span></span><br><span class="line">          if (valid) &#123;</span><br><span class="line"><span class="javascript">            <span class="comment">//验证成功</span></span></span><br><span class="line"><span class="javascript">            alert(<span class="string">&#x27;submit!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			<span class="built_in">this</span>.$router.push(<span class="string">&quot;/main&quot;</span>);</span></span><br><span class="line"><span class="javascript">          &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">&#x27;error submit!!&#x27;</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      resetForm(formName) &#123; <span class="comment">//重置表单</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$refs[formName].resetFields();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>npm run dev</code>运行测试</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/05/30/VJb7MKAIxGkcpwj.png" alt="image-20200530145455116"></p>
<h3 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h3><p>嵌套路由又称子路由,在实际应用中, 通常由多层嵌套的组件组合而成;同样的,URL中各段动态路径也按某种结构对应嵌套的各层组件</p>
<p><img src="https://i.loli.net/2020/05/30/oeFTvCmBA2X6gDi.png" alt="image-20200530145849907"></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  routes: [</span><br><span class="line">    &#123;</span><br><span class="line">      path: <span class="string">&#x27;/main&#x27;</span>,</span><br><span class="line">      component: Main,</span><br><span class="line">      children: [ <span class="comment">//嵌套路由</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/profile&#x27;</span>, <span class="attr">component</span>:UserProfile&#125;</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/list&#x27;</span>, <span class="attr">component</span>:UserList&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;...</span><br></pre></td></tr></table></figure>

<p>这样就可以实现在Main页面中实现路由跳转组件了</p>
<h3 id="传递参数和重定向"><a href="#传递参数和重定向" class="headerlink" title="传递参数和重定向"></a>传递参数和重定向</h3><p><strong>根据用户id路由,以显示不同的用户信息</strong></p>
<ul>
<li><strong>定义参数</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">children: [ <span class="comment">//嵌套路由</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/profile/:id&#x27;</span>, <span class="attr">name</span>:<span class="string">&#x27;UserProfile&#x27;</span>, <span class="attr">component</span>:UserProfile&#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&#x27;/user/list&#x27;</span>, <span class="attr">component</span>:UserList&#125;</span><br><span class="line">      ]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>传参</strong>,注意使用路由名称</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#123;name: &#x27;UserProfile&#x27;, params: &#123;id: 2&#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>获取参数</strong>,注意是<code>$route</code>,并且需要根元素</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;&#123; $route.params.id &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>还可使用props传参</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/user/profile/:id&#x27;</span>, <span class="attr">name</span>:<span class="string">&#x27;UserProfile&#x27;</span>, <span class="attr">component</span>:UserProfile, <span class="attr">props</span>: <span class="literal">true</span>&#125;,</span><br></pre></td></tr></table></figure>

<p>定义路由时指定<code>props: true</code>允许使用props接收参数</p>
<ul>
<li><strong>使用参数</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>个人信息<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    &#123;&#123; id &#125;&#125;</span><br><span class="line">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    props: [<span class="string">&quot;id&quot;</span>],</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;UserProfile&quot;</span></span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>回到首页重定向</strong></p>
<ul>
<li><strong>定义路由</strong></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">      path: <span class="string">&#x27;/goHome&#x27;</span>,</span><br><span class="line">      redirect: <span class="string">&#x27;/main&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;title&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/goHome&quot;</span>&gt;</span>回到首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="路由钩子和异步请求"><a href="#路由钩子和异步请求" class="headerlink" title="路由钩子和异步请求"></a>路由钩子和异步请求</h3><p><code>beforeRouteEnter</code>: 在进入路由前执行</p>
<p><code>beforeRouteLeave</code>: 在离开路由前执行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  template: <span class="string">`...`</span>,</span><br><span class="line">  beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在渲染该组件的对应路由被 confirm 前调用</span></span><br><span class="line">    <span class="comment">// 不！能！获取组件实例 `this`</span></span><br><span class="line">    <span class="comment">// 因为当守卫执行前，组件实例还没被创建</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 在当前路由改变，但是该组件被复用时调用</span></span><br><span class="line">    <span class="comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span></span><br><span class="line">    <span class="comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;,</span><br><span class="line">  beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">    <span class="comment">// 导航离开该组件的对应路由时调用</span></span><br><span class="line">    <span class="comment">// 可以访问组件实例 `this`</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeRouteEnter</code> 守卫 <strong>不能</strong> 访问 <code>this</code>，因为守卫在导航确认前被调用，因此即将登场的新组件还没被创建。</p>
<p>不过，你可以通过传一个回调给 <code>next</code>来访问组件实例。在导航被确认的时候执行回调，并且把组件实例作为回调方法的参数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteEnter (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  next(<span class="function"><span class="params">vm</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 通过 `vm` 访问组件实例</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意 <code>beforeRouteEnter</code> 是支持给 <code>next</code> 传递回调的唯一守卫。对于 <code>beforeRouteUpdate</code> 和 <code>beforeRouteLeave</code> 来说，<code>this</code> 已经可用了，所以<strong>不支持</strong>传递回调，因为没有必要了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteUpdate (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="comment">// just use `this`</span></span><br><span class="line">  <span class="built_in">this</span>.name = to.params.name</span><br><span class="line">  next()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个离开守卫通常用来禁止用户在还未保存修改前突然离开。该导航可以通过 <code>next(false)</code> 来取消。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span><br><span class="line">  <span class="keyword">const</span> answer = <span class="built_in">window</span>.confirm(<span class="string">&#x27;Do you really want to leave? you have unsaved changes!&#x27;</span>)</span><br><span class="line">  <span class="keyword">if</span> (answer) &#123;</span><br><span class="line">    next()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>完整的导航解析流程</strong></p>
<ol>
<li>导航被触发。</li>
<li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li>
<li>调用全局的 <code>beforeEach</code> 守卫。</li>
<li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li>
<li>在路由配置里调用 <code>beforeEnter</code>。</li>
<li>解析异步路由组件。</li>
<li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li>
<li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li>
<li>导航被确认。</li>
<li>调用全局的 <code>afterEach</code> 钩子。</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数。</li>
</ol>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p>Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</p>
<p>每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的**状态 (state)**。Vuex 和单纯的全局对象有以下两点不同：</p>
<ol>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地<strong>提交 (commit) mutation</strong>。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。</li>
</ol>
<p><img src="https://i.loli.net/2020/05/31/eZOTYBLKcmnM376.png" alt="image-20200531105217081"></p>
<blockquote>
<p>如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 <a href="https://cn.vuejs.org/v2/guide/state-management.html#%E7%AE%80%E5%8D%95%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%B5%B7%E6%AD%A5%E4%BD%BF%E7%94%A8">store 模式</a>就足够您所需了。</p>
</blockquote>
<p><strong>核心概念</strong></p>
<ul>
<li><strong>State</strong>: 应用程序全局的状态/数据（待办事项，帖子，令牌等）</li>
<li><strong>Getters</strong>: 从状态获取状态或计算值</li>
<li><strong>Actions</strong>: 从组件调用以提交一个mutation</li>
<li><strong>Mutations</strong>: 改变状态（更新数据等）</li>
<li><strong>Modules</strong>: 每个模块可以有自己的state，getters，actions和mutations（发布模块，身份验证模块等）</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>安装vuex</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install vuex --save</span><br></pre></td></tr></table></figure>

<p><code>store/index.js</code>导入vuex包</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line">Vue.use(Vuex)</span><br></pre></td></tr></table></figure>

<p>创建store对象</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="comment">//state 中存放全局共享的数据</span></span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>将store对象挂载到vue实例中(main.js)</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&#x27;./store&#x27;</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">	render: <span class="function"><span class="params">h</span> =&gt;</span> h(app),</span><br><span class="line">	router,</span><br><span class="line">	<span class="comment">//将创建的共享数据对象挂载到Vue实例中</span></span><br><span class="line">	<span class="comment">//所有的组件就可以从store中获取全局的数据了</span></span><br><span class="line">	store</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="访问全局数据"><a href="#访问全局数据" class="headerlink" title="访问全局数据"></a>访问全局数据</h3><p>组件访问state中数据的第一种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.state.全局数据名称</span><br><span class="line">当前最新的count值为: &#123;&#123;$store.state.count&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>组件访问state中数据的第二种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从vuex中按需导入 mapState 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapState函数,将当前组件需要的全局数据,映射为当前组件的computed计算属性:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">当前最新的count值为: &#123;&#123;count&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="修改全局数据"><a href="#修改全局数据" class="headerlink" title="修改全局数据"></a>修改全局数据</h3><p>直接在自定义事件中修改全局数据是不合理的</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">btnHandler () &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.state.count++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用Mutation变更Store中的数据,操作起来稍微繁琐,但是可以集中监控所有数据的变化</p>
<p>定义mutations变更state数据</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    add (state) &#123;</span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>触发mutation的第一种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">      btnHandler1 () &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义在触发mutations时传递的参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">addN (state, step) &#123;</span><br><span class="line">      state.count += step</span><br><span class="line">&#125;</span><br><span class="line">-----</span><br><span class="line"><span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addN&#x27;</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>触发mutation的第二种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从vuex种按需导入 mapMutations 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapMutations函数,将需要的mutations函数,映射为当前组件的methods方法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">sub (state) &#123;</span><br><span class="line">      state.count--</span><br><span class="line">&#125;,</span><br><span class="line">subN (state, step) &#123;</span><br><span class="line">      state.count -= step</span><br><span class="line">&#125;</span><br><span class="line">-------</span><br><span class="line">methods: &#123;</span><br><span class="line">      ...mapMutations([<span class="string">&#x27;sub&#x27;</span>, <span class="string">&#x27;subN&#x27;</span>]),</span><br><span class="line">      btnHandler1 () &#123;</span><br><span class="line">        <span class="built_in">this</span>.sub()</span><br><span class="line">      &#125;,</span><br><span class="line">      btnHandler2 () &#123;</span><br><span class="line">        <span class="built_in">this</span>.subN(<span class="number">3</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="异步操作全局数据"><a href="#异步操作全局数据" class="headerlink" title="异步操作全局数据"></a><strong>异步操作全局数据</strong></h3><p>不要在mutations函数中执行异步操作</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mutations: &#123;</span><br><span class="line">    add (state) &#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            state.count++</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐使用Action处理异步任务,但是在Action中还是要通过触发mutations的方式间接变更数据</p>
<p>定义Actions</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    ....</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    	add (state) &#123;</span><br><span class="line">    		state.count++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addAsync (context) &#123;</span><br><span class="line">            <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">                context.commit(<span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">            &#125;, <span class="number">1000</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>context</code>就相当于<code>Vuex.Store</code></p>
<p>触发actions的第一种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handle () &#123;</span><br><span class="line">        <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addAsync&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发Action时携带参数</p>
<p>定义actions</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">    ....</span><br><span class="line">    mutations: &#123;</span><br><span class="line">    	 addN (state, step) &#123;</span><br><span class="line">      		state.count += step</span><br><span class="line">    	 &#125;</span><br><span class="line">	&#125;,</span><br><span class="line">    actions: &#123;</span><br><span class="line">        addNAsync (context, step) &#123;</span><br><span class="line">      		<span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        		context.commit(<span class="string">&#x27;addN&#x27;</span>, step)</span><br><span class="line">      		&#125;, <span class="number">1000</span>)</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发action</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Handler () &#123;</span><br><span class="line">     <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;addNAsync&#x27;</span>, <span class="number">5</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>触发action的第二种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从vuex种导入 mapActions 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"><span class="comment">//or</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapMutations, mapActions &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过刚才导入的mapActions函数, 将需要的actions函数,映射为当前组件的methods方法:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">subAsync (context) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;sub&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    subNAsync (context, step) &#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;subN&#x27;</span>, step)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line">---------------</span><br><span class="line">methods: &#123;</span><br><span class="line">      ...mapActions([<span class="string">&#x27;subAsync&#x27;</span>, <span class="string">&#x27;subNAsync&#x27;</span>]),</span><br><span class="line">      btnHandler3 () &#123;</span><br><span class="line">        <span class="built_in">this</span>.subAsync()</span><br><span class="line">      &#125;,</span><br><span class="line">      btnHandler4 () &#123;</span><br><span class="line">        <span class="built_in">this</span>.subNAsync(<span class="number">10</span>)</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//也可直接绑定函数</span></span><br><span class="line"><span class="comment">// &lt;button @click=&quot;subAsync&quot;&gt; -1 Async &lt;/button&gt;</span></span><br><span class="line"><span class="comment">// &lt;button @click=&quot;subNAsync(10)&quot;&gt; -N Async &lt;/button&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="消费全局数据"><a href="#消费全局数据" class="headerlink" title="消费全局数据"></a>消费全局数据</h3><p>Getter用于对Store中的数据进行加工处理形成新的数据,但不会修改Store中的源数据,类似vue的计算属性,Store中的数据发送变化,Getter的数据也会跟着变化</p>
<p>getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>
<p>定义Getter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    showNum: <span class="function"><span class="params">state</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&#x27;当前最新的数量是[ &#x27;</span> + state.count + <span class="string">&#x27;]&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用getters的第一种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">this</span>.$store.getters.名称</span><br><span class="line"><span class="comment">//&lt;h3&gt;&#123;&#123;$store.getters.showNum&#125;&#125;&lt;/h3&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用getters的第二种方式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//从vuex种导入 mapGetters 函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapGetters &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过mapGetters函数,将数据映射到当前组件的computed计算属性中</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">    ...mapGetters([<span class="string">&#x27;showNum&#x27;</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="模块的局部状态"><a href="#模块的局部状态" class="headerlink" title="模块的局部状态"></a>模块的局部状态</h3><p>由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。</p>
<p>为了解决以上问题，Vuex 允许我们将 store 分割成<strong>模块（module）</strong>。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123; ... &#125;),</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>

<p>对于模块内部的 mutation 和 getter，接收的第一个参数是<strong>模块的局部状态对象</strong>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;),</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    increment (state) &#123;</span><br><span class="line">      <span class="comment">// 这里的 `state` 对象是模块的局部状态</span></span><br><span class="line">      state.count++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    doubleCount (state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count * <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样，对于模块内部的 action，局部状态通过 <code>context.state</code> 暴露出来，根节点状态则为 <code>context.rootState</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  actions: &#123;</span><br><span class="line">    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((state.count + rootState.count) % <span class="number">2</span> === <span class="number">1</span>) &#123;</span><br><span class="line">        commit(<span class="string">&#x27;increment&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  getters: &#123;</span><br><span class="line">    sumWithRootCount (state, getters, rootState) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.count + rootState.count</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="使用vue-ui创建项目"><a href="#使用vue-ui创建项目" class="headerlink" title="使用vue ui创建项目"></a>使用vue ui创建项目</h3><p>命令行执行<code>vue ui</code>,即可打开可视化页面</p>
<ul>
<li><p>点击创建新项目</p>
<img src="https://i.loli.net/2020/05/31/aTyGqjepWYJX52M.png" alt="image-20200531114058190" style="zoom:67%;" />
</li>
<li><p>预设选择手动或默认</p>
<img src="https://i.loli.net/2020/05/31/gQ6h1clneOJZtqR.png" alt="image-20200531114218938" style="zoom:67%;" />
</li>
<li><p>选择功能 Babel, Vuex, Linter/Formatter, use config file</p>
</li>
</ul>
<img src="https://i.loli.net/2020/05/31/mQW6UrnGYFlNq1V.png" alt="image-20200531114459333" style="zoom:67%;" />

<ul>
<li>选择标准配置 ESlint语法检测工具</li>
</ul>
<p><img src="https://i.loli.net/2020/05/31/91Emg4fqGrBz2dt.png" alt="image-20200531114553629"></p>
<ul>
<li><p>启动测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm run serve</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>关闭ESlint缩进检测</strong></p>
<p>eslintrc.js文件<code>rules:</code>中添加<code>&quot;indent&quot;: [&quot;off&quot;, 2]</code>,然后重启</p>
<p><strong>关闭函数前空格</strong><code>space-before-function-paren</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">rules: &#123;</span><br><span class="line">    <span class="string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span> ? <span class="string">&#x27;warn&#x27;</span> : <span class="string">&#x27;off&#x27;</span>,</span><br><span class="line">    <span class="string">&quot;space-before-function-paren&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="string">&quot;indent&quot;</span>: [<span class="string">&quot;off&quot;</span>, <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h3 id="ant-design-vue组件模板"><a href="#ant-design-vue组件模板" class="headerlink" title="ant-design-vue组件模板"></a>ant-design-vue组件模板</h3><p>开发和服务于企业级后台产品</p>
<ul>
<li><p>安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install ant-design-vue --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>在main.js导入</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//导入ant-design-vue组件库</span></span><br><span class="line"><span class="keyword">import</span> Antd <span class="keyword">from</span> <span class="string">&#x27;ant-design-vue&#x27;</span></span><br><span class="line"><span class="comment">//导入组件库的样式表</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;ant-design-vue/dist/antd.css&#x27;</span></span><br><span class="line"></span><br><span class="line">Vue.use(Antd)</span><br></pre></td></tr></table></figure>
</li>
<li><blockquote>
<p><a href="https://www.antdv.com/docs/vue/use-with-vue-cli-cn/">https://www.antdv.com/docs/vue/use-with-vue-cli-cn/</a></p>
</blockquote>
</li>
</ul>
<h2 id="微信小程序"><a href="#微信小程序" class="headerlink" title="微信小程序"></a>微信小程序</h2><h3 id="微信开发者工具"><a href="#微信开发者工具" class="headerlink" title="微信开发者工具"></a>微信开发者工具</h3><p><strong>微信小程序导入</strong></p>
<p>打开开发者工具–&gt;小程序–&gt;导入项目– &gt;选择项目目录–&gt;打开项目源码目录–&gt;unpackage–&gt;dist–&gt;dev–&gt;mp-weixin  </p>
<p>–&gt;输入AppID –&gt; 完成</p>
<p><strong>打开安全服务端口</strong></p>
<p><img src="https://i.loli.net/2020/06/06/T8jcOSGY2k9lRbJ.png" alt="image-20200606122204801"></p>
<h3 id="小米球Ngrok使用"><a href="#小米球Ngrok使用" class="headerlink" title="小米球Ngrok使用"></a>小米球Ngrok使用</h3><ul>
<li><p><strong>下载</strong> <a href="http://ngrok.ciqiuwl.cn/">http://ngrok.ciqiuwl.cn/</a></p>
</li>
<li><p>1,下载windows版本的客户端，解压到你喜欢的目录<br>2,前往控制台(<a href="https://manager.xiaomiqiu.com/)%E6%B3%A8%E5%86%8C%E8%8E%B7%E5%8F%96token(%E5%85%8D%E8%B4%B9)">https://manager.xiaomiqiu.com/)注册获取token(免费)</a><br>3,在配置文件里替换你注册后获得的token<br>4,在命令行下进入到ngrok客户端目录下<br>5,执行 <code>ngrok.exe -config ngrok.conf -log=ngrok.log start 隧道名称 </code>(隧道名称可以在配置文件中配置，多个用空格隔开)<br>6,执行 <code>ngrok.exe -config=ngrok.conf -subdomain xxx 80</code> (此命令用于未在配置文件中配置隧道的情况)<br>7,如果开启成功 你就可以使用 xxx.ngrok2.xiaomiqiu.cn 来访问你本机的 127.0.0.1:80 的服务啦<br>8,如果你自己有顶级域名，想通过自己的域名来访问本机的项目，那么先将自己的顶级域名解析到小米球服务器的IP(域名需要已备案哦)，然后执行 <code>ngrok -config=ngrok.conf -hostname xxx.xxx.xxx 80</code> (xxx.xxx.xxx是你自定义的顶级域名,此命令用于未在配置文件中配置隧道的情况)<br>9，如果开启成功 你就可以使用你的顶级域名来访问你本机的 127.0.0.1:80 的服务啦<br>10,如果失败 可以加下交流群 反馈下问题 本屌会看看什么原因<br>11,如果实在闲命令打开麻烦，windows版提供了一键启动脚本！直接启动即可（其它版本暂没有脚本）</p>
</li>
<li><p><strong>配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auth_token: &quot;c66c4ecA6b7e4465b35399d98763459e&quot; #小米球token</span><br><span class="line"></span><br><span class="line">tunnels:</span><br><span class="line">    httptun: #隧道名称,可以自定义</span><br><span class="line">      remote_port: 80 映射端口</span><br><span class="line">      subdomain: hzy00729 映射前缀</span><br><span class="line">      proto:</span><br><span class="line">        http: 127.0.0.1:8081 #http协议 本机地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动<code>ngrok.exe -config ngrok.conf -log=ngrok.log start httptun </code></p>
</li>
<li><p>再程序中访问控制台输出的域名,即可在手机端访问到本机的127.0.0.1:8081</p>
<p><img src="https://i.loli.net/2020/06/06/WOzgvGfyPuXUaQV.png" alt="image-20200606121834978"></p>
</li>
</ul>
<h2 id="uni-app"><a href="#uni-app" class="headerlink" title="uni-app"></a>uni-app</h2><p><strong>项目目录结构介绍</strong></p>
<ul>
<li>pages: 存放对用户展示的页面</li>
<li>static: 存放静态资源</li>
<li>unpackage: 存放打包文件</li>
<li>App.vue: 页面入口文件</li>
<li>main.js: 程序入口文件</li>
<li>manifest.json: 打包配置</li>
<li>pages.json: 配置页面存放路径和全局样式</li>
</ul>
<h3 id="globalStyle全局样式配置"><a href="#globalStyle全局样式配置" class="headerlink" title="globalStyle全局样式配置"></a>globalStyle全局样式配置</h3><p>pages.json中<code>globalStyle:</code>可用于设置应用的状态栏、导航条、标题、窗口背景色等。<a href="https://uniapp.dcloud.io/collocation/pages?id=globalstyle">详细文档</a></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">默认值</th>
<th align="left">描述</th>
<th align="left">平台差异说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">navigationBarBackgroundColor</td>
<td align="left">#F7F7F7</td>
<td align="left">导航栏背景颜色（同状态栏背景色）</td>
<td align="left">APP与H5为#F7F7F7，小程序平台请参考相应小程序文档</td>
</tr>
<tr>
<td align="left">navigationBarTextStyle</td>
<td align="left">white</td>
<td align="left">导航栏标题颜色及状态栏前景颜色，仅支持 black/white</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">navigationBarTitleText</td>
<td align="left"></td>
<td align="left">导航栏标题文字内容</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">navigationStyle</td>
<td align="left">default</td>
<td align="left">导航栏样式，仅支持 default/custom。custom即取消默认的原生导航栏，需看<a href="https://uniapp.dcloud.io/collocation/pages?id=customnav">使用注意</a></td>
<td align="left">微信小程序 7.0+、百度小程序、H5、App（2.0.3+）</td>
</tr>
<tr>
<td align="left">backgroundColor</td>
<td align="left">#ffffff</td>
<td align="left">下拉显示出来的窗口的背景色</td>
<td align="left">微信小程序</td>
</tr>
<tr>
<td align="left">backgroundTextStyle</td>
<td align="left">dark</td>
<td align="left">下拉 loading 的样式，仅支持 dark / light</td>
<td align="left">微信小程序</td>
</tr>
<tr>
<td align="left">enablePullDownRefresh</td>
<td align="left">false</td>
<td align="left">是否开启下拉刷新，详见<a href="https://uniapp.dcloud.io/use?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">页面生命周期</a>。</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">onReachBottomDistance</td>
<td align="left">50</td>
<td align="left">页面上拉触底事件触发时距页面底部距离，单位只支持px，详见<a href="https://uniapp.dcloud.io/use?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">页面生命周期</a></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">backgroundColorTop</td>
<td align="left">#ffffff</td>
<td align="left">顶部窗口的背景色（bounce回弹区域）</td>
<td align="left">仅 iOS 平台</td>
</tr>
</tbody></table>
<p>注意<code>pages:</code>中的局部样式会覆盖全局配置</p>
<p><strong>新建页面及配置</strong></p>
<p>创建Message.vue,并在page.json中配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;: [ //pages数组中第一项表示应用启动页,</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;pages/main/main&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;style&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;登录模板&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;, </span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;path&quot;</span>: <span class="string">&quot;pages/others/Message&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;style&quot;</span>: &#123;</span><br><span class="line">				<span class="attr">&quot;navigationBarTitleText&quot;</span>: <span class="string">&quot;消息&quot;</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br></pre></td></tr></table></figure>

<h3 id="tabbar导航栏配置"><a href="#tabbar导航栏配置" class="headerlink" title="tabbar导航栏配置"></a>tabbar导航栏配置</h3><p><strong>Tips</strong></p>
<ul>
<li>顶部的tabbar不会显示图标</li>
<li>tabbar最少有2个,最多5个</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">		&quot;color&quot;: &quot;#7a7e83&quot;,</span><br><span class="line">		&quot;selectedColor&quot;: &quot;#0faeff&quot;,</span><br><span class="line">		&quot;backgroundColor&quot;: &quot;#ffffff&quot;,</span><br><span class="line">		&quot;list&quot;: [&#123;</span><br><span class="line">			&quot;pagePath&quot;: &quot;pages/main/main&quot;,</span><br><span class="line">			&quot;text&quot;: &quot;首页&quot;,</span><br><span class="line">			&quot;iconPath&quot;: &quot;static/img/home.png&quot;,</span><br><span class="line">			&quot;selectedIconPath&quot;: &quot;static/img/homeHL.png&quot;</span><br><span class="line">		&#125;, &#123;</span><br><span class="line">			&quot;pagePath&quot;: &quot;pages/user/user&quot;,</span><br><span class="line">			&quot;text&quot;: &quot;我的&quot;,</span><br><span class="line">			&quot;iconPath&quot;: &quot;static/img/user.png&quot;,</span><br><span class="line">			&quot;selectedIconPath&quot;: &quot;static/img/userHL.png&quot;</span><br><span class="line">		&#125;]</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>属性说明: </p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">必填</th>
<th align="left">默认值</th>
<th align="left">描述</th>
<th align="left">平台差异说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">color</td>
<td align="left">HexColor</td>
<td align="left">是</td>
<td align="left"></td>
<td align="left">tab 上的文字默认颜色</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">selectedColor</td>
<td align="left">HexColor</td>
<td align="left">是</td>
<td align="left"></td>
<td align="left">tab 上的文字选中时的颜色</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">backgroundColor</td>
<td align="left">HexColor</td>
<td align="left">是</td>
<td align="left"></td>
<td align="left">tab 的背景色</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">borderStyle</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">black</td>
<td align="left">tabbar 上边框的颜色，可选值 black/white</td>
<td align="left">App 2.3.4+ 支持其他颜色值</td>
</tr>
<tr>
<td align="left">blurEffect</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">none</td>
<td align="left">iOS 高斯模糊效果，可选值 dark/extralight/light/none（参考:<a href="https://ask.dcloud.net.cn/article/36617">使用说明</a>）</td>
<td align="left">App 2.4.0+ 支持</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">Array</td>
<td align="left">是</td>
<td align="left"></td>
<td align="left">tab 的列表，详见 list 属性说明，最少2个、最多5个 tab</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">position</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">bottom</td>
<td align="left">可选值 bottom、top</td>
<td align="left">top 值仅微信小程序支持</td>
</tr>
</tbody></table>
<p>其中 list 接收一个数组，数组中的每个项都是一个对象，其属性值如下：</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">必填</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">pagePath</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">页面路径，必须在 pages 中先定义</td>
</tr>
<tr>
<td align="left">text</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">tab 上按钮文字，在 App 和 H5 平台为非必填。例如中间可放一个没有文字的+号图标</td>
</tr>
<tr>
<td align="left">iconPath</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片，不支持字体图标</td>
</tr>
<tr>
<td align="left">selectedIconPath</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效</td>
</tr>
</tbody></table>
<h3 id="condition启动模式配置"><a href="#condition启动模式配置" class="headerlink" title="condition启动模式配置"></a>condition启动模式配置</h3><p>启动模式配置,仅在开发期间起效,用于模拟直达页面的场景,如:小程序转发后,用户点击所打开的页面</p>
<p><strong>属性说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">是否必填</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">current</td>
<td align="left">Number</td>
<td align="left">是</td>
<td align="left">当前激活的模式，list节点的索引值</td>
</tr>
<tr>
<td align="left">list</td>
<td align="left">Array</td>
<td align="left">是</td>
<td align="left">启动模式列表</td>
</tr>
</tbody></table>
<p><strong>list说明：</strong></p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">类型</th>
<th align="left">是否必填</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">启动模式名称</td>
</tr>
<tr>
<td align="left">path</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left">启动页面路径</td>
</tr>
<tr>
<td align="left">query</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">启动参数，可在页面的 <a href="https://uniapp.dcloud.io/use?id=%E9%A1%B5%E9%9D%A2%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">onLoad</a> 函数里获得</td>
</tr>
</tbody></table>
<p><strong>注意：</strong> 在 App 里真机运行可直接打开配置的页面，微信开发者工具里需要手动改变编译模式，如下图：</p>
<p><img src="https://i.loli.net/2020/06/11/caeIW9SRomwNg3Z.png" alt="img"></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&quot;condition&quot;: &#123; //模式配置，仅开发期间生效</span><br><span class="line">    &quot;current&quot;: 0, //当前激活的模式（list 的索引项）</span><br><span class="line">    &quot;list&quot;: [&#123;</span><br><span class="line">            &quot;name&quot;: &quot;swiper&quot;, //模式名称</span><br><span class="line">            &quot;path&quot;: &quot;pages/component/swiper/swiper&quot;, //启动页面，必选</span><br><span class="line">            &quot;query&quot;: &quot;interval=4000&amp;autoplay=false&quot; //启动参数，在页面的onLoad函数里面得到。</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;path&quot;</span>: <span class="string">&quot;pages/component/switch/switch&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="text组件的使用"><a href="#text组件的使用" class="headerlink" title="text组件的使用"></a>text组件的使用</h3><p><strong>属性说明</strong></p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">selectable</td>
<td align="left">Boolean</td>
<td align="left">false</td>
<td align="left">文本是否可选</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">space</td>
<td align="left">String</td>
<td align="left"></td>
<td align="left">显示连续空格</td>
<td align="left">App、H5、微信小程序</td>
</tr>
<tr>
<td align="left">decode</td>
<td align="left">Boolean</td>
<td align="left">false</td>
<td align="left">是否解码</td>
<td align="left">App、H5、微信小程序</td>
</tr>
</tbody></table>
<p><strong>space 值说明</strong></p>
<table>
<thead>
<tr>
<th align="left">值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ensp</td>
<td align="left">中文字符空格一半大小</td>
</tr>
<tr>
<td align="left">emsp</td>
<td align="left">中文字符空格大小</td>
</tr>
<tr>
<td align="left">nbsp</td>
<td align="left">根据字体设置的空格大小</td>
</tr>
</tbody></table>
<p><strong>Tips</strong></p>
<ul>
<li><code>&lt;text&gt;</code> 组件内只支持嵌套 <code>&lt;text&gt;</code>，不支持其它组件或自定义组件，否则会引发在不同平台的渲染差异。。</li>
<li>decode 可以解析的有 <code> </code> <code>&lt;</code> <code>&gt;</code> <code>&amp;</code> <code>&#39;</code> <code> </code> <code> </code>。</li>
<li>各个操作系统的空格标准并不一致。</li>
<li>除了文本节点以外的其他节点都无法长按选中。</li>
<li>支持 <code>\n</code> 方式换行。</li>
<li>如果使用 <code>&lt;span&gt;</code> 组件编译时会被转换为 <code>&lt;text&gt;</code>。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-padding-wrap uni-common-mt&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;text-box&quot;</span> <span class="attr">scroll-y</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">text</span>&gt;</span>&#123;&#123;text&#125;&#125;<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-btn-v&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!canAdd&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>add line<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;warn&quot;</span> <span class="attr">:disabled</span>=<span class="string">&quot;!canRemove&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;remove&quot;</span>&gt;</span>remove line<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            texts: [</span><br><span class="line">                <span class="string">&#x27;HBuilder，200万开发者选择的IDE&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;MUI，轻巧、漂亮的前端开源框架&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;wap2app，M站快速转换原生体验的App&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;5+Runtime，为HTML5插上原生的翅膀&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;HBuilderX，轻巧、极速，极客编辑器&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;uni-app，终极跨平台方案&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;HBuilder，200万开发者选择的IDE&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;MUI，轻巧、漂亮的前端开源框架&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;wap2app，M站快速转换原生体验的App&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;5+Runtime，为HTML5插上原生的翅膀&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;HBuilderX，轻巧、极速，极客编辑器&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;uni-app，终极跨平台方案&#x27;</span>,</span><br><span class="line">                <span class="string">&#x27;......&#x27;</span></span><br><span class="line">            ],</span><br><span class="line">            text: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">            canAdd: <span class="literal">true</span>,</span><br><span class="line">            canRemove: <span class="literal">false</span>,</span><br><span class="line">            extraLine: []</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">this</span>.extraLine.push(<span class="built_in">this</span>.texts[<span class="built_in">this</span>.extraLine.length % <span class="number">12</span>]);</span><br><span class="line">            <span class="built_in">this</span>.text = <span class="built_in">this</span>.extraLine.join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">            <span class="built_in">this</span>.canAdd = <span class="built_in">this</span>.extraLine.length &lt; <span class="number">12</span>;</span><br><span class="line">            <span class="built_in">this</span>.canRemove = <span class="built_in">this</span>.extraLine.length &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.extraLine.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">this</span>.extraLine.pop();</span><br><span class="line">                <span class="built_in">this</span>.text = <span class="built_in">this</span>.extraLine.join(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">                <span class="built_in">this</span>.canAdd = <span class="built_in">this</span>.extraLine.length &lt; <span class="number">12</span>;</span><br><span class="line">                <span class="built_in">this</span>.canRemove = <span class="built_in">this</span>.extraLine.length &gt; <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://i.loli.net/2020/06/11/znE2sT6lgXtUIi8.png" alt="img" style="zoom: 50%;" />

<h3 id="view组件的使用"><a href="#view组件的使用" class="headerlink" title="view组件的使用"></a>view组件的使用</h3><p>视图容器。</p>
<p><strong>属性说明</strong></p>
<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">类型</th>
<th align="left">默认值</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">hover-class</td>
<td align="left">String</td>
<td align="left">none</td>
<td align="left">指定按下去的样式类。当 hover-class=”none” 时，没有点击态效果</td>
</tr>
<tr>
<td align="left">hover-stop-propagation</td>
<td align="left">Boolean</td>
<td align="left">false</td>
<td align="left">指定是否阻止本节点的祖先节点出现点击态</td>
</tr>
<tr>
<td align="left">hover-start-time</td>
<td align="left">Number</td>
<td align="left">50</td>
<td align="left">按住后多久出现点击态，单位毫秒</td>
</tr>
<tr>
<td align="left">hover-stay-time</td>
<td align="left">Number</td>
<td align="left">400</td>
<td align="left">手指松开后点击态保留时间，单位毫秒</td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-padding-wrap uni-common-mt&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-title uni-common-mt&quot;</span>&gt;</span></span><br><span class="line">                flex-direction: row</span><br><span class="line">                <span class="tag">&lt;<span class="name">text</span>&gt;</span>\n横向布局<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-flex uni-row&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item uni-bg-red&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item uni-bg-green&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item uni-bg-blue&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-title uni-common-mt&quot;</span>&gt;</span></span><br><span class="line">                flex-direction: column</span><br><span class="line">                <span class="tag">&lt;<span class="name">text</span>&gt;</span>\n纵向布局<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;uni-flex uni-column&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item flex-item-V uni-bg-red&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item flex-item-V uni-bg-green&quot;</span>&gt;</span>B<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">view</span> <span class="attr">class</span>=<span class="string">&quot;flex-item flex-item-V uni-bg-blue&quot;</span>&gt;</span>C<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong></p>
<ul>
<li>如果需要使用滚动视图，请使用 <a href="https://uniapp.dcloud.io/component/scroll-view">scroll-view</a></li>
<li>如果使用 <code>&lt;div&gt;</code> 组件编译时会被转换为 <code>&lt;view&gt;</code>。</li>
</ul>
<img src="https://gitee.com/hanzhengyu/picture-bed-2021/raw/master/20210428171437.png" style="zoom:50%;" />

<h3 id="uni-request-OBJECT"><a href="#uni-request-OBJECT" class="headerlink" title="uni.request(OBJECT)"></a>uni.request(OBJECT)</h3><p><a href="https://uniapp.dcloud.io/api/request/request?id=request">发起网络请求</a>。</p>
<blockquote>
<p>在各个小程序平台运行时，网络相关的 API 在使用前需要配置域名白名单。</p>
</blockquote>
<p><strong>OBJECT 参数说明</strong></p>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">类型</th>
<th align="left">必填</th>
<th align="left">默认值</th>
<th align="left">说明</th>
<th align="left">平台差异说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">url</td>
<td align="left">String</td>
<td align="left">是</td>
<td align="left"></td>
<td align="left">开发者服务器接口地址</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">data</td>
<td align="left">Object/String/ArrayBuffer</td>
<td align="left">否</td>
<td align="left"></td>
<td align="left">请求的参数</td>
<td align="left">App（自定义组件编译模式）不支持ArrayBuffer类型</td>
</tr>
<tr>
<td align="left">header</td>
<td align="left">Object</td>
<td align="left">否</td>
<td align="left"></td>
<td align="left">设置请求的 header，header 中不能设置 Referer。</td>
<td align="left">H5端会自动带上cookie不可手动覆盖</td>
</tr>
<tr>
<td align="left">method</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">GET</td>
<td align="left">有效值详见下方说明</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">Number</td>
<td align="left">否</td>
<td align="left">30000</td>
<td align="left">超时时间，单位 ms</td>
<td align="left">微信小程序（2.10.0）、支付宝小程序</td>
</tr>
<tr>
<td align="left">dataType</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">json</td>
<td align="left">如果设为 json，会尝试对返回的数据做一次 JSON.parse</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">responseType</td>
<td align="left">String</td>
<td align="left">否</td>
<td align="left">text</td>
<td align="left">设置响应的数据类型。合法值：text、arraybuffer</td>
<td align="left">App和支付宝小程序不支持</td>
</tr>
<tr>
<td align="left">sslVerify</td>
<td align="left">Boolean</td>
<td align="left">否</td>
<td align="left">true</td>
<td align="left">验证 ssl 证书</td>
<td align="left">仅App安卓端支持（HBuilderX 2.3.3+）</td>
</tr>
<tr>
<td align="left">withCredentials</td>
<td align="left">Boolean</td>
<td align="left">否</td>
<td align="left">false</td>
<td align="left">跨域请求时是否携带凭证（cookies）</td>
<td align="left">仅H5支持（HBuilderX 2.6.15+）</td>
</tr>
<tr>
<td align="left">success</td>
<td align="left">Function</td>
<td align="left">否</td>
<td align="left"></td>
<td align="left">收到开发者服务器成功返回的回调函数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">fail</td>
<td align="left">Function</td>
<td align="left">否</td>
<td align="left"></td>
<td align="left">接口调用失败的回调函数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">complete</td>
<td align="left">Function</td>
<td align="left">否</td>
<td align="left"></td>
<td align="left">接口调用结束的回调函数（调用成功、失败都会执行）</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>method 有效值</strong></p>
<p>必须大写，有效值在不同平台差异说明不同。</p>
<table>
<thead>
<tr>
<th align="center">method</th>
<th align="center">App</th>
<th align="center">H5</th>
<th align="center">微信小程序</th>
<th align="center">支付宝小程序</th>
<th align="center">百度小程序</th>
<th align="center">字节跳动小程序</th>
</tr>
</thead>
<tbody><tr>
<td align="center">GET</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">POST</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">PUT</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">DELETE</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">CONNECT</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">HEAD</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">OPTIONS</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">√</td>
<td align="center">x</td>
</tr>
<tr>
<td align="center">TRACE</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">x</td>
<td align="center">x</td>
<td align="center">x</td>
</tr>
</tbody></table>
<p><strong>success 返回参数说明</strong></p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">类型</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">data</td>
<td align="left">Object/String/ArrayBuffer</td>
<td align="left">开发者服务器返回的数据</td>
</tr>
<tr>
<td align="left">statusCode</td>
<td align="left">Number</td>
<td align="left">开发者服务器返回的 HTTP 状态码</td>
</tr>
<tr>
<td align="left">header</td>
<td align="left">Object</td>
<td align="left">开发者服务器返回的 HTTP Response Header</td>
</tr>
</tbody></table>
<p><strong>data 数据说明</strong></p>
<p>最终发送给服务器的数据是 String 类型，如果传入的 data 不是 String 类型，会被转换成 String。转换规则如下：</p>
<ul>
<li>对于 <code>GET</code> 方法，会将数据转换为 query string。例如 <code>&#123; name: &#39;name&#39;, age: 18 &#125;</code> 转换后的结果是 <code>name=name&amp;age=18</code>。</li>
<li>对于 <code>POST</code> 方法且 <code>header[&#39;content-type&#39;]</code> 为 <code>application/json</code> 的数据，会进行 JSON 序列化。</li>
<li>对于 <code>POST</code> 方法且 <code>header[&#39;content-type&#39;]</code> 为 <code>application/x-www-form-urlencoded</code> 的数据，会将数据转换为 query string。</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">uni.request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://www.example.com/request&#x27;</span>, <span class="comment">//仅为示例，并非真实接口地址。</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        text: <span class="string">&#x27;uni.request&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    header: &#123;</span><br><span class="line">        <span class="string">&#x27;custom-header&#x27;</span>: <span class="string">&#x27;hello&#x27;</span> <span class="comment">//自定义请求头信息</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">        <span class="built_in">this</span>.text = <span class="string">&#x27;request success&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong></p>
<p>如果希望返回一个 <code>requestTask</code> 对象，需要至少传入 success / fail / complete 参数中的一个。例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> requestTask = uni.request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://www.example.com/request&#x27;</span>, <span class="comment">//仅为示例，并非真实接口地址。</span></span><br><span class="line">    complete: <span class="function">()=&gt;</span> &#123;&#125;</span><br><span class="line">&#125;);</span><br><span class="line">requestTask.abort();</span><br></pre></td></tr></table></figure>

<p>如果没有传入 success / fail / complete 参数，则会返回封装后的 Promise 对象：<a href="https://uniapp.dcloud.io/api/README?id=promise-%E5%B0%81%E8%A3%85">Promise 封装</a></p>
<p>通过 <code>requestTask</code>，可中断请求任务。</p>
<p><strong>requestTask 对象的方法列表</strong></p>
<table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">参数</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">abort</td>
<td align="left"></td>
<td align="left">中断请求任务</td>
</tr>
<tr>
<td align="left">offHeadersReceived</td>
<td align="left"></td>
<td align="left">取消监听 HTTP Response Header 事件，仅<code>微信小程序平台</code>支持，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/RequestTask.offHeadersReceived.html">文档详情</a></td>
</tr>
<tr>
<td align="left">onHeadersReceived</td>
<td align="left"></td>
<td align="left">监听 HTTP Response Header 事件。会比请求完成事件更早，仅<code>微信小程序平台</code>支持，<a href="https://developers.weixin.qq.com/miniprogram/dev/api/RequestTask.onHeadersReceived.html">文档详情</a></td>
</tr>
</tbody></table>
<p><strong>示例</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> requestTask = uni.request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://www.example.com/request&#x27;</span>, <span class="comment">//仅为示例，并非真实接口地址。</span></span><br><span class="line">    data: &#123;</span><br><span class="line">        name: <span class="string">&#x27;name&#x27;</span>,</span><br><span class="line">        age: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中断请求任务</span></span><br><span class="line">requestTask.abort();</span><br></pre></td></tr></table></figure>

<p><strong>Tips</strong></p>
<ul>
<li>请求的 <code>header</code> 中 <code>content-type</code> 默认为 <code>application/json</code>。</li>
<li>网络请求的 <code>超时时间</code> 可以统一在 <code>manifest.json</code> 中配置 <a href="https://uniapp.dcloud.io/collocation/manifest?id=networktimeout">networkTimeout</a>。</li>
<li>H5 端本地调试需注意跨域问题，参考：<a href="https://ask.dcloud.net.cn/article/35267">调试跨域问题解决方案</a></li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">manifest.json-&gt;源码视图中添加</span><br><span class="line">&quot;h5&quot; : &#123;</span><br><span class="line">        &quot;devServer&quot; : &#123;</span><br><span class="line">            &quot;port&quot; : 8849,</span><br><span class="line">			&quot;disableHostCheck&quot; : true,</span><br><span class="line">			&quot;proxy&quot; : &#123;</span><br><span class="line">				&quot;/api&quot; : &#123;</span><br><span class="line">					&quot;target&quot; : &quot;http://localhost:9002&quot;,</span><br><span class="line">					&quot;changeOrigin&quot; : true,</span><br><span class="line">					&quot;secure&quot; : false,</span><br><span class="line">					&quot;pathRewrite&quot; : &#123;</span><br><span class="line">						&quot;^/api&quot; : &quot;/&quot;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h3 id="Promise-封装"><a href="#Promise-封装" class="headerlink" title="Promise 封装"></a>Promise 封装</h3><p>uni-app 对部分 API 进行了 Promise 封装，返回数据的第一个参数是错误对象，第二个参数是返回数据。</p>
<p>详细策略如下：</p>
<ul>
<li>异步的方法，如果不传入 success、fail、complete 等 callback 参数，将以 Promise 返回数据。例如：uni.getImageInfo()</li>
<li>异步的方法且有返回对象，如果希望获取返回对象，必须至少传入一项 success、fail、complete 等 callback 参数。例如：uni.connectSocket()</li>
<li>同步的方法（即以 sync 结束），不封装 Promise。例如：uni.getSystemInfoSync()</li>
<li>以 create 开头的方法，不封装 Promise。例如：uni.createMapContext()</li>
<li>以 manager 结束的方法，不封装 Promise。例如：uni.getBackgroundAudioManager()</li>
</ul>
<p>使用示例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认方式</span></span><br><span class="line">uni.request(&#123;</span><br><span class="line">    url: <span class="string">&#x27;https://www.example.com/request&#x27;</span>,</span><br><span class="line">    success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise</span></span><br><span class="line">uni.request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;https://www.example.com/request&#x27;</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;<span class="comment">//data为一个数组，数组第一项为错误信息，第二项为返回数据</span></span><br><span class="line">        <span class="keyword">var</span> [error, res]  = data;</span><br><span class="line">        <span class="built_in">console</span>.log(res.data);</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Await</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">async</span> <span class="title">request</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> [error, res] = <span class="keyword">await</span> uni.request(&#123;</span><br><span class="line">        url: <span class="string">&#x27;https://www.example.com/request&#x27;</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(res.data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h5><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://uniapp.dcloud.io/api/request/request?id=request">uni.request</a></td>
<td align="left">发起网络请求</td>
</tr>
</tbody></table>
<h5 id="上传、下载"><a href="#上传、下载" class="headerlink" title="上传、下载"></a>上传、下载</h5><table>
<thead>
<tr>
<th align="left">API</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://uniapp.dcloud.io/api/request/network-file?id=uploadfile">uni.uploadFile</a></td>
<td align="left">上传文件</td>
</tr>
<tr>
<td align="left"><a href="https://uniapp.dcloud.io/api/request/network-file?id=downloadfile">uni.downloadFile</a></td>
<td align="left">下载文件</td>
</tr>
</tbody></table>
<p><a href="https://uniapp.dcloud.io/api/README?id=promise-%E5%B0%81%E8%A3%85">API列表</a></p>
<h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度 非常快，性能非常好。</p>
<p>下载官网：<a href="https://nodejs.org/en/">https://nodejs.org/en/</a> </p>
<p>中文网：<a href="http://nodejs.cn/">http://nodejs.cn/</a> </p>
<p>LTS：长期支持版本 </p>
<p>Current：最新版</p>
<p>浏览器的内核包括两部分核心： </p>
<ul>
<li>DOM渲染引擎； </li>
<li>js解析器（js引擎） </li>
<li>js运行在浏览器中的内核中的js引擎内部 Node.js是脱离浏览器环境运行的JavaScript程序，基于V8 引擎（Chrome 的 JavaScript的引擎）</li>
</ul>
<p>服务器端应用开发:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>)</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 发送HTTP头部</span></span><br><span class="line">    <span class="comment">// HTTP状态值: 200 OK</span></span><br><span class="line">    <span class="comment">// 内容类型: text/plain</span></span><br><span class="line">    response.writeHead(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span>&#125;);</span><br><span class="line">    <span class="comment">// 发送响应数据 &#x27;Hello World&#x27;</span></span><br><span class="line">    response.end(<span class="string">&#x27;Hello World&#x27;</span>);</span><br><span class="line">&#125;).listen(<span class="number">8888</span>);</span><br><span class="line"><span class="comment">// 终端打印如下信息</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;&#x27;Server running at http://127.0.0.1:8888/&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行服务程序: <code>node server-app.js</code></p>
<p>服务器启动成功后，在浏览器中输入：<a href="http://localhost:8888/">http://localhost:8888/</a> 查看webserver成功运行，并输出html页面 停止服务：ctrl + c</p>
<h2 id="vue-element-admin"><a href="#vue-element-admin" class="headerlink" title="vue-element-admin"></a>vue-element-admin</h2><p>vue-element-admin是基于element-ui 的一套后台管理系统集成方案。</p>
<p>文档：<a href="https://panjiachen.github.io/vue-element-admin-site/zh/guide/#%E5%8A%9F%E8%83%BD">https://panjiachen.github.io/vue-element-admin-site/zh/guide/#功能</a></p>
<p>GitHub地址：<a href="https://github.com/PanJiaChen/vue-element-admin">https://github.com/PanJiaChen/vue-element-admin</a> </p>
<p>在线预览：<a href="https://panjiachen.gitee.io/vue-element-admin">https://panjiachen.gitee.io/vue-element-admin</a></p>
<p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压压缩包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd vue-element-admin-master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动。执行后，浏览器自动弹出并访问http://localhost:9527/</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p><strong>vue-admin-template</strong></p>
<p>是基于vue-element-admin的一套后台管理系统基础模板（最少精简版），可作为模 板进行二次开发。 </p>
<p>GitHub地址：<a href="https://github.com/PanJiaChen/vue-admin-template">https://github.com/PanJiaChen/vue-admin-template</a> </p>
<p>建议：你可以在 vue-admin-template 的基础上进行二次开发，把 vue-element-admin当做工具箱，想要什么 功能或者组件就去 vue-element-admin 那里复制过来。</p>
<p><strong>安装</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 克隆项目</span></span><br><span class="line">git clone https://github.com/PanJiaChen/vue-admin-template.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd vue-admin-template-master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装依赖</span></span><br><span class="line">npm install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动。执行后，浏览器自动弹出并访问http://localhost:9528/</span></span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>

<p>修改config/index.js </p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不使用Eslint</span></span><br><span class="line">useEslint: <span class="literal">false</span>,</span><br></pre></td></tr></table></figure>

<p>config/dev.env.js中定义了API访问路径</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = merge(prodEnv, &#123;</span><br><span class="line">  NODE_ENV: <span class="string">&#x27;&quot;development&quot;&#x27;</span>,</span><br><span class="line">  BASE_API: <span class="string">&#x27;&quot;https://easy-mock.com/mock/5950a2419adc231f356a6636/vue-admin&quot;&#x27;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
