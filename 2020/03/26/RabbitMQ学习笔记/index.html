<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/cat.jpg">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/cat.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/cat.jpg">
  <link rel="mask-icon" href="/images/cat.jpg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"growup-hzy.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="RabbitMQ大多应用中,可以通过消息服务中间件来提升系统异步通信,拓展解耦能力 消息服务中两个重要概念:  **消息代理(message broker) **  目的地(destination)   当消息发送者发送消息以后,将由消息代理接管,消息代理保证消息传递到指定目的地. 消息队列主要有两种形式的目的地,对应两种通信方式:  **队列(queue):**点对点消息通信(point-to-">
<meta property="og:type" content="article">
<meta property="og:title" content="RabbitMQ学习笔记">
<meta property="og:url" content="https://growup-hzy.github.io/2020/03/26/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="煜虚人渊">
<meta property="og:description" content="RabbitMQ大多应用中,可以通过消息服务中间件来提升系统异步通信,拓展解耦能力 消息服务中两个重要概念:  **消息代理(message broker) **  目的地(destination)   当消息发送者发送消息以后,将由消息代理接管,消息代理保证消息传递到指定目的地. 消息队列主要有两种形式的目的地,对应两种通信方式:  **队列(queue):**点对点消息通信(point-to-">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2020/05/16/4Kc9AqTyrR28wlM.png">
<meta property="og:image" content="https://i.loli.net/2020/07/02/FdftApo9y8eu3ms.png">
<meta property="og:image" content="d:/study/Markdown/images/FHCNqzekvLl8jBX.png">
<meta property="og:image" content="https://i.loli.net/2020/07/03/cd2OwDpFlTIHCUj.png">
<meta property="og:image" content="https://i.loli.net/2020/07/03/KPQEMhxgL6qe5m1.png">
<meta property="og:image" content="https://i.loli.net/2020/07/01/9kqbnH6uVGvh1jE.png">
<meta property="og:image" content="https://i.loli.net/2020/07/04/lCcxyu75zB9Jm8f.png">
<meta property="og:image" content="https://i.loli.net/2020/07/04/e5BYpEGWguiQSRZ.png">
<meta property="og:image" content="https://i.loli.net/2020/07/04/cDnTC5M2sZBqxtP.png">
<meta property="og:image" content="https://i.loli.net/2020/07/07/MDodcWSTBwZ8bKe.png">
<meta property="article:published_time" content="2020-03-26T07:50:00.000Z">
<meta property="article:modified_time" content="2021-04-02T06:55:33.687Z">
<meta property="article:author" content="hzy">
<meta property="article:tag" content="Hexo">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="软件开发">
<meta property="article:tag" content="github">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2020/05/16/4Kc9AqTyrR28wlM.png">

<link rel="canonical" href="https://growup-hzy.github.io/2020/03/26/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>RabbitMQ学习笔记 | 煜虚人渊</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">煜虚人渊</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个不断成长的Java开发人员</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://growup-hzy.github.io/2020/03/26/RabbitMQ%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/cat.jpg">
      <meta itemprop="name" content="hzy">
      <meta itemprop="description" content="记录学习的过程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="煜虚人渊">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          RabbitMQ学习笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-03-26 15:50:00" itemprop="dateCreated datePublished" datetime="2020-03-26T15:50:00+08:00">2020-03-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-02 14:55:33" itemprop="dateModified" datetime="2021-04-02T14:55:33+08:00">2021-04-02</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MQ/" itemprop="url" rel="index"><span itemprop="name">MQ</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><p>大多应用中,可以通过消息服务中间件来提升系统<strong>异步通信,拓展解耦</strong>能力</p>
<p>消息服务中两个重要概念:</p>
<ul>
<li><p>**消息代理(message broker) **</p>
</li>
<li><p><strong>目的地(destination)</strong></p>
</li>
</ul>
<p>当消息发送者发送消息以后,将由消息代理接管,消息代理保证消息传递到指定目的地.</p>
<p>消息队列主要有两种形式的目的地,对应两种通信方式:</p>
<ul>
<li>**队列(queue):**点对点消息通信(point-to-point)</li>
<li>**主题(topic):**发布(publish) 订阅(subscribe) 消息通信</li>
</ul>
<a id="more"></a>

<p><strong>点对点式:</strong></p>
<p>消息发送者发送消息,消息代理将其放入一个队列中,消息接收者从中获取消息内容,消息读取后被移出队列;消息只有唯一的发送者和接受者,但并不是说只能有一个接收者.(多个接收者来拿这个消息,只能有一个拿到)</p>
<p><strong>发布订阅式:</strong></p>
<p>发送者发布消息到主题,多个接收者订阅这个主题,那么就会在消息到达时同时收到消息.</p>
<p><strong>JMS(Java Message Service) JAVA消息服务:</strong></p>
<p>基于JVM消息代理的规范. ActiveMQ.HornetMQ是JMS实现</p>
<p><strong>AMQP(Advanced Message Queuing Protocol):</strong></p>
<p>高级消息队列协议,也是消息代理的规范,兼容JMS,RabbitMQ是AMQP的实现</p>
<p><strong>spring-jms和spring-rabbit提供了以上两种规范的支持</strong></p>
<ul>
<li><p>需要<code>ConnectionFactory</code>的实现来连接消息代理</p>
</li>
<li><p>提供<code>JmsTemplate,RabbitTemplate</code>来发送消息</p>
</li>
<li><p><code>@JmsListener,@RabbitListener</code>注解在方法上监听消息代理发布的消息</p>
</li>
<li><p><code>@EnableJms,@EnableRabbit</code>开启支持</p>
</li>
<li><p>自动配置类:<code> JmsAutoConfiguration,RabbitAutoConfiguration</code></p>
</li>
</ul>
<p><strong>RabbitMQ是由erlang开发的AMQP的开源实现</strong></p>
<h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a><strong>核心概念</strong></h2><ul>
<li><p><strong>Message</strong></p>
<p>消息,消息是不具名的,它由消息头和消息体组成;消息体是不透明的,而消息头则由一系列的可选属性组成,这些属性包括routing-key(路由键),priority(相对于其他消息的优先权),delivery-mode(指出该消息可能需要持久化存储)等.</p>
</li>
<li><p><strong>Publisher</strong></p>
<p>消息的生产者,也是一个向交换器发布消息的客户端程序.</p>
</li>
<li><p><strong>Exchange</strong></p>
<p>交换器,用来接收生产者发送的消息,并将这些消息路由给服务器中的队列;<strong>Exchange有4种类型</strong>,不同类型的Exchange转发消息的策略有所区别.</p>
<ul>
<li>direct(默认):通过指定路由键点对点方式与队列绑定</li>
<li>fanout:广播模式,将消息发送到所有队列</li>
<li>topic:允许对路由键制定模糊匹配,单词之间用点隔开,#匹配0个或多个单词,*匹配一个单词</li>
<li>headers 和默认基本一致,且性能不佳</li>
</ul>
</li>
<li><p><strong>Queue</strong></p>
<p>消息队列,用来保存消息直到发送给消费者;它是消息的容器,也是消息的终点;一个消息可投入一个或多个队列;消息一直在队列里面,等待消费者连接到这个队列将其取走.</p>
</li>
<li><p><strong>Binding</strong></p>
<p>绑定,用于消息队列和交换器之间的关联;一个绑定器就是基于路由键将交换器和消息队列连接起来的路由规则,所以可以将交换器理解成一个由绑定构成的路由表.Exchange和Queue的绑定可以是多对多的关系.</p>
</li>
<li><p><strong>Connection</strong></p>
<p>网络连接,比如一个TCP连接.</p>
</li>
<li><p><strong>Channel</strong></p>
<p>信道,多路复用连接中的一条独立的双向数据流通道;信道是建立在真实的TCP连接内的虚拟连接,AMQP命令都是通过信道发送出去的,不管是发布消息,订阅队列还是接收消息,这些动作由是通过信道完成;因为对于操作系统来说建立和销毁TCP都是非常昂贵的开销,所以引入了信道的概念,以复用一条TCP连接.</p>
</li>
<li><p><strong>Consumer</strong></p>
<p>消息的消费者,表示一个从消息队列中取得消息的客户端应用程序.</p>
</li>
<li><p><strong>Virtual Host</strong></p>
<p>虚拟主机,表示一批交换器,消息队列和相关对象;虚拟主机是共享相同的身份认证和加密环境的独立服务器域;每个vhost本质上就是一个mini版的RabbitMQ服务器,拥有自己的队列,交换器,绑定和权限机制;vhost是AMQP概念的基础,必须在连接时指定,RabbitMQ默认的vhost是<code>/</code>.</p>
</li>
<li><p><strong>Broker</strong></p>
<p>表示消息队列服务器实体</p>
<p><img src="https://i.loli.net/2020/05/16/4Kc9AqTyrR28wlM.png" alt="broker 2020-03-27 131401"></p>
</li>
</ul>
<h2 id="安装RabbitMQ"><a href="#安装RabbitMQ" class="headerlink" title="安装RabbitMQ"></a>安装RabbitMQ</h2><p>rabbitmq和erlang版本对照:<a target="_blank" rel="noopener" href="https://www.rabbitmq.com/which-erlang.html">https://www.rabbitmq.com/which-erlang.html</a></p>
<p><strong>windows</strong></p>
<ul>
<li><p><strong>下载erlang</strong>:<a target="_blank" rel="noopener" href="http://erlang.org/download/otp_win64__21.3.exe">http://erlang.org/download/otp_win64__21.3.exe</a></p>
</li>
<li><p><strong>下载rbbitmq</strong>:<a target="_blank" rel="noopener" href="https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe">https://dl.bintray.com/rabbitmq/all/rabbitmq-server/3.7.14/rabbitmq-server-3.7.14.exe</a></p>
</li>
<li><p>在rabbitmq/sbin目录下执行<code>  set ERLANG_HOME=erlang的安装路径</code><strong>设置erlang环境变量</strong></p>
</li>
<li><p><strong>并输入以下命令启动管理功能</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmq-plugins enable rabbitmq_management</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>使用rabbitmq Service -start.exe程序启动</strong></p>
</li>
<li><p>访问:<a target="_blank" rel="noopener" href="http://localhost:15672/">http://localhost:15672/</a> 账号密码:guest guest</p>
</li>
</ul>
<p><strong>Linux</strong></p>
<ul>
<li><p>准备：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc-c++ kernel-devel m4 ncurses-devel tk tc xz</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载&amp;安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line">wget http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</span><br><span class="line">wget www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先安装erlang</span></span><br><span class="line">rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash">socat密钥</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm </span><br><span class="line"><span class="meta">#</span><span class="bash">然后rabbitmq-server</span></span><br><span class="line">rpm -ivh socat-1.7.3.2-1.1.el7.x86_64.rpm </span><br></pre></td></tr></table></figure>
</li>
<li><p>配置文件：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app</span><br><span class="line">比如修改密码、配置等等，例如：loopback_users 中的 &lt;&lt;&quot;guest&quot;&gt;&gt;,删除尖括号和引号只保留[guest]</span><br></pre></td></tr></table></figure>

<p>env下可修改端口号等环境变量:</p>
<p><img src="https://i.loli.net/2020/07/02/FdftApo9y8eu3ms.png" alt="image-20200702120334702"></p>
</li>
<li><p>服务启动和停止：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">启动 rabbitmq-server start &amp;</span><br><span class="line">停止 rabbitmqctl stop_app</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>启用管理插件：<code>rabbitmq-plugins enable rabbitmq_management</code><br>访问地址：<a target="_blank" rel="noopener" href="http://192.168.107.132:15672/">http://192.168.107.132:15672/</a></p>
<p>如果启动失败可查看端口占用情况: <code>lsof -i:5672</code></p>
<h2 id="命令行与管控台操作"><a href="#命令行与管控台操作" class="headerlink" title="命令行与管控台操作"></a>命令行与管控台操作</h2><ul>
<li><p>服务启动: <code>rabbitmqctl start_app</code></p>
</li>
<li><p>服务停止: <code>rabbitmqctl stop_app</code></p>
</li>
<li><p>节点状态: <code>rabbitmqctl status</code></p>
</li>
<li><p>创建虚拟主机: <code>rabbitmqctl add_vhost &lt; vhostpath &gt;</code></p>
</li>
<li><p>查看所有虚拟主机:<code> rabbitmqctl list_vhosts</code></p>
</li>
<li><p>查看所有队列: <code>rabbitmqctl list_queues</code></p>
</li>
<li><p>清除队列里的消息: <code>rabbitmqctl -p vhostpath purge_queue blue</code></p>
</li>
<li><p>移除所有数据: <code>rabbitmqctl reset</code> (要在服务停止之后使用)</p>
</li>
<li><p>组成集群命令: <code>rabbitmqctl join_cluster &lt; clusternode&gt; [--ram]</code>存储模式</p>
</li>
<li><p>修改集群节点的存储模式: <code>rabbitmqctl change_cluster_node_type disc | ram</code></p>
</li>
<li><p>摘除节点:<code>rabbitmqctl forget_cluster_node [--offline]</code></p>
</li>
</ul>
<p>管控台可以管理监控 连接(Connections),信道(Channels),交换器(Exchanges),队列(Queues) ;</p>
<p>Admin中可监控和添加虚拟主机(Virtual Host)</p>
<h2 id="与springboot整合"><a href="#与springboot整合" class="headerlink" title="与springboot整合"></a>与springboot整合</h2><p>创建springboot项目选择依赖web,rabbitMQ</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--rabbitMQ--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>spring-boot-starter-amqp</code>引入了<code>spring-messaging</code>, <code>spring-rabbit</code></p>
<p>自动配置类:<code>RabbitAutoConfiguration</code></p>
<p>配置了<code>rabbitConnectionFactory</code>连接工厂</p>
<p><code>RabbitPtoperties</code>封装了RabbitMQ的配置</p>
<p><code>RabbitTemplate</code>用来发送和接受消息</p>
<p><code>AmqpAdmin</code>RabbitMQ系统管理功能组件</p>
<p><strong>相关配置</strong>:</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#rabbit主机地址</span></span><br><span class="line"><span class="meta">spring.rabbitmq.host</span>=<span class="string">192.168.107.108</span></span><br><span class="line"><span class="comment">#用户名 密码 端口</span></span><br><span class="line"><span class="meta">spring.rabbitmq.username</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.password</span>=<span class="string">guest</span></span><br><span class="line"><span class="meta">spring.rabbitmq.port</span>=<span class="string">5672</span></span><br><span class="line"><span class="comment">#虚拟主机地址</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="comment"># 支持发布确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 支持发布返回</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-returns</span>=<span class="string">false</span></span><br><span class="line"><span class="comment"># 虚拟主机名称</span></span><br><span class="line"><span class="meta">spring.rabbitmq.virtual-host</span>=<span class="string">/</span></span><br><span class="line"><span class="comment"># 采用手动应答</span></span><br><span class="line"><span class="comment"># spring.rabbitmq.listener.acknowledge-mode=manual</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mq-api</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.107</span><span class="number">.132</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line">    <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">      <span class="attr">listener:</span></span><br><span class="line">        <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动ack</span></span><br></pre></td></tr></table></figure>

<p>在测试类中注入<code>RabbitTemplate</code>,有<strong>两种发送消息的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Message需要自己构造,可定制消息体内容和消息头</span></span><br><span class="line">rabbitTemplate.send(exchange,routeKey,message);</span><br><span class="line"></span><br><span class="line"><span class="comment">//object默认作为消息体,只需要传入要发送的对象,自动序列化发送给rabbitmq</span></span><br><span class="line">rabbitTemplate.convertAndSend(exchange,routeKey,object);</span><br></pre></td></tr></table></figure>

<p>使用<code>AmqpAdmin</code>组件可以编码的方式创建和管理<strong>Queue,Bindings以及Exchange</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * declareXXX()用来创建组件</span></span><br><span class="line"><span class="comment">     * removeXXX(),deleteXXX()用来删除</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AmqpAdmin amqpAdmin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Exchange</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createExchange</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//传入对应类型的实现类</span></span><br><span class="line">        amqpAdmin.declareExchange(<span class="keyword">new</span> DirectExchange(<span class="string">&quot;amqpadmin.exchange&quot;</span>));</span><br><span class="line">        System.out.println(<span class="string">&quot;创建完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建Queue</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//名字 是否持久化</span></span><br><span class="line">        amqpAdmin.declareQueue(<span class="keyword">new</span> Queue(<span class="string">&quot;amqpadmin.queue&quot;</span>,<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建绑定规则</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBindings</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//绑定目的地 目的地类型 Exchange Routing key 参数</span></span><br><span class="line">        amqpAdmin.declareBinding(<span class="keyword">new</span> Binding(<span class="string">&quot;amqpadmin.queue&quot;</span>, 	                                       Binding.DestinationType.QUEUE,</span><br><span class="line">                  <span class="string">&quot;amqpadmin.exchange&quot;</span>,<span class="string">&quot;amqp.haha&quot;</span>,<span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Exchange接口的实现类</strong>:</p>
<p><img src="D:\study\Markdown\images\FHCNqzekvLl8jBX.png" alt="image-20200514172523355"></p>
<p><strong>例子</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 点对点方式 发送</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextLoads</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">       map.put(<span class="string">&quot;msg&quot;</span>,<span class="string">&quot;这是第一个消息&quot;</span>);</span><br><span class="line">       map.put(<span class="string">&quot;data&quot;</span>, Arrays.asList(<span class="string">&quot;helloWorld&quot;</span>,<span class="number">123</span>,<span class="keyword">true</span>));</span><br><span class="line">       <span class="comment">//对象被默认序列化后发送出去</span></span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.direct&quot;</span>,<span class="string">&quot;user.news&quot;</span>,map);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 接收消息</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Object o = rabbitTemplate.receiveAndConvert(<span class="string">&quot;user.news&quot;</span>);</span><br><span class="line">       System.out.println(o.getClass());</span><br><span class="line">       System.out.println(o);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 广播</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">       rabbitTemplate.convertAndSend(<span class="string">&quot;exchange.fanout&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="keyword">new</span> Book(<span class="string">&quot;三国演义&quot;</span>,<span class="string">&quot;罗贯中&quot;</span>));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>JSON序列化</strong>:</p>
<p><code>RabbitTemplate</code>中的<code>MessageConverter</code>的实现默认为<code>SimpleMessageConverter</code>也就是jdk序列化的方式</p>
<p>将<code>MessageConverter</code>的实现改成<code>Jackson2JsonMessageConverter</code>,数据就会以JSON的格式发送了</p>
<p>==注意实现Serializable接口==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.support.converter.MessageConverter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyAMQPConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">messageConverter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//或者</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageConverter <span class="title">jsonMessageConverter</span><span class="params">(ObjectMapper objectMapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Jackson2JsonMessageConverter(objectMapper);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@RabbitListener</code><strong>监听队列自动接收消息</strong></p>
<p>在<strong>启动类</strong>加上<code>@EnableRabbit</code>注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;</span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BookService</span> </span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 监听指定的队列,多个用逗号分隔</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;user.news&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive</span><span class="params">(Book book)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;收到消息: &quot;</span>+book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * message对象可获得消息头和消息体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RabbitListener(queues = &quot;user&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">receive02</span><span class="params">(Message message)</span></span>&#123;</span><br><span class="line">        System.out.println(message.getBody());</span><br><span class="line">        System.out.println(message.getMessageProperties());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="构建生产者-amp-消费者"><a href="#构建生产者-amp-消费者" class="headerlink" title="构建生产者&amp;消费者"></a>构建生产者&amp;消费者</h2><h3 id="原生API"><a href="#原生API" class="headerlink" title="原生API"></a>原生API</h3><ul>
<li><p><strong>消费者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String queueName = <span class="string">&quot;test001&quot;</span>;</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//设置channel 队列名称, autoAck, consumer</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line">        <span class="comment">//在Broker接收到该Consumer的ack前,</span></span><br><span class="line">        <span class="comment">//Consumer在同一个时间点最多被分配qos个Message</span></span><br><span class="line">        channel.basicQos(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拓展DefaultConsumer</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>(channel);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理消息的逻辑</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">                System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动消费者后查看管控台,发现connection,channel已成功连接,队列已成功创建</p>
</li>
<li><p><strong>生产者</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</span><br><span class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line">        <span class="comment">//使用默认exchange 发布消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// exchange, routeKey, properties, message</span></span><br><span class="line">            channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test001&quot;</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">            System.out.println(<span class="string">&quot;发送消息: &quot;</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="comment">//关闭资源</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>测试</strong></p>
<ul>
<li>启动消费者后运行生产者,收到消息</li>
<li>运行生产者后消息未被消费,再启动消费者后收到消息</li>
</ul>
</li>
<li><p><strong>tip: QueueingConsumer已被废弃</strong></p>
<p>QueueingConsumer内部用LinkedBlockingQueue来存放消息的内容，而LinkedBlockingQueue：一个由链表结构组成的有界队列，照先进先出的顺序进行排序 ，未指定长度的话，默认 此队列的长度为Integer.MAX_VALUE，那么问题来了，如果生产者的速度远远大于消费者的速度，也许没等到队列阻塞的条件产生（长度达到Integer.MAX_VALUE）内存就完蛋了，在老的版本你可以通过设置 rabbitmq的prefetch属性channel.basicQos(prefetch)来处理这个问题如果不设置可能出现内存问题（比如因为网络问题只能向rabbitmq生产不能消费，消费者恢复网络之后就会有大量的数据涌入，出现内存问题,oom fgc等）。</p>
<p>而且写法很不合理不符合事件驱动，什么时候停止while循环也不能写的很优雅，所以在更高的版本直接被移除。取而代之的是DefaultConsumer，你可以通过扩展DefaultConsumer来实现消费者</p>
</li>
</ul>
<h3 id="spring-boot"><a href="#spring-boot" class="headerlink" title="spring-boot"></a><em>spring-boot</em></h3><ul>
<li><p><strong>消费者</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">mq-api</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="number">.107</span><span class="number">.132</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">    <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">    <span class="attr">template:</span></span><br><span class="line">      <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">      <span class="attr">listener:</span></span><br><span class="line">        <span class="attr">simple:</span></span><br><span class="line">          <span class="attr">acknowledge-mode:</span> <span class="string">manual</span> <span class="comment">#手动ack</span></span><br><span class="line">          <span class="attr">concurrency:</span> <span class="number">5</span> <span class="comment">#消费者的最小数量</span></span><br><span class="line">          <span class="attr">max-concurrency:</span> <span class="number">10</span> <span class="comment">#消费者的最大数量</span></span><br></pre></td></tr></table></figure>

<p>消费者核心注解: <code>@RabbitListener</code>, <code>@RabbitHandler</code></p>
<p>@RabbitListener是一个组合注解, 与@QueueBinding, @Queue, @Exchange 组合使用, 一次性搞定消费端交换机, 队列, 绑定, 路由, 并且配置监听功能等, ==配置信息建议从配置文件动态加载==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(bindings = @QueueBinding(</span></span><br><span class="line"><span class="meta">        value = @Queue(value = &quot;queue_1&quot;, durable = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        exchange = @Exchange(value = &quot;exchange_1&quot;,</span></span><br><span class="line"><span class="meta">                durable = &quot;true&quot;,</span></span><br><span class="line"><span class="meta">                type = &quot;topic&quot;,</span></span><br><span class="line"><span class="meta">                ignoreDeclarationExceptions = &quot;true&quot;),</span></span><br><span class="line"><span class="meta">        key = &quot;springboot.#&quot;</span></span><br><span class="line"><span class="meta">))</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(Message message, Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费端: &quot;</span> + <span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">    Long deliveryTag = message.getMessageProperties().getDeliveryTag();</span><br><span class="line">    <span class="comment">//手动ack</span></span><br><span class="line">    channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>@RabbitListener 可以标注在类上面，需配合 @RabbitHandler 注解一起使用</p>
<p>@RabbitListener 标注在类上面表示当有收到消息的时候，就交给 @RabbitHandler 的方法处理，具体使用哪个方法处理，根据 MessageConverter 转换后的参数类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@RabbitListener(queues = &quot;consumer_queue&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage1</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RabbitHandler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(<span class="keyword">byte</span>[] message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Payload</code>和<code>@Headers</code>注解用来指定消息体, 和接受消息头参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOrderMessage</span><span class="params">(<span class="meta">@Payload</span> OrderMessage orderMessage, Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="meta">@Headers</span> Map&lt;String, Object&gt; Headers)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;消费端: &quot;</span> + orderMessage.getContent());</span><br><span class="line">    Long deliveryTag = (Long) Headers.get(AmqpHeaders.DELIVERY_TAG);</span><br><span class="line">    <span class="comment">//手动ack</span></span><br><span class="line">    channel.basicAck(deliveryTag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>生产者</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line"><span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.MessageProperties;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RabbitTemplate.ConfirmCallback confirmCallback = <span class="keyword">new</span> RabbitTemplate.ConfirmCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步监听 消息是否到达 exchange</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> correlationData 包含消息的唯一标识的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> ack             true 标识 ack，false 标识 nack</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> cause           nack 的原因</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----confirmCallback-----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;correlationData: &quot;</span> + correlationData);</span><br><span class="line">            System.out.println(<span class="string">&quot;ack: &quot;</span> + ack);</span><br><span class="line">            System.out.println(<span class="string">&quot;cause: &quot;</span> + cause);</span><br><span class="line">            <span class="keyword">if</span> (ack)&#123;</span><br><span class="line">                <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递成功</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//log.error(&quot;消息投递失败,ID为: &#123;&#125;,错误信息: &#123;&#125;&quot;, correlationData.getId(), cause);</span></span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> RabbitTemplate.ReturnCallback returnCallback = <span class="keyword">new</span> RabbitTemplate.ReturnCallback() &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 异步监听 消息是否到达 queue</span></span><br><span class="line"><span class="comment">         * 触发回调要满足的条件有两个：</span></span><br><span class="line"><span class="comment">         * 1.消息已经到达了 exchange </span></span><br><span class="line"><span class="comment">         * 2.消息无法到达 queue (比如 exchange 找不到跟 routingKey 对应的 queue)</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> message    返回的消息</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyCode  回复 code</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> replyText  回复 text</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(org.springframework.amqp.core.Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;-----returnCallback-----&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + message);</span><br><span class="line">            System.out.println(<span class="string">&quot;replyCode: &quot;</span> + replyCode + <span class="string">&quot;, replyText: &quot;</span> + replyText);</span><br><span class="line">            System.out.println(<span class="string">&quot;exchange: &quot;</span> + exchange + <span class="string">&quot;, routingKey: &quot;</span> + routingKey);</span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String exchange, String routingKey, String msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//消息头</span></span><br><span class="line">        MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        properties.getHeaders().put(<span class="string">&quot;send_time&quot;</span>, LocalDateTime.now());</span><br><span class="line">        properties.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">        <span class="comment">//构建消息</span></span><br><span class="line">        Message message = <span class="keyword">new</span> Message(msg.getBytes(), properties);</span><br><span class="line">        <span class="comment">//指定confirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">        <span class="comment">//指定returnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">        <span class="comment">//指定唯一id</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, msg, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendOrder</span><span class="params">(OrderMessage orderMessage)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//指定confirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(confirmCallback);</span><br><span class="line">        <span class="comment">//指定returnCallback</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(returnCallback);</span><br><span class="line">        <span class="comment">//id + 时间戳</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        rabbitTemplate.convertAndSend(<span class="string">&quot;exchange_2&quot;</span>, <span class="string">&quot;springboot.def&quot;</span>, orderMessage, correlationData);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="Exchange交换机"><a href="#Exchange交换机" class="headerlink" title="Exchange交换机"></a>Exchange交换机</h2><p>用来接收生产者发送的消息,并将这些消息路由给服务器中的队列;</p>
<p><strong>Exchange有4种类型</strong>,不同类型的Exchange转发消息的策略有所区别:</p>
<ul>
<li>direct(默认): 通过指定路由键点对点方式与队列绑定</li>
<li>fanout: 广播模式,将消息发送到所有队列</li>
<li>topic: 允许对路由键制定模糊匹配,单词之间用点隔开,#匹配0个或多个单词,*匹配一个单词</li>
<li>headers: 和默认基本一致,且性能不佳</li>
</ul>
<p><strong>交换机属性</strong></p>
<ul>
<li>Name: 交换机名称</li>
<li>Durability: 是否持久化</li>
<li>AutoDelete: 当最后一个绑定到Exchange上的队列被删除后,自动删除该Exchange</li>
<li>Internal: 当前Exchange是否用于RabbitMQ内部使用,默认false</li>
<li>Arguments: 拓展参数, 用于拓展AMQP协议自定制化使用</li>
</ul>
<p><strong>测试三种类型的交换器</strong></p>
<ol>
<li><p>点击管控台的<strong>Add a new exchange</strong>创建交换机</p>
<p>Durability:是否持久化选择Durable</p>
<p><code>exchange.direct</code>交换器,Type为direct</p>
<p><code>exchange.fanout</code>交换器,Type为fanout</p>
<p><code>exchange.topic</code>交换器,Type为topic</p>
</li>
<li><p><strong>Add a new queue</strong>添加消息队列</p>
<p>user  user.news  user.orders  edc.news</p>
</li>
<li><p>给队列<strong>绑定交换器</strong></p>
<p>exchange.direct/<strong>Bindings **选择 **To Queue</strong>,使用Routing key同名字分别绑定,点击Unbind可解绑,fanout与之同理</p>
<p>topic用通配符绑定</p>
<table>
<thead>
<tr>
<th>*.news</th>
<th>user.#</th>
</tr>
</thead>
<tbody><tr>
<td>user.news</td>
<td>user</td>
</tr>
<tr>
<td>edc.news</td>
<td>user.news</td>
</tr>
<tr>
<td></td>
<td>user.orders</td>
</tr>
</tbody></table>
</li>
<li><p>接着分别在三个Exchange发送消息测试</p>
<p>Exchanges中点击<strong>Publish message</strong> ,输入Routing key发送消息,如:direct.exchange.msg.helloWorld</p>
<p>在Queues中点击对应的queue,点击<strong>Get Message</strong>获取消息,Ack Mode选择Ack message requeue false会清除上一次的消息</p>
</li>
</ol>
<p><strong>结果:</strong></p>
<ul>
<li><p>direct通过指定路由键点对点方式与队列绑定,所以只有完全匹配Routing key的队列才会收到消息.</p>
</li>
<li><p>fanout会将消息广播发送到所有队列</p>
</li>
<li><p>topic会有选择的模糊匹配Routing key对应的队列</p>
</li>
</ul>
<h2 id="Message自定义消息属性"><a href="#Message自定义消息属性" class="headerlink" title="Message自定义消息属性"></a>Message自定义消息属性</h2><ol>
<li><p><strong>构建BasicProperties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义headers属性</span></span><br><span class="line">        HashMap&lt;String, Object&gt; attr = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        attr.put(<span class="string">&quot;status&quot;</span>, <span class="number">1</span>);</span><br><span class="line">        attr.put(<span class="string">&quot;detail&quot;</span>, <span class="string">&quot;这是附加属性&quot;</span>);</span><br><span class="line">        <span class="comment">//构建消息属性</span></span><br><span class="line">        AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                .deliveryMode(<span class="number">2</span>) <span class="comment">//1:不持久化消息, 2:持久化消息</span></span><br><span class="line">                .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>) <span class="comment">//字符集</span></span><br><span class="line">                .expiration(<span class="string">&quot;10000&quot;</span>) <span class="comment">//过期时间</span></span><br><span class="line">                .headers(attr) <span class="comment">//自定义属性</span></span><br><span class="line">                .build();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>发布时指定properties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String msg = <span class="string">&quot;Hello RabbitMQ&quot;</span>;</span><br><span class="line"><span class="comment">//使用默认exchange 发布消息</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i =<span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// exchange, routeKey, properties, message</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, <span class="string">&quot;test001&quot;</span>, properties, msg.getBytes());</span><br><span class="line">    System.out.println(<span class="string">&quot;发送消息: &quot;</span> + msg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel.close();</span><br><span class="line">connection.close();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取properties</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理消息的逻辑</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">    System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">    System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">    System.out.println(properties.getHeaders().get(<span class="string">&quot;detail&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="AMQP事务"><a href="#AMQP事务" class="headerlink" title="AMQP事务"></a>AMQP事务</h2><p>我们知道可以通过持久化（交换机、队列和消息持久化）来保障我们在服务器崩溃时，重启服务器消息数据不会丢失。</p>
<p>但是我们无法确认当消息的发布者在将消息发送出去之后，消息到底有没有正确到达Broker代理服务器呢？如果不进行特殊配置的话，默认情况下发布操作是不会返回任何信息给生产者的，也就是默认情况下我们的生产者是不知道消息有没有正确到达Broker的。如果在消息到达Broker之前已经丢失的话，持久化操作也解决不了这个问题，因为消息根本就没到达代理服务器，这个是没有办法进行持久化的，那么当我们遇到这个问题又该如何去解决呢？</p>
<p>RabbitMQ中的消息确认机制，通过消息确认机制我们可以确保我们的消息可靠送达到我们的用户手中，即使消息丢失掉，我们也可以通过进行重复分发确保用户可靠收到消息。</p>
<p><strong>RabbitMQ提供了两种消息确认方式：</strong></p>
<ul>
<li>通过AMQP事务机制实现，这也是AMQP协议层面提供的解决方案；</li>
<li>通过将channel设置成confirm模式来实现；</li>
</ul>
<p><strong>RabbitMQ中与事务有关的主要有三个方法：</strong></p>
<ul>
<li>txSelect() : 主要用于将当前channel设置成transaction模式</li>
<li>txCommit() : 用于提交事务</li>
<li>txRollback() : txRollback用于回滚事务</li>
</ul>
<p>当我们使用txSelect提交开始事务之后，我们就可以发布消息给Broke代理服务器，如果txCommit提交成功了，则消息一定到达了Broke了，如果在txCommit执行之前Broker出现异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback方法进行回滚事务了。</p>
<p>所以RabbitMQ事务中的主要代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 开启事务</span></span><br><span class="line">    channel.txSelect();</span><br><span class="line">    <span class="comment">// 往队列中发出一条消息，使用rabbitmq默认交换机</span></span><br><span class="line">    channel.basicPublish(<span class="string">&quot;&quot;</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">    <span class="comment">// 提交事务</span></span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    <span class="comment">// 事务回滚</span></span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">// 关闭频道和连接</span></span><br><span class="line">	channel.close();</span><br><span class="line">	connection.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先进行事务提交，然后开始发送消息，最后提交事务。</p>
<p>在使用事务时，在application.properties中，需要将确认模式更改为false。</p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 支持发布确认</span></span><br><span class="line"><span class="meta">spring.rabbitmq.publisher-confirms</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure>

<h2 id="消息可靠性投递"><a href="#消息可靠性投递" class="headerlink" title="消息可靠性投递"></a>消息可靠性投递</h2><ul>
<li>保障消息成功发出</li>
<li>保障MQ节点的成功接收</li>
<li>发送端收到MQ节点Broker确认答应</li>
<li>完善的消息补偿机制</li>
</ul>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a><strong>解决方案一</strong></h3><p><img src="https://i.loli.net/2020/07/03/cd2OwDpFlTIHCUj.png" alt="image-20200703124116225"></p>
<p><strong>消息落库, 对消息状态进行打标</strong></p>
<ol>
<li>生产者首先将自己的业务数据落库(如订单),然后将生成的消息落库,发送状态为<strong>待发送</strong>(status:0), 如果持久化失败,将进行快速失败</li>
<li>发送消息到MQ Broker</li>
<li>异步监听Broker收到消息后返回的确认答应</li>
<li>更新数据库信息状态为<strong>已发送</strong>(status:1)</li>
<li>如果超过最大发送时限仍然没有收到Borker的答应,使用分布式定时任务获取所有状态为待发送的信息记录<ul>
<li>分布式任务重复获取的问题,需要保证同一时间只有一个定时任务在获取消息记录</li>
<li>可能消息刚刚入库就被获取,造成不必要的重发,需要设置消息超时的最大容忍限制</li>
</ul>
</li>
<li>尝试重新发送</li>
<li>超过最大重试次数仍然没有答应,消息状态更新为坏消息(status:2),需要人工干预</li>
</ol>
<p><strong>缺点</strong>: 数据库操作频繁,高并发场景不适合</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a><strong>解决方案二</strong></h3><p><strong>消息的延迟投递, 做二次确认, 回调检查</strong></p>
<ul>
<li>Upstream: 上游服务,消息生产者</li>
<li>Downstream: 下游服务,消息消费者</li>
<li>MQ Broker: MQ集群</li>
<li>Callback: 回调服务</li>
</ul>
<p><img src="https://i.loli.net/2020/07/03/KPQEMhxgL6qe5m1.png" alt="image-20200703131009257"></p>
<ol>
<li>上游服务将自己的业务数据持久化之后,进行第一次消息投递</li>
<li>延迟消息投递检查, 在第一次消息发送后几分钟进行第二次投递,对应check队列,被Callback服务监听</li>
<li>下游服务监听消息并处理消息</li>
<li>如果消息被成功处理,发送确认信息到confirm队列,被Callback服务监听</li>
<li>Callback监听到confirm队列中消息被正确处理的答应,将消息记录入库</li>
<li>如果下游服务没有返回答应消息,MSG DB中就没有该消息的记录,此时check队列中延迟消息到达,检查DB中是否存在此条消息记录,也就是验证该消息是否在之前被正确处理,如果没有Callback服务将发送RPC通知上游服务,将该消息对应的业务数据进行重新一轮发送</li>
</ol>
<p><strong>优点</strong>: 减少了数据库操作,补偿服务和主业务解耦</p>
<h2 id="消费端-冥等性保障"><a href="#消费端-冥等性保障" class="headerlink" title="消费端-冥等性保障"></a>消费端-冥等性保障</h2><p><strong>冥等性</strong></p>
<p>任意多次执行操作对资源本身所产生的影响均与一次执行的影响相同</p>
<p><strong>解决的问题:</strong></p>
<p>在高并发情况下,难免会发送消息的重复投递</p>
<p><strong>在海量订单产生的业务高峰期,如何避免消息的重复消费问题?</strong></p>
<p><strong>消费端实现冥等性,就意味着,我们的消息永远不会被消费多次,即使我们收到了多条一样的消息</strong></p>
<h3 id="解决方案一-1"><a href="#解决方案一-1" class="headerlink" title="解决方案一"></a>解决方案一</h3><p><strong>唯一ID + 指纹码机制, 利用数据库主键去重</strong></p>
<ul>
<li>生成全局唯一ID + 指纹码(可能是某种业务规则,或第三方提供的唯一标识),利用数据库主键唯一性去重</li>
<li><code>SELETE COUNT(1) FROM T_ORDER WHERE ID = 唯一ID + 指纹码</code>,查到数据库没有此条记录,再进行Insert并消费,否则说明此条记录已经被操作了,丢弃</li>
</ul>
<p><strong>优点</strong>: 实现简单</p>
<p><strong>缺点</strong>: 高并发下存在数据库写入的性能瓶颈</p>
<p><strong>解决方案</strong>: 根据ID进行分库分表进行路由算法分摊压力 </p>
<h3 id="解决方案二-1"><a href="#解决方案二-1" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>利用Redis的原子性实现冥等</p>
<p><strong>需要考虑的问题:</strong></p>
<ul>
<li>我们是否要进行数据落库, 如果落库的话, 关键解决的问题是数据库和缓存如何做到原子性?</li>
<li>如果不进行落库,那么都存储到缓存中, 如何设置定时同步的策略?</li>
</ul>
<h2 id="confirm消息确认机制"><a href="#confirm消息确认机制" class="headerlink" title="confirm消息确认机制"></a>confirm消息确认机制</h2><p>消息的确认,是指生产者投递消息后, 如果Broker收到消息,则会给生产者一个答应</p>
<p>生产者进行接收答应,用来确定这条消息是否正常的发送到Broker,这种方式也是消息可靠性投递的核心保障</p>
<p><img src="https://i.loli.net/2020/07/01/9kqbnH6uVGvh1jE.png" alt="Producer-Confirm"></p>
<blockquote>
<p>默认情况下rabbitmq的消费者采用平均分配的方式消费队列中的消息,而且默认开启autoAck自动答应机制,消费者在接受到消息后就会向rabbitmq发送消息已被消费的信号,此时消息将被删除,如果消费者消费到一半的时候宕机,便导致了业务无法正常完成;</p>
<p>为了保证消息不会丢失,如果一个消费者宕机,我们希望将未被处理的消息交给另一个消费者</p>
</blockquote>
<p><strong>实现原理：</strong></p>
<p>==生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个<strong>唯一的ID</strong>(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了==，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中<strong>delivery-tag</strong>域包含了确认消息的序列号，此外broker也可以设置basic.ack的<strong>multiple</strong>域，表示到这个序列号之前的所有消息都已经得到了处理；</p>
<p>confirm模式最大的好处在于他是<strong>异步</strong>的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条<strong>nack</strong>消息，生产者应用程序同样可以在回调方法中处理该nack消息；</p>
<p><strong>开启confirm模式的方法：</strong></p>
<ul>
<li>在channel上开启确认模式: <code>channel.confirmSelect()</code></li>
<li>在channel上添加监听: <code>addConfirmListener</code>, 监听成功和失败的返回结果,根据具体的结果对消息进行重新发送,或记录日志等后续处理</li>
</ul>
<p>生产者通过调用channel的<code>confirmSelect</code>方法将channel设置为confirm模式，(注意一点，已经在transaction事务模式的channel是不能再设置成confirm模式的，即这两种模式是不能共存的)，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式(从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的，而且我也没找到我们自己能够设置no-wait标志的方法)；</p>
<p>注意：<strong>发布确认和事务。(两者不可同时使用)在channel为事务时，不可引入确认模式；同样channel为确认模式下，不可使用事务</strong></p>
<h3 id="原生API-1"><a href="#原生API-1" class="headerlink" title="原生API"></a>原生API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.confirm.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;confirm.#&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.confirm.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange和队列</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>);</span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定exchange和队列</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//设置channel 队列名称, autoAck, consumer</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//消息处理逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;消费端: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指定消息确认模式</span></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.confirm.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;confirm.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送消息</span></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ Send confirm message!&quot;</span>;</span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----添加确认监听----</span></span><br><span class="line">        channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 成功答应</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> deliveryTag 消息唯一标识</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> multiple 是否批量</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;----------------ack!--------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//否认答应</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.err.println(<span class="string">&quot;----------------no ack--------------&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="spring-boot-1"><a href="#spring-boot-1" class="headerlink" title="spring-boot"></a><em>spring-boot</em></h3><p><strong>配置:</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rabbitmq:</span></span><br><span class="line">  <span class="attr">host:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">5672</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">guest</span></span><br><span class="line">  <span class="attr">virtual-host:</span> <span class="string">/</span></span><br><span class="line">  <span class="attr">publisher-confirms:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 到达 exchange</span></span><br><span class="line">  <span class="attr">publisher-returns:</span> <span class="literal">true</span> <span class="comment">#监听消息是否 没有到达 queue</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">mandatory:</span> <span class="literal">true</span> <span class="comment">#自动删除不可达消息，默认为false</span></span><br><span class="line">  <span class="attr">listener:</span></span><br><span class="line">    <span class="attr">simple:</span></span><br><span class="line">      <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>

<p><strong>消息实体:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 订单的消息实体</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMessage</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务id，在业务系统中的唯一。比如 订单id、支付id、商品id ，消息消费端可以通过该 id 避免消息重复消费</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 其他业务字段</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>发送消息并异步监听:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.core.Message;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.connection.CorrelationData;</span><br><span class="line"><span class="keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息并异步监听 ack</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderMessageSendAsync</span> <span class="keyword">implements</span> <span class="title">RabbitTemplate</span>.<span class="title">ConfirmCallback</span>, <span class="title">RabbitTemplate</span>.<span class="title">ReturnCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(OrderMessageSendAsync.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过构造函数注入 RabbitTemplate 依赖</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rabbitTemplate</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrderMessageSendAsync</span><span class="params">(RabbitTemplate rabbitTemplate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rabbitTemplate = rabbitTemplate;</span><br><span class="line">        <span class="comment">// 设置消息到达 exchange 时，要回调的方法，每个 RabbitTemplate 只支持一个 ConfirmCallback</span></span><br><span class="line">        rabbitTemplate.setConfirmCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 设置消息无法到达 queue 时，要回调的方法</span></span><br><span class="line">        rabbitTemplate.setReturnCallback(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 发送消息</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由建</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    消息实体</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMsg</span><span class="params">(String exchange, String routingKey, Object message)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构造包含消息的唯一id的对象，id 必须在该 channel 中始终唯一</span></span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        logger.info(<span class="string">&quot;ID为: &#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">        <span class="comment">// todo 先将业务数据入库，在将 message 的数据库ID 、message的消息id message的初始状态(发送中)等信息入库</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 完成 数据落库，消息状态打标后，就可以安心发送 message</span></span><br><span class="line">        rabbitTemplate.convertAndSend(exchange, routingKey, message, correlationData);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;发送消息的线程处于休眠状态， confirm 和 returnedMessage 方法依然处于异步监听状态&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>*<span class="number">15</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听 消息是否到达 exchange</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> correlationData 包含消息的唯一标识的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack             true 标识 ack，false 标识 nack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cause           nack 的原因</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">confirm</span><span class="params">(CorrelationData correlationData, <span class="keyword">boolean</span> ack, String cause)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (ack) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;消息投递成功,ID为: &#123;&#125;&quot;</span>, correlationData.getId());</span><br><span class="line">            <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递成功</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;消息投递失败,ID为: &#123;&#125;,错误信息: &#123;&#125;&quot;</span>, correlationData.getId(), cause);</span><br><span class="line">        <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异步监听 消息是否到达 queue</span></span><br><span class="line"><span class="comment">     * 触发回调要满足的条件有两个：1.消息已经到达了 exchange 2.消息无法到达 queue (比如 exchange 找不到跟 routingKey 对应的 queue)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message    返回的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyCode  回复 code</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> replyText  回复 text</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange   交换机</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnedMessage</span><span class="params">(Message message, <span class="keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// correlationId 就是发消息时设置的 id</span></span><br><span class="line">        String correlationId = message.getMessageProperties().getHeaders().get(<span class="string">&quot;spring_returned_message_correlation&quot;</span>).toString();</span><br><span class="line"></span><br><span class="line">        logger.error(<span class="string">&quot;没有找到对应队列，消息投递失败,ID为: &#123;&#125;, replyCode &#123;&#125; , replyText &#123;&#125;, exchange &#123;&#125; routingKey &#123;&#125;&quot;</span>,</span><br><span class="line">                correlationId, replyCode, replyText, exchange, routingKey);</span><br><span class="line">        <span class="comment">// todo 操作数据库，将 correlationId 这条消息状态改为投递失败</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSONObject;</span><br><span class="line"><span class="keyword">import</span> com.wqlm.rabbitmq.send.MessageSend.OrderMessageSendAsync;</span><br><span class="line"><span class="keyword">import</span> com.wqlm.rabbitmq.send.message.OrderMessage;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;/&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderMessageSendAsync orderMessageSendAsync;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 测试发送消息并异步接收响应</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        OrderMessage orderMessage = <span class="keyword">new</span> OrderMessage(<span class="string">&quot;123&quot;</span>, <span class="string">&quot;订单123&quot;</span>);</span><br><span class="line">        <span class="comment">// 序列化成json ，OrderMessage 也可以 implements Serializable 这样就不需要序列化成json</span></span><br><span class="line">        String message = JSONObject.toJSONString(orderMessage);</span><br><span class="line">        orderMessageSendAsync.sendMsg(<span class="string">&quot;exchangeName&quot;</span>, <span class="string">&quot;routingKeyValue&quot;</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="springAMQP"><a href="#springAMQP" class="headerlink" title="springAMQP"></a>springAMQP</h2><h3 id="SimpleMessageListenerContainer"><a href="#SimpleMessageListenerContainer" class="headerlink" title="SimpleMessageListenerContainer"></a><em>SimpleMessageListenerContainer</em></h3><p><strong>简单消息监听容器:</strong> 我们使用SimpleMessageListenerContainer容器设置消费队列监听，然后设置具体的监听Listener进行消息消费具体逻辑的编写</p>
<ul>
<li>SimpleMessageListenerContainer可监听多个队列</li>
<li>设置事务特性, 事务管理器, 事务属性, 事务容量, 回滚消息等</li>
<li>设置消费者数量, 最小最大数量, 批量消费</li>
<li>设置消息签收模式 NONE, AUTO, MANUAL</li>
<li>是否重回队列, 异常捕获handler函数</li>
<li>设置消费则标签生成策略, 是否独占模式, 消费者属性等</li>
<li>设置具体监听器, 转换器</li>
</ul>
<p>注意: SimpleMessageListenerContainer可以在运行中动态的改变其消费者数量的大小, 接收消息的模式等; 很多基于RabbitMQ的自定制后台管理在进行动态设置的时候, 也是根据SpringAMQP这一特性取实现的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.ack&quot;</span>, <span class="string">&quot;test.order.queue&quot;</span>); <span class="comment">//监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); //监听的队列, 注入方式</span></span><br><span class="line">    container.setConcurrentConsumers(<span class="number">1</span>); <span class="comment">//当前的消费者数量</span></span><br><span class="line">    container.setMaxConcurrentConsumers(<span class="number">5</span>); <span class="comment">//最大消费者数量</span></span><br><span class="line">    container.setDefaultRequeueRejected(<span class="keyword">false</span>); <span class="comment">//默认不重回队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">//手动ack模式</span></span><br><span class="line">    <span class="comment">//container.setAfterReceivePostProcessors(MessagePostProcessor); 在接收到消息之前做什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费端标签生成策略 (可lambda)</span></span><br><span class="line">    container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue + <span class="string">&quot;_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消息监听处理</span></span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt;&#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;===监听到消息===&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.getMessageProperties().getHeaders().get(<span class="string">&quot;err&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===消息已确认===&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;===拒绝消息===&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="MessageListenerAdapter"><a href="#MessageListenerAdapter" class="headerlink" title="MessageListenerAdapter"></a><em>MessageListenerAdapter</em></h3><p><strong>消息监听适配器:</strong> 允许你自定义MessageListener, 通过MessageListenerAdapter来适配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;test.ack&quot;</span>, <span class="string">&quot;test.order.queue&quot;</span>); <span class="comment">//监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); //监听的队列, 注入方式</span></span><br><span class="line">    container.setConcurrentConsumers(<span class="number">1</span>); <span class="comment">//当前的消费者数量</span></span><br><span class="line">    container.setMaxConcurrentConsumers(<span class="number">5</span>); <span class="comment">//最大消费者数量</span></span><br><span class="line">    container.setDefaultRequeueRejected(<span class="keyword">false</span>); <span class="comment">//默认不重回队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">//手动ack模式</span></span><br><span class="line">    <span class="comment">//container.setAfterReceivePostProcessors(MessagePostProcessor); 在接收到消息之前做什么</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//消费端标签生成策略 (可lambda)</span></span><br><span class="line">    container.setConsumerTagStrategy(<span class="keyword">new</span> ConsumerTagStrategy() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">createConsumerTag</span><span class="params">(String queue)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> queue + <span class="string">&quot;_&quot;</span> + UUID.randomUUID().toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//适配自定义消息监听处理</span></span><br><span class="line">    MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageDelegate());</span><br><span class="line">    adapter.setDefaultListenerMethod(<span class="string">&quot;consumeMessage&quot;</span>); <span class="comment">//改变默认方法</span></span><br><span class="line">    adapter.setMessageConverter(<span class="keyword">new</span> TextMessageConverter()); <span class="comment">//消息转换器</span></span><br><span class="line">    <span class="comment">//设置消息监听器</span></span><br><span class="line">    container.setMessageListener(adapter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义消息监听器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageDelegate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(String messageBody)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;默认方法, 消息内容: &quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consumeMessage</span><span class="params">(<span class="keyword">byte</span>[] messageBody)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;字节数组方法, 消息内容: &quot;</span> + messageBody);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>==自定义消息监听器的处理方法名称, 定义在MessageListenerAdapter中==:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageListenerAdapter</span> <span class="keyword">extends</span> <span class="title">AbstractAdaptableMessageListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, String&gt; queueOrTagToMethodName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ORIGINAL_DEFAULT_LISTENER_METHOD = <span class="string">&quot;handleMessage&quot;</span>;</span><br><span class="line">    <span class="keyword">private</span> Object delegate;</span><br><span class="line">    <span class="keyword">private</span> String defaultListenerMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageListenerAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queueOrTagToMethodName = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">this</span>.defaultListenerMethod = <span class="string">&quot;handleMessage&quot;</span>;</span><br><span class="line">        <span class="keyword">this</span>.delegate = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>你可以通过<code>adapter.setDefaultListenerMethod(&quot;consumeMessage&quot;);</code>==修改负责消息监听处理的方法, 以适配不同的消息处理方式==</p>
<hr>
<p><strong>consumeMessage的入参是byte[]类型, 假设我们发送的消息是String类型就会抛出异常, 可使用自定义MessageConvert来转换类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文本消息转换器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextMessageConverter</span> <span class="keyword">implements</span> <span class="title">MessageConverter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Object 转 Message</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Message <span class="title">toMessage</span><span class="params">(Object object, MessageProperties messageProperties)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message(object.toString().getBytes(), messageProperties);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Message 转 Object</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">fromMessage</span><span class="params">(Message message)</span> <span class="keyword">throws</span> MessageConversionException </span>&#123;</span><br><span class="line">        String contentType = message.getMessageProperties().getContentType();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != contentType &amp;&amp; contentType.contains(<span class="string">&quot;text&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> String(message.getBody());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> message.getBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>adapter.setMessageConverter(new TextMessageConverter());</code>==指定消息转换器, 并在发送消息时指定ContentType;==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消息头</span></span><br><span class="line">MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">properties.getHeaders().put(<span class="string">&quot;send_time&quot;</span>, LocalDateTime.now());</span><br><span class="line">properties.setContentType(<span class="string">&quot;text/plain&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>可以设置多个队列通过队列名或Tag与不同方法的映射绑定</strong></p>
<p><em>queueOrTagToMethodName</em>: 队列标识与方法名称组成的集合</p>
<p>==即指定队列里的消息会被所绑定的方法所接收处理==</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MessageListenerAdapter adapter = <span class="keyword">new</span> MessageListenerAdapter(<span class="keyword">new</span> MessageDelegate());</span><br><span class="line">HashMap&lt;String, String&gt; queueOrTagToMethodName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">queueOrTagToMethodName.put(<span class="string">&quot;order.queue&quot;</span>, <span class="string">&quot;handleOrder&quot;</span>);</span><br><span class="line">queueOrTagToMethodName.put(<span class="string">&quot;product&quot;</span>, <span class="string">&quot;handleProduct&quot;</span>);</span><br><span class="line"><span class="comment">//设置队列与监听处理方法的映射绑定</span></span><br><span class="line">adapter.setQueueOrTagToMethodName(queueOrTagToMethodName); </span><br><span class="line">container.setMessageListener(adapter);</span><br></pre></td></tr></table></figure>

<h2 id="消息监听器处理Ack"><a href="#消息监听器处理Ack" class="headerlink" title="消息监听器处理Ack"></a>消息监听器处理Ack</h2><ul>
<li>消息<strong>通过 ACK 确认是否被正确接收</strong>，每个 Message 都要被确认（acknowledged），可以手动去 ACK 或自动 ACK</li>
<li>自动确认会在消息发送给消费者后立即确认，但存在丢失消息的可能，如果消费端消费逻辑抛出异常，也就是消费端没有处理成功这条消息，那么就相当于丢失了消息</li>
<li>如果消息已经被处理，但后续代码抛出异常，使用 Spring 进行管理的话消费端业务逻辑会进行回滚，这也同样造成了实际意义的消息丢失</li>
<li>如果手动确认则当消费者调用 ack、nack、reject 几种方法进行确认，手动确认可以在业务失败后进行一些操作，如果消息未被 ACK 则会发送到下一个消费者</li>
<li><strong>如果某个服务没有 ACK ，则 RabbitMQ 不会再发送数据给它，因为 RabbitMQ 认为该服务的处理能力有限</strong></li>
<li>ACK 机制还可以起到限流作用，比如在接收到某条消息时休眠几秒钟</li>
<li>消息确认模式有：<ul>
<li>AcknowledgeMode.NONE：自动确认</li>
<li>AcknowledgeMode.AUTO：根据情况确认</li>
<li>AcknowledgeMode.MANUAL：手动确认</li>
</ul>
</li>
</ul>
<h3 id="确认消息（局部方法处理消息）"><a href="#确认消息（局部方法处理消息）" class="headerlink" title="确认消息（局部方法处理消息）"></a>确认消息（局部方法处理消息）</h3><ul>
<li><p>默认情况下消息消费者是自动 ack （确认）消息的，如果要手动 ack（确认）则需要修改确认模式为 manual</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>或在 RabbitListenerContainerFactory 中进行开启手动 ack</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> RabbitListenerContainerFactory&lt;?&gt; rabbitListenerContainerFactory(ConnectionFactory connectionFactory)&#123;</span><br><span class="line">    SimpleRabbitListenerContainerFactory factory = <span class="keyword">new</span> SimpleRabbitListenerContainerFactory();</span><br><span class="line">    factory.setConnectionFactory(connectionFactory);</span><br><span class="line">    factory.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    factory.setAcknowledgeMode(AcknowledgeMode.MANUAL);             <span class="comment">//开启手动 ack</span></span><br><span class="line">    <span class="keyword">return</span> factory;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>确认消息 @RabbitHandler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage2</span><span class="params">(String message,Channel channel,<span class="meta">@Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck(tag,<span class="keyword">false</span>); <span class="comment">// 确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>需要注意的 basicAck 方法需要传递两个参数</p>
<ul>
<li><strong>deliveryTag（唯一标识 ID）</strong>：当一个消费者向 RabbitMQ 注册后，会建立起一个 Channel ，RabbitMQ 会用 basic.deliver 方法向消费者推送消息，这个方法携带了一个 delivery tag， <strong>它代表了 RabbitMQ 向该 Channel 投递的这条消息的唯一标识 ID</strong>，是一个单调递增的正整数，delivery tag 的范围仅限于 Channel</li>
<li><strong>multiple</strong>：为了减少网络流量，手动确认可以被批处理，<strong>当该参数为 true 时，则可以一次性确认 delivery_tag 小于等于传入值的所有消息</strong></li>
</ul>
</li>
</ul>
<h3 id="手动否认-拒绝消息"><a href="#手动否认-拒绝消息" class="headerlink" title="手动否认 拒绝消息"></a>手动否认 拒绝消息</h3><ul>
<li><p>发送一条错误消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendError</span><span class="params">(String exchange, String routeKey, String body)</span></span>&#123;</span><br><span class="line">        MessageProperties properties = <span class="keyword">new</span> MessageProperties();</span><br><span class="line">        properties.getHeaders().put(<span class="string">&quot;error&quot;</span>, <span class="string">&quot;这是一条错误的消息&quot;</span>);</span><br><span class="line">        properties.setMessageId(UUID.randomUUID().toString());</span><br><span class="line">        Message message = <span class="keyword">new</span> Message(body.getBytes(), properties);</span><br><span class="line">        rabbitTemplate.send(exchange, routeKey, message);</span><br><span class="line">        System.out.println(<span class="string">&quot;发送了错误信息&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>消费者获取消息时检查到头部包含 error 则 nack 消息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RabbitListener(queues = &quot;test.ack&quot;)</span></span><br><span class="line"><span class="meta">@RabbitHandler</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">processMessage</span><span class="params">(String message, Channel channel,<span class="meta">@Headers</span> Map&lt;String,Object&gt; map)</span> </span>&#123;</span><br><span class="line">    System.out.println(message);</span><br><span class="line">    <span class="keyword">if</span> (map.get(<span class="string">&quot;error&quot;</span>)!= <span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;错误的消息&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel.basicNack((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>,<span class="keyword">true</span>);      <span class="comment">//否认消息</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel.basicAck((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>);            <span class="comment">//确认消息</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>此时控制台重复打印，说明该消息被 nack 后一直重新入队列然后一直重新消费</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br><span class="line">hello</span><br><span class="line">错误的消息</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以拒绝该消息，消息会被丢弃，不会重回队列</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicReject((Long)map.get(AmqpHeaders.DELIVERY_TAG),<span class="keyword">false</span>); <span class="comment">//拒绝消息</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="确认消息（全局处理消息）"><a href="#确认消息（全局处理消息）" class="headerlink" title="确认消息（全局处理消息）"></a>确认消息（全局处理消息）</h3><ul>
<li><p><strong>自动确认</strong>涉及到一个问题就是如果在处理消息的时候抛出异常，消息处理失败，但是因为自动确认而导致 Rabbit 将该消息删除了，造成消息丢失</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//NONE</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);                 <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.NONE);     <span class="comment">// NONE 代表自动确认</span></span><br><span class="line">    container.setMessageListener((MessageListener) message -&gt; &#123;         <span class="comment">//消息监听处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="comment">//相当于自己的一些消费逻辑抛错误</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;consumer fail&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>手动确认消息</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MANUAL</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>); <span class="comment">// 监听的队列, 多个用逗号分隔</span></span><br><span class="line">    <span class="comment">//container.setQueues(queue001(), queue002()); // 监听的队列, 注入方式</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.MANUAL); <span class="comment">// 手动确认</span></span><br><span class="line">    </span><br><span class="line">    container.setMessageListener((ChannelAwareMessageListener) (message, channel) -&gt; &#123;      <span class="comment">//消息处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;====监听到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="keyword">if</span>(message.getMessageProperties().getHeaders().get(<span class="string">&quot;error&quot;</span>) == <span class="keyword">null</span>)&#123;</span><br><span class="line">        channel.basicAck(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息已经确认&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//channel.basicNack(message.getMessageProperties().getDeliveryTag(),false,false);</span></span><br><span class="line">            channel.basicReject(message.getMessageProperties().getDeliveryTag(),<span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;消息拒绝&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>AcknowledgeMode 除了 NONE 和 MANUAL 之外还有 <strong>AUTO</strong> ，它会根据方法的执行情况来决定是否确认还是拒绝（是否重新入queue）</p>
<ul>
<li>如果消息成功被消费（成功的意思是在消费的过程中没有抛出异常），则自动确认</li>
<li>当抛出 AmqpRejectAndDontRequeueException 异常的时候，则消息会被拒绝，且 requeue = false（不重新入队列）</li>
<li>当抛出 ImmediateAcknowledgeAmqpException 异常，则消费者会被确认</li>
<li>其他的异常，则消息会被拒绝，且 requeue = true（==如果此时只有一个消费者监听该队列，则有发生死循环的风险，多消费端也会造成资源的极大浪费，这个在开发过程中一定要避免的==）。可以通过 setDefaultRequeueRejected（默认是true）去设置</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AUTO</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SimpleMessageListenerContainer <span class="title">messageListenerContainer</span><span class="params">(ConnectionFactory connectionFactory)</span></span>&#123;</span><br><span class="line">    SimpleMessageListenerContainer container = <span class="keyword">new</span> SimpleMessageListenerContainer();</span><br><span class="line">    container.setConnectionFactory(connectionFactory);</span><br><span class="line">    container.setQueueNames(<span class="string">&quot;consumer_queue&quot;</span>);              <span class="comment">// 监听的队列</span></span><br><span class="line">    container.setAcknowledgeMode(AcknowledgeMode.AUTO);     <span class="comment">// 根据情况确认消息</span></span><br><span class="line">    container.setMessageListener((MessageListener) (message) -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====接收到消息=====&quot;</span>);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(message.getBody()));</span><br><span class="line">        <span class="comment">//抛出NullPointerException异常则重新入队列</span></span><br><span class="line">        <span class="comment">//throw new NullPointerException(&quot;消息消费失败&quot;);</span></span><br><span class="line">        <span class="comment">//当抛出的异常是AmqpRejectAndDontRequeueException异常的时候，则消息会被拒绝，且requeue=false</span></span><br><span class="line">        <span class="comment">//throw new AmqpRejectAndDontRequeueException(&quot;消息消费失败&quot;);</span></span><br><span class="line">        <span class="comment">//当抛出ImmediateAcknowledgeAmqpException异常，则消费者会被确认</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ImmediateAcknowledgeAmqpException(<span class="string">&quot;消息消费失败&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> container;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>消息可靠总结</strong></p>
<ul>
<li>持久化<ul>
<li>exchange要持久化</li>
<li>queue要持久化</li>
<li>message要持久化</li>
</ul>
</li>
<li>消息确认<ul>
<li>启动消费返回（@ReturnList注解，生产者就可以知道哪些消息没有发出去）</li>
<li>生产者和Server（broker）之间的消息确认</li>
<li>消费者和Server（broker）之间的消息确认</li>
</ul>
</li>
</ul>
<h2 id="Return消息机制"><a href="#Return消息机制" class="headerlink" title="Return消息机制"></a>Return消息机制</h2><p>Return Listener 用于处理一些不可路由的消息</p>
<p>我们的消息生产者,通过指定一个Exchange和Routingkey,把消息送达到某一个队列中取,然后我们的消费者监听队列,进行消费处理操作</p>
<p>但是在某些情况下,如果我们在发送消息的时候,当前的exchange不存在或者指定的路由key路由不到,这个时候需要监听这种不可达的消息,就要使用Return Listener</p>
<p><strong>关键配置项:</strong></p>
<ul>
<li><em>Mandatory</em>: 如果为true, 则监听器会接收到路由不可达的消息,然后进行后续处理; 如果为false, 那么broker端自动删除改消息</li>
</ul>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.return.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;return.#&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.return.queue&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建消费者</span></span><br><span class="line">        MessageConsumer consumer = <span class="keyword">new</span> MessageConsumer(channel);</span><br><span class="line">        <span class="comment">//指定channel的消费者 autoAck</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">true</span>, consumer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReturnProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.return.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;return.save&quot;</span>;</span><br><span class="line">        String routingKeyError = <span class="string">&quot;abc.save&quot;</span>;</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ Return Listener!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//---添加return listener---</span></span><br><span class="line">        channel.addReturnListener(<span class="keyword">new</span> ReturnListener() &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 监听不可达消息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyCode 响应码</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> replyText 响应文本</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> exchange 交换器</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> routingKey 路由键</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> basicProperties 属性</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@param</span> body 消息</span></span><br><span class="line"><span class="comment">             * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturn</span><span class="params">(<span class="keyword">int</span> replyCode, String replyText, String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     String routingKey, AMQP.BasicProperties basicProperties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;------------------handle return---------------&quot;</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;replyCode: &quot;</span> + replyCode);</span><br><span class="line">                System.out.println(<span class="string">&quot;replyText: &quot;</span> + replyText);</span><br><span class="line">                System.out.println(<span class="string">&quot;exchange: &quot;</span> + exchange);</span><br><span class="line">                System.out.println(<span class="string">&quot;routingKey: &quot;</span> + routingKey);</span><br><span class="line">                System.out.println(<span class="string">&quot;properties: &quot;</span> + basicProperties.getMessageId());</span><br><span class="line">                System.out.println(<span class="string">&quot;body: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Mandatory = true 才能使监听起效! */</span></span><br><span class="line">        <span class="comment">//发送消息 exchange, routingKey, Mandatory, properties, body</span></span><br><span class="line">        channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        <span class="comment">//发送消息到不存在的routingKey</span></span><br><span class="line">        channel.basicPublish(exchangeName, routingKeyError, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送消息到不存在的routingKey,将会触发handleReturn回调,打印信息如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">------------------handle <span class="keyword">return</span>---------------</span><br><span class="line">replyCode: <span class="number">312</span></span><br><span class="line">replyText: NO_ROUTE</span><br><span class="line">exchange: test.return.exchange</span><br><span class="line">routingKey: abc.save</span><br><span class="line">properties: <span class="keyword">null</span></span><br><span class="line">body: Hello RabbitMQ Return Listener!</span><br></pre></td></tr></table></figure>

<p>==Mandatory = true 才能使监听起效!==</p>
<h2 id="消费端限流"><a href="#消费端限流" class="headerlink" title="消费端限流"></a>消费端限流</h2><blockquote>
<p>假设一个场景, 首先我们RabbitM服务器有上万条未处理的消息,此时开启一个消费端,会出现下面的情况:</p>
<p>巨量的消息瞬间被推送过来,单个消费端无法同时处理这么多的数据,造成服务的崩溃</p>
</blockquote>
<p>RabbitMQ提供了一种qos(服务治理保证)功能, 即在非自动确认消息的前提下,如果一定数目的消息(通过基于consume或者channel设置Qos的值) 未被确认前,不进行消费新的消息</p>
<p>实际开发中 <em>autoAck</em> 一定是false</p>
<p><code>void BasicQos(int prefetchSize, short prefetchConut, bool global)</code></p>
<ul>
<li>prefetchSize: 消息大小的限制, 一般设置为0不限制</li>
<li>prefetchConut: 在Broker接收到该Consumer的ack之前,Consumer在同一个时间点最多被分配最多处理消息数量</li>
<li>global: true应用在监听此channel的所有consume, false仅应用在当前consume</li>
</ul>
<p>prefetchSize和global这两项,rabbitmq没有实现,暂且不研究;</p>
<p>prefetchConut只在no_ask=false的情况下生效</p>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.qos.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.qos.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;qos.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----QOS限流, 每次处理1条消息----</span></span><br><span class="line">        channel.basicQos(<span class="number">0</span>, <span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//设置consumer 设置autoAck false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            <span class="comment">//ack答应</span></span><br><span class="line">            channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果将basicAck注释掉,consumer将只会收到第一条信息</p>
<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LimitProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.qos.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;qos.save&quot;</span>;</span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ QOS Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送5条消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, <span class="keyword">null</span>, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="消费端Ack与重回队列"><a href="#消费端Ack与重回队列" class="headerlink" title="消费端Ack与重回队列"></a>消费端Ack与重回队列</h2><p><strong>ack的三种答应:</strong></p>
<ul>
<li>basicAck : 返回正确的答应</li>
<li>basicNack: 返回否定的答应,且 requeue = true 消息会重回队列,循环重发</li>
<li>basicReject: 返回拒绝的答应, 消息会被丢弃</li>
</ul>
<p><strong>消费端的重回队列:</strong></p>
<ul>
<li>消费端重回队列是为了对没有处理成功的消息, 把消息重新回递给Broker</li>
<li>一般在实际应用中,都会关闭重回队列,也就是false</li>
</ul>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReQueueConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.ack.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.ack.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;ack.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//创建一个队列 队列名称, 是否持久化, 此channel独占这个队列, autoDelete, 拓展参数</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer autoAck = false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>((Integer)properties.getHeaders().get(<span class="string">&quot;num&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//否定答应 消息唯一标识, 是否批量处理, 是否重回队列</span></span><br><span class="line">                channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;重回队列, DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//ack答应</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">                System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">                System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>num为0的消息被否认ack,接着处理完其他几条消息后, num为0的消息不断的重回队列</p>
<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReQueueProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.ack.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.ack.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;ack.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ ACK Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//发送5条信息</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            HashMap&lt;String, Object&gt; headers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            headers.put(<span class="string">&quot;num&quot;</span>, i);</span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .deliveryMode(<span class="number">2</span>) <span class="comment">//持久化</span></span><br><span class="line">                    .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                    .expiration(<span class="string">&quot;20000&quot;</span>)</span><br><span class="line">                    .headers(headers)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="TTL消息-队列"><a href="#TTL消息-队列" class="headerlink" title="TTL消息/队列"></a>TTL消息/队列</h2><p>TTL是 Time To Live 的缩写, 也就是生存时间</p>
<p><strong>RabbitMQ支持消息的过期时间, 在发送消息时可以进行指定</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .expiration(<span class="string">&quot;20000&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>RabbitMQ支持队列级消息的过期时间, 从消息入队开始计算, 只要超过了队列的超时时间配置, 那么消息会自动的清除</strong></p>
<p><img src="https://i.loli.net/2020/07/04/lCcxyu75zB9Jm8f.png" alt="image-20200704160309883"></p>
<p>在创建时可指定 Arguments 下面的参数:</p>
<ul>
<li>message-ttl : 消息过期时间, 毫秒</li>
<li>max-length: 消息最大长度</li>
<li>…</li>
</ul>
<p><strong>测试TTL队列</strong></p>
<ul>
<li><p>新建exchange, 指定路由键为 ttl.abc 绑定到上面创建的 exp.queue 队列</p>
</li>
<li><p>发送一条消息</p>
<img src="https://i.loli.net/2020/07/04/e5BYpEGWguiQSRZ.png" alt="image-20200704161110566" style="zoom: 80%;" />
</li>
<li><p>10秒之后这条消息会被清除</p>
<p><img src="https://i.loli.net/2020/07/04/cDnTC5M2sZBqxtP.png" alt="image-20200704161315752"></p>
</li>
</ul>
<h2 id="DLX死信队列"><a href="#DLX死信队列" class="headerlink" title="DLX死信队列"></a>DLX死信队列</h2><p><strong>死信队列: Dead-Letter-Exchange</strong></p>
<p>RabbitMQ中的死信队列是和exchange息息相关的</p>
<p>利用DLX, 当消息在一个队列中变成死信(dead message)之后, 它能被重新publish到另一个Exchange,  这个Exchange就是DLX</p>
<p><strong>消息变成死信有以下几种情况</strong></p>
<ul>
<li>消息被拒绝(basic.reject / basic.nack)，并且requeue = false</li>
<li>消息TTL过期</li>
<li>队列达到最大长度</li>
</ul>
<p><strong>死信处理过程</strong></p>
<ul>
<li>DLX也是一个正常的Exchange，和一般的Exchange没有区别，它能在任何的队列上被指定，实际上就是设置某个队列的属性。</li>
<li>当这个队列中有死信时，RabbitMQ就会自动的将这个消息重新发布到设置的Exchange上去，进而被路由到另一个队列。</li>
<li>可以监听这个队列中的消息做相应的处理。</li>
</ul>
<p><strong>死信队列设置</strong></p>
<ol>
<li><p>设置死信队列的exchange和queue, 然后进行绑定:</p>
<p>Exchange: dlx.exchange</p>
<p>Queue: dlx.queue </p>
<p>RoutingKey: #</p>
</li>
<li><p>然后正常声明交换机, 队列, 绑定, 只不过需要在队列上加一个参数设置死信交换机:</p>
<p>arguments.put(“x-dead-letter-exchange”, “dlx.exchange”);</p>
</li>
</ol>
<p>如此, ==消息在过期, 无法requeue, 或达到队列最大长度时, 消息可以直接路由到死信队列==</p>
<p><strong>消费端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//普通的交换机和队列以及路由</span></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.order.exchange&quot;</span>;</span><br><span class="line">        String queueName = <span class="string">&quot;test.order.queue&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;order.#&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建exchange</span></span><br><span class="line">        channel.exchangeDeclare(exchangeName, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//-----设置死信队列exchange----</span></span><br><span class="line">        String DLX_exchange = <span class="string">&quot;dlx.exchange&quot;</span>;</span><br><span class="line">        HashMap&lt;String, Object&gt; arguments = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        arguments.put(<span class="string">&quot;x-dead-letter-exchange&quot;</span>, DLX_exchange);</span><br><span class="line">        <span class="comment">//创建一个队列 设置arguments</span></span><br><span class="line">        channel.queueDeclare(queueName, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, arguments);</span><br><span class="line">        <span class="comment">//绑定</span></span><br><span class="line">        channel.queueBind(queueName, exchangeName, routingKey);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//----声明死信队列和exchange并绑定----</span></span><br><span class="line">        String DLX_queue = <span class="string">&quot;dlx.queue&quot;</span>;</span><br><span class="line">        channel.exchangeDeclare(DLX_exchange, <span class="string">&quot;topic&quot;</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueDeclare(DLX_queue, <span class="keyword">true</span>, <span class="keyword">false</span> ,<span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        channel.queueBind(DLX_queue, DLX_exchange, <span class="string">&quot;#&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置consumer autoAck = false</span></span><br><span class="line">        channel.basicConsume(queueName, <span class="keyword">false</span>, <span class="keyword">new</span> MessageConsumer(channel));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageConsumer</span> <span class="keyword">extends</span> <span class="title">DefaultConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//channel</span></span><br><span class="line">        <span class="keyword">private</span> Channel channel;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MessageConsumer</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(channel);</span><br><span class="line">            <span class="keyword">this</span>.channel = channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理消息的逻辑</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>.handleDelivery(consumerTag, envelope, properties, body);</span><br><span class="line">            <span class="comment">//NACK否认答应</span></span><br><span class="line">            channel.basicNack(envelope.getDeliveryTag(), <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;message: &quot;</span> + <span class="keyword">new</span> String(body));</span><br><span class="line">            System.out.println(<span class="string">&quot;DeliveryTag: &quot;</span> + envelope.getDeliveryTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>生产端:</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLXProducer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接工厂,设置连接信息</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        factory.setHost(<span class="string">&quot;192.168.107.132&quot;</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">&quot;/&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="comment">//创建信道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        String exchangeName = <span class="string">&quot;test.order.exchange&quot;</span>;</span><br><span class="line">        String routingKey = <span class="string">&quot;order.save&quot;</span>;</span><br><span class="line"></span><br><span class="line">        String msg = <span class="string">&quot;Hello RabbitMQ DLX Message!&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line"></span><br><span class="line">            AMQP.BasicProperties properties = <span class="keyword">new</span> AMQP.BasicProperties().builder()</span><br><span class="line">                    .deliveryMode(<span class="number">2</span>) <span class="comment">//持久化</span></span><br><span class="line">                    .contentEncoding(<span class="string">&quot;UTF-8&quot;</span>)</span><br><span class="line">                    .expiration(<span class="string">&quot;10000&quot;</span>)  <span class="comment">//过期时间10秒</span></span><br><span class="line">                    .build();</span><br><span class="line">            channel.basicPublish(exchangeName, routingKey, <span class="keyword">true</span>, properties, msg.getBytes());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Spring-Cloud-Stream整合"><a href="#Spring-Cloud-Stream整合" class="headerlink" title="Spring Cloud Stream整合"></a>Spring Cloud Stream整合</h2><p><img src="https://i.loli.net/2020/07/07/MDodcWSTBwZ8bKe.png" alt="img"></p>
<p><strong>屏蔽底层消息中间件的差异，降低切换成本，统一消息的编程模型</strong></p>
<p>Spring Cloud Stream相当于是一个消息的中间代理, 消息的生产与消费, 可以使用不同的消息中间件</p>
<p>Spring Cloud Stream 为 Kafka 和 Rabbit MQ 提供了 Binder 实现</p>
<p><strong>Spring Cloud Stream 中的几个重要概念</strong>:</p>
<ul>
<li><p><em>Destination Binders</em>：目标绑定器，目标指的是 kafka 还是 RabbitMQ，绑定器就是封装了目标中间件的包。如果操作的是 kafka 就使用 kafka binder ，如果操作的是 RabbitMQ 就使用 rabbitmq binder。</p>
</li>
<li><p><em>Destination Bindings</em>：外部消息传递系统和应用程序之间的桥梁，提供消息的“生产者”和“消费者”（由目标绑定器创建）</p>
</li>
<li><p><em>Message</em>：一种规范化的数据结构，生产者和消费者基于这个数据结构通过外部消息系统与目标绑定器和其他应用程序通信。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>组成</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Middleware</td>
<td>中间件,目前只支持RabbitMQ和Kafka</td>
</tr>
<tr>
<td>Binder</td>
<td>Binder是应用与消息中间件之间的封装,可以很方便的连接,动态的改变消息类型</td>
</tr>
<tr>
<td>@Input</td>
<td>表示输入通道,通过该输入通道接收到的消息进入应用程序</td>
</tr>
<tr>
<td>@Output</td>
<td>表示输出通道,发布的消息将通过该通道离开应用程序</td>
</tr>
<tr>
<td>@StreamListener</td>
<td>监听队列,用于消费者队列的消息接收</td>
</tr>
<tr>
<td>@EnableBinding</td>
<td>指信道channel和exchange绑定在一起</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/26/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Redis学习笔记">
      <i class="fa fa-chevron-left"></i> Redis学习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/07/12/Gateway+JWT%E9%89%B4%E6%9D%83/" rel="next" title="Gateway+JWT鉴权">
      Gateway+JWT鉴权 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#RabbitMQ"><span class="nav-number">1.</span> <span class="nav-text">RabbitMQ</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="nav-number">1.1.</span> <span class="nav-text">核心概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%89%E8%A3%85RabbitMQ"><span class="nav-number">1.2.</span> <span class="nav-text">安装RabbitMQ</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8E%E7%AE%A1%E6%8E%A7%E5%8F%B0%E6%93%8D%E4%BD%9C"><span class="nav-number">1.3.</span> <span class="nav-text">命令行与管控台操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8Espringboot%E6%95%B4%E5%90%88"><span class="nav-number">1.4.</span> <span class="nav-text">与springboot整合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E7%94%9F%E4%BA%A7%E8%80%85-amp-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="nav-number">1.5.</span> <span class="nav-text">构建生产者&amp;消费者</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9FAPI"><span class="nav-number">1.5.1.</span> <span class="nav-text">原生API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-boot"><span class="nav-number">1.5.2.</span> <span class="nav-text">spring-boot</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Exchange%E4%BA%A4%E6%8D%A2%E6%9C%BA"><span class="nav-number">1.6.</span> <span class="nav-text">Exchange交换机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Message%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B6%88%E6%81%AF%E5%B1%9E%E6%80%A7"><span class="nav-number">1.7.</span> <span class="nav-text">Message自定义消息属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#AMQP%E4%BA%8B%E5%8A%A1"><span class="nav-number">1.8.</span> <span class="nav-text">AMQP事务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92"><span class="nav-number">1.9.</span> <span class="nav-text">消息可靠性投递</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80"><span class="nav-number">1.9.1.</span> <span class="nav-text">解决方案一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C"><span class="nav-number">1.9.2.</span> <span class="nav-text">解决方案二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF-%E5%86%A5%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="nav-number">1.10.</span> <span class="nav-text">消费端-冥等性保障</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%80-1"><span class="nav-number">1.10.1.</span> <span class="nav-text">解决方案一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%BA%8C-1"><span class="nav-number">1.10.2.</span> <span class="nav-text">解决方案二</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#confirm%E6%B6%88%E6%81%AF%E7%A1%AE%E8%AE%A4%E6%9C%BA%E5%88%B6"><span class="nav-number">1.11.</span> <span class="nav-text">confirm消息确认机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9FAPI-1"><span class="nav-number">1.11.1.</span> <span class="nav-text">原生API</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#spring-boot-1"><span class="nav-number">1.11.2.</span> <span class="nav-text">spring-boot</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#springAMQP"><span class="nav-number">1.12.</span> <span class="nav-text">springAMQP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SimpleMessageListenerContainer"><span class="nav-number">1.12.1.</span> <span class="nav-text">SimpleMessageListenerContainer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MessageListenerAdapter"><span class="nav-number">1.12.2.</span> <span class="nav-text">MessageListenerAdapter</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E6%81%AF%E7%9B%91%E5%90%AC%E5%99%A8%E5%A4%84%E7%90%86Ack"><span class="nav-number">1.13.</span> <span class="nav-text">消息监听器处理Ack</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF%EF%BC%88%E5%B1%80%E9%83%A8%E6%96%B9%E6%B3%95%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%EF%BC%89"><span class="nav-number">1.13.1.</span> <span class="nav-text">确认消息（局部方法处理消息）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%8B%E5%8A%A8%E5%90%A6%E8%AE%A4-%E6%8B%92%E7%BB%9D%E6%B6%88%E6%81%AF"><span class="nav-number">1.13.2.</span> <span class="nav-text">手动否认 拒绝消息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%A1%AE%E8%AE%A4%E6%B6%88%E6%81%AF%EF%BC%88%E5%85%A8%E5%B1%80%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%EF%BC%89"><span class="nav-number">1.13.3.</span> <span class="nav-text">确认消息（全局处理消息）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Return%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6"><span class="nav-number">1.14.</span> <span class="nav-text">Return消息机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AF%E9%99%90%E6%B5%81"><span class="nav-number">1.15.</span> <span class="nav-text">消费端限流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B6%88%E8%B4%B9%E7%AB%AFAck%E4%B8%8E%E9%87%8D%E5%9B%9E%E9%98%9F%E5%88%97"><span class="nav-number">1.16.</span> <span class="nav-text">消费端Ack与重回队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TTL%E6%B6%88%E6%81%AF-%E9%98%9F%E5%88%97"><span class="nav-number">1.17.</span> <span class="nav-text">TTL消息&#x2F;队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#DLX%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.18.</span> <span class="nav-text">DLX死信队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Spring-Cloud-Stream%E6%95%B4%E5%90%88"><span class="nav-number">1.19.</span> <span class="nav-text">Spring Cloud Stream整合</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="hzy"
      src="/uploads/cat.jpg">
  <p class="site-author-name" itemprop="name">hzy</p>
  <div class="site-description" itemprop="description">记录学习的过程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">10</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">12</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/growup-hzy" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;growup-hzy" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/edcfanshzy@163.com" title="E-Mail → edcfanshzy@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hzy</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
